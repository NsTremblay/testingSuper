// Generated by CoffeeScript 1.7.1

/*


 File: superphy.coffee
 Desc: Objects & functions for managing views in Superphy
 Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
 Date: March 7th, 2013
 */

(function() {
  var GenomeController, GroupView, ListView, SuperphyError, ViewController, ViewTemplate, cmp, escapeRegExp, root, trimInput, typeIsArray,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.Superphy || (root.Superphy = {});


  /*
   CLASS SuperphyError
   
   Error object for this library
   */

  SuperphyError = (function(_super) {
    __extends(SuperphyError, _super);

    function SuperphyError(message, name) {
      this.message = message != null ? message : '';
      this.name = name != null ? name : 'Superphy Error';
    }

    return SuperphyError;

  })(Error);


  /*
   CLASS ViewController
    
   Captures events. Updates data and views
   */

  ViewController = (function() {
    function ViewController() {
      if (typeof jQuery === "undefined" || jQuery === null) {
        throw new SuperphyError('jQuery must be loaded before the SuperPhy libary');
      }
      if (typeof URL === "undefined" || URL === null) {
        throw new SuperphyError('SuperPhy library requires the URL library');
      }
      if (typeof Blob === "undefined" || Blob === null) {
        throw new SuperphyError('SuperPhy library requires the Blob library');
      }
    }

    ViewController.prototype.views = [];

    ViewController.prototype.groups = [];

    ViewController.prototype.actionType = false;

    ViewController.prototype.action = false;

    ViewController.prototype.genomeController = void 0;

    ViewController.prototype.init = function(publicGenomes, privateGenomes, actionMode, action) {
      this.actionMode = actionMode;
      this.action = action;
      if (!(this.actionMode === 'single_select' || this.actionMode === 'multi_select' || this.actionMode === 'two_groups')) {
        throw new SuperphyError('Unrecognized actionMode in ViewController init() method.');
      }
      return this.genomeController = new GenomeController(public_genomes, private_genomes);
    };

    ViewController.prototype.createView = function(viewType, elem) {
      var clickStyle, downloadElem, listView, vNum;
      clickStyle = 'select';
      vNum = this.views.length + 1;
      downloadElem = jQuery("<a href='#' data-genome-view='" + vNum + "'>Download</a>");
      downloadElem.click(function(e) {
        var data, viewNum;
        viewNum = parseInt(this.dataset.genomeView);
        data = viewController.downloadViews(viewNum);
        this.href = data.href;
        this.download = data.file;
        return true;
      });
      elem.append(downloadElem);
      if (this.actionMode === 'single_select') {
        clickStyle = 'redirect';
      }
      if (viewType === 'list') {
        listView = new ListView(elem, clickStyle, vNum);
        listView.update(this.genomeController);
        this.views.push(listView);
      } else {
        throw new SuperphyError('Unrecognized viewType in ViewController createView() method.');
        return false;
      }
      return true;
    };

    ViewController.prototype.createGroup = function(boxEl, buttonEl) {
      var gNum, grpView;
      gNum = this.groups.length + 1;
      grpView = new GroupView(boxEl, 'select', gNum);
      grpView.update(this.genomeController);
      this.groups.push(grpView);
      buttonEl.click(function(e) {
        e.preventDefault();
        return viewController.addToGroup(gNum);
      });
      return true;
    };

    ViewController.prototype.select = function(g, checked) {
      this.genomeController.select(g, checked);
      return true;
    };

    ViewController.prototype.redirect = function(g) {
      alert('Genome ' + g + ' redirected!');
      return true;
    };

    ViewController.prototype.addToGroup = function(grp) {
      var i, selected, v, _i, _len, _ref, _results;
      selected = this.genomeController.selected();
      console.log(selected);
      this.genomeController.assignGroup(selected, grp);
      this.genomeController.unselectAll();
      i = grp - 1;
      this.groups[i].add(selected, this.genomeController);
      _ref = this.views;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(v.update(this.genomeController));
      }
      return _results;
    };

    ViewController.prototype.removeFromGroup = function(genomeID, grp) {
      var gset, i, v, _i, _len, _ref;
      console.log('deleting ' + genomeID);
      gset = this.genomeController.genomeSet([genomeID]);
      this.genomeController.deleteGroup(gset);
      i = grp - 1;
      this.groups[i].remove(genomeID);
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.updateCSS(gset, this.genomeController);
      }
      return true;
    };

    ViewController.prototype.updateViews = function(option, checked) {
      var v, _i, _j, _len, _len1, _ref, _ref1;
      this.genomeController.updateMeta(option, checked);
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.update(this.genomeController);
      }
      _ref1 = this.groups;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        v = _ref1[_j];
        v.update(this.genomeController);
      }
      return true;
    };

    ViewController.prototype.downloadViews = function(viewNum) {
      var blob, dump, file, href, url;
      url = window.URL || window.webkitURL;
      blob = window.Blob;
      dump = this.views[viewNum - 1].dump(this.genomeController);
      file = new blob([dump.data], {
        type: dump.type
      });
      href = url.createObjectURL(file);
      file = "superphy_download." + dump.ext;
      return {
        href: href,
        file: file
      };
    };

    ViewController.prototype.metaForm = function(elem) {
      var form;
      form = '<div style="display:inline-block;">' + '<button type="button" class="btn btn-mini btn-info" data-toggle="collapse" data-target="#meta-display">' + '<i class=" icon-eye-open icon-white"></i>' + '<span class="caret"></span>' + '</button>' + '<div id="meta-display" class="collapse out">' + '<div style="padding:10px;">Change meta-data displayed:</div>' + '<form class="form-horizontal">' + '<fieldset>' + '<label><input class="meta-option" type="checkbox" name="meta-option" value="accession"> Accession # </label>' + '<label><input class="meta-option" type="checkbox" name="meta-option" value="strain"> Strain </label>' + '<label><input class="meta-option" type="checkbox" name="meta-option" value="serotype"> Serotype </label>' + '<label><input class="meta-option" type="checkbox" name="meta-option" value="isolation_host"> Isolation Host </label>' + '<label><input class="meta-option" type="checkbox" name="meta-option" value="isolation_source"> Isolation Source </label>' + '<label><input class="meta-option" type="checkbox" name="meta-option" value="isolation_date"> Isolation Date </label>' + '</fieldset>' + '</form>' + '</div>' + '</div>' + '</div>';
      elem.append(form);
      jQuery('input[name="meta-option"]').change(function() {
        return viewController.updateViews(this.value, this.checked);
      });
      return true;
    };

    ViewController.prototype.filterViews = function(filterForm) {
      var searchTerms, term, v, _i, _len, _ref;
      searchTerms = null;
      if (filterForm === 'fast') {
        term = jQuery("#fast-filter > input").val().toLowerCase();
        if ((term != null) && term.length) {
          searchTerms = [];
          searchTerms.push({
            searchTerm: term,
            dataField: 'displayname',
            negate: false
          });
        }
      } else {
        searchTerms = this._parseFilterForm();
      }
      this.genomeController.filter(searchTerms);
      this._toggleFilterStatus();
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.update(this.genomeController);
      }
      return true;
    };

    ViewController.prototype.resetFilter = function() {
      var v, _i, _len, _ref, _results;
      this.genomeController.filter();
      this._toggleFilterStatus();
      this._clearFilterForm();
      _ref = this.views;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(v.update(this.genomeController));
      }
      return _results;
    };

    ViewController.prototype.filterForm = function(elem) {
      var advForm, advLab, advRadio, delFilterButton, fastLab, fastRadio, filtType, filterOff, filterOn, filterStatus, isFiltered, sf;
      filtType = jQuery('<div id="select-filter-form"></div>');
      fastLab = jQuery('<label class="radio">Basic</label>');
      fastRadio = jQuery('<input type="radio" name="filter-form-type" value="fast" checked>');
      fastRadio.change(function(e) {
        if (this.checked != null) {
          jQuery("#fast-filter").show();
          jQuery("#adv-filter").hide();
        }
        return true;
      });
      fastLab.append(fastRadio);
      filtType.append(fastLab);
      advLab = jQuery('<label class="radio">Advanced</label>');
      advRadio = jQuery('<input type="radio" name="filter-form-type" value="advanced">');
      advRadio.change(function(e) {
        if (this.checked != null) {
          jQuery("#fast-filter").hide();
          jQuery("#adv-filter").show();
        }
        return true;
      });
      advLab.append(advRadio);
      filtType.append(advLab);
      elem.append(filtType);
      isFiltered = this.genomeController.filtered;
      filterStatus = jQuery('<div id="filter-status"></div>');
      filterOn = jQuery('<div id="filter-on">...Filter applied</div>');
      filterOff = jQuery('<div id="filter-off"></div>');
      delFilterButton = jQuery('<button id="remove-filter" type="button">Clear</button>');
      delFilterButton.click(function(e) {
        e.preventDefault();
        return viewController.resetFilter();
      });
      filterOn.append(delFilterButton);
      if (isFiltered) {
        filterOn.show();
        filterOff.hide();
      } else {
        filterOn.hide();
        filterOff.show();
      }
      filterStatus.append(filterOn);
      filterStatus.append(filterOff);
      elem.append(filterStatus);
      sf = jQuery("<div id='fast-filter'></div>");
      this.addFastFilter(sf);
      elem.append(sf);
      advForm = jQuery("<div id='adv-filter'></div>");
      this.addAdvancedFilter(advForm);
      advForm.hide();
      elem.append(advForm);
      return true;
    };

    ViewController.prototype._toggleFilterStatus = function() {
      var filterOff, filterOn, isFiltered;
      isFiltered = this.genomeController.filtered;
      filterOn = jQuery('#filter-on');
      filterOff = jQuery('#filter-off');
      if (isFiltered) {
        filterOn.show();
        filterOff.hide();
      } else {
        filterOn.hide();
        filterOff.show();
      }
      return true;
    };

    ViewController.prototype._clearFilterForm = function() {
      var advForm, sf;
      sf = jQuery("#fast-filter");
      sf.empty();
      this.addFastFilter(sf);
      advForm = jQuery("#adv-filter");
      advForm.empty();
      this.addAdvancedFilter(advForm);
      return true;
    };

    ViewController.prototype.addAdvancedFilter = function(elem) {
      var addRow, advButton, advRows;
      advRows = jQuery("<div id='adv-filter-rows'></div>");
      elem.append(advRows);
      this.addFilterRow(advRows, 1);
      advButton = jQuery('<button id="adv-filter-submit" type="button">Filter</button>');
      elem.append(advButton);
      advButton.click(function(e) {
        e.preventDefault;
        return viewController.filterViews('advanced');
      });
      addRow = jQuery('<a href="#" class="adv-filter-addition">Add term</a>');
      addRow.click(function(e) {
        var rowI, rows;
        e.preventDefault();
        rows = jQuery('.adv-filter-row');
        rowI = rows.length + 1;
        return viewController.addFilterRow(jQuery('#adv-filter-rows'), rowI);
      });
      elem.append(addRow);
      return true;
    };

    ViewController.prototype.addFilterRow = function(elem, rowNum) {
      var delRow, dropDown, dt, k, keyw, row, v, _ref;
      row = jQuery('<div class="adv-filter-row" data-filter-row="' + rowNum + '"></div>').appendTo(elem);
      if (rowNum !== 1) {
        jQuery('<select name="adv-filter-op" data-filter-row="' + rowNum + '">' + '<option value="and" selected="selected">AND</option>' + '<option value="or">OR</option>' + '<option value="not">NOT</option>' + '</select>').appendTo(row);
      }
      dropDown = jQuery('<select name="adv-filter-field" data-filter-row="' + rowNum + '"></select>').appendTo(row);
      _ref = this.genomeController.metaMap;
      for (k in _ref) {
        v = _ref[k];
        dropDown.append('<option value="' + k + '">' + v + '</option>');
      }
      dropDown.append('<option value="displayname" selected="selected">Genome name</option>');
      dropDown.change(function() {
        var thisRow;
        thisRow = this.dataset.filterRow;
        if (this.value === 'isolation_date') {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').show();
        } else {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').show();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
        }
        return true;
      });
      keyw = jQuery('<div class="adv-filter-keyword" data-filter-row="' + rowNum + '"></div>)');
      jQuery('<input type="text" name="adv-filter-term" data-filter-row="' + rowNum + '" placeholder="Keyword"></input>').appendTo(keyw);
      keyw.appendTo(row);
      dt = jQuery('<div class="adv-filter-date" data-filter-row="' + rowNum + '"></div>)');
      dt.append('<select name="adv-filter-before" data-filter-row="' + rowNum + '">' + '<option value="before" selected="selected">before</option>' + '<option value="after">after</option>' + '</select>');
      dt.append('<input type="text" name="adv-filter-year" data-filter-row="' + rowNum + '" placeholder="YYYY"></input>');
      dt.append('<input type="text" name="adv-filter-mon" data-filter-row="' + rowNum + '" placeholder="MM"></input>');
      dt.append('<input type="text" name="adv-filter-day" data-filter-row="' + rowNum + '" placeholder="DD"></input>');
      dt.hide();
      dt.appendTo(row);
      if (rowNum !== 1) {
        delRow = jQuery('<a href="#" class="adv-filter-subtraction" data-filter-row="' + rowNum + '">Remove term</a>');
        delRow.appendTo(row);
        delRow.click(function(e) {
          var thisRow;
          e.preventDefault();
          thisRow = this.dataset.filterRow;
          return jQuery('.adv-filter-row[data-filter-row="' + thisRow + '"]').remove();
        });
      }
      return true;
    };

    ViewController.prototype.addFastFilter = function(elem) {
      var fastButton, tBox;
      tBox = jQuery('<input type="text" name="fast-filter-term" placeholder="Filter by..."></input>');
      fastButton = jQuery('<button id="fast-filter-submit" type="button">Filter</button>');
      fastButton.click(function(e) {
        e.preventDefault;
        return viewController.filterViews('fast');
      });
      tBox.appendTo(elem);
      fastButton.appendTo(elem);
      return true;
    };

    ViewController.prototype._parseFilterForm = function() {
      var bef, date, df, dy, isBefore, isDate, mn, negate, op, row, rowNum, rows, searchTerms, t, term, yr, _i, _len;
      rows = jQuery('.adv-filter-row');
      searchTerms = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        t = {};
        rowNum = parseInt(row.dataset.filterRow);
        df = jQuery("[name='adv-filter-field'][data-filter-row='" + rowNum + "']").val();
        t.dataField = df;
        isDate = false;
        if (df === 'isolation_date') {
          isDate = true;
        }
        if (!isDate) {
          term = jQuery("[name='adv-filter-term'][data-filter-row='" + rowNum + "']").val();
          term = trimInput(term, 'keyword');
          if (term == null) {
            return null;
          }
          t.searchTerm = term;
        } else {
          bef = jQuery("[name='adv-filter-before'][data-filter-row='" + rowNum + "']").val();
          if (!(bef === 'before' || bef === 'after')) {
            throw new SuperphyError('Invalid input in advanced filter form. Element "adv-filter-before" must contain strings "before","after".');
          }
          isBefore = true;
          if (bef === 'after') {
            isBefore = false;
          }
          yr = jQuery("[name='adv-filter-year'][data-filter-row='" + rowNum + "']").val();
          yr = trimInput(yr, 'Year');
          if (yr == null) {
            return null;
          }
          if (!/^[1-9][0-9]{3}$/.test(yr)) {
            alert('Error: invalid Year.');
            return null;
          }
          mn = jQuery("[name='adv-filter-mon'][data-filter-row='" + rowNum + "']").val();
          if (mn != null) {
            mn = jQuery.trim(mn);
          }
          if ((mn != null) && mn.length) {
            if (!/^[0-9]{1,2}$/.test(mn)) {
              alert('Error: invalid Month.');
              return null;
            }
          } else {
            mn = '01';
          }
          dy = jQuery("[name='adv-filter-day'][data-filter-row='" + rowNum + "']").val();
          if (dy != null) {
            dy = jQuery.trim(dy);
          }
          if ((dy != null) && dy.length) {
            if (!/^[0-9]{1,2}$/.test(dy)) {
              alert('Error: invalid Day.');
              return null;
            }
          } else {
            dy = '01';
          }
          date = Date.parse("" + yr + "-" + mn + "-" + dy);
          if (isNaN(date)) {
            alert('Error: invalid date.');
            return null;
          }
          t.date = date;
          t.before = isBefore;
        }
        if (rowNum !== 1) {
          op = jQuery("[name='adv-filter-op'][data-filter-row='" + rowNum + "']").val();
          negate = false;
          if (!(op === 'or' || op === 'and' || op === 'not')) {
            throw new SuperphyError('Invalid input in advanced filter form. Element "adv-filter-op" must contain strings "and","or","not".');
          }
          if (op === 'not') {
            op = 'and';
            negate = true;
          }
          t.op = op;
          t.negate = negate;
          searchTerms.push(t);
        } else {
          t.negate = false;
          searchTerms.unshift(t);
        }
      }
      return searchTerms;
    };

    return ViewController;

  })();

  if (!root.ViewController) {
    root.viewController = new ViewController;
  }


  /*
   CLASS ViewTemplate
   
   Template object for views. Defines required and
   common properties/methods. All view objects
   are descendants of the ViewTemplate.
   */

  ViewTemplate = (function() {
    function ViewTemplate(parentElem, style, elNum) {
      this.parentElem = parentElem;
      this.style = style != null ? style : 'select';
      this.elNum = elNum != null ? elNum : 1;
      this.elID = this.elName + this.elNum;
    }

    ViewTemplate.prototype.type = void 0;

    ViewTemplate.prototype.elNum = 1;

    ViewTemplate.prototype.elName = 'view';

    ViewTemplate.prototype.elID = void 0;

    ViewTemplate.prototype.parentElem = void 0;

    ViewTemplate.prototype.style = 'select';

    ViewTemplate.prototype.update = function(genomes) {
      throw new SuperphyError("ViewTemplate method update() must be defined in child class.");
      return false;
    };

    ViewTemplate.prototype.dump = function(genomes) {
      throw new SuperphyError("ViewTemplate method print() must be defined in child class.");
      return false;
    };

    ViewTemplate.prototype.cssClass = function() {
      return this.elName + '_item';
    };

    return ViewTemplate;

  })();


  /*
   CLASS ListView
   
   Genome list
   */

  ListView = (function(_super) {
    __extends(ListView, _super);

    function ListView() {
      return ListView.__super__.constructor.apply(this, arguments);
    }

    ListView.prototype.type = 'list';

    ListView.prototype.elName = 'genome_list';

    ListView.prototype.update = function(genomes) {
      var ft, listElem, t1, t2;
      listElem = jQuery("#" + this.elID);
      if (listElem.length) {
        listElem.empty();
      } else {
        listElem = jQuery("<ul id='" + this.elID + "'/>");
        jQuery(this.parentElem).append(listElem);
      }
      t1 = new Date();
      this._appendGenomes(listElem, genomes.pubVisible, genomes.public_genomes, this.style);
      listElem.append(function() {
        return "<li class='genome_list_spacer'>---- USER-SUBMITTED GENOMES ----</li>";
      });
      this._appendGenomes(listElem, genomes.pvtVisible, genomes.private_genomes, this.style);
      t2 = new Date();
      ft = t2 - t1;
      console.log('elapsed time: ' + ft);
      return true;
    };

    ListView.prototype._appendGenomes = function(el, visibleG, genomes, style) {
      var actionEl, checked, cls, g, labEl, listEl, thiscls, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        if (style === 'redirect') {
          listEl = jQuery(("<li class='" + thiscls + "'>") + genomes[g].viewname + '</li>');
          actionEl = jQuery("<a href='#' data-genome='" + g + "'><i class='icon-search'></i> info</a>");
          actionEl.click(function(e) {
            var gid;
            e.preventDefault();
            gid = this.dataset.genome;
            return viewController.redirect(gid);
          });
          listEl.append(actionEl);
          el.append(listEl);
        } else if (style === 'select') {
          checked = '';
          if (genomes[g].isSelected) {
            checked = 'checked';
          }
          listEl = jQuery("<li class='" + thiscls + "'></li>");
          labEl = jQuery("<label class='checkbox'>" + genomes[g].viewname + "</label>");
          actionEl = jQuery("<input class='checkbox' type='checkbox' value='" + g + "' " + checked + "/>");
          actionEl.change(function(e) {
            e.preventDefault();
            return viewController.select(this.value, this.checked);
          });
          labEl.append(actionEl);
          listEl.append(labEl);
          el.append(listEl);
        } else {
          return false;
        }
      }
      return true;
    };

    ListView.prototype.updateCSS = function(gset, genomes) {
      var ft, listEl, t1, t2;
      listEl = jQuery("#" + this.elID);
      if (!((listEl != null) && listEl.length)) {
        throw new SuperphyError("DOM element for list view " + this.elID + " not found. Cannot call ListView method updateCSS().");
      }
      t1 = new Date();
      if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
        this._updateGenomeCSS(listEl, gset["public"], genomes.public_genomes);
      }
      if ((gset["private"] != null) && typeof gset["private"] !== 'undefined') {
        this._updateGenomeCSS(listEl, gset["private"], genomes.private_genomes);
      }
      t2 = new Date();
      ft = t2 - t1;
      console.log('elapsed time: ' + ft);
      return true;
    };

    ListView.prototype._updateGenomeCSS = function(el, changedG, genomes) {
      var cls, descriptor, g, itemEl, liEl, thiscls, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = changedG.length; _i < _len; _i++) {
        g = changedG[_i];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        itemEl = null;
        if (this.style === 'redirect') {
          descriptor = "li > a[data-genome='" + g + "']";
          itemEl = el.find(descriptor);
        } else if (this.style === 'select') {
          descriptor = "li input[value='" + g + "']";
          itemEl = el.find(descriptor);
        } else {
          return false;
        }
        if (!((itemEl != null) && itemEl.length)) {
          throw new SuperphyError("List element for genome " + g + " not found in ListView " + this.elID);
          return false;
        }
        console.log("Updating class to " + thiscls);
        liEl = itemEl.parents().eq(1);
        liEl.attr('class', thiscls);
      }
      return true;
    };

    ListView.prototype.dump = function(genomes) {
      var fullMeta, g, header, id, k, output, _ref, _ref1;
      fullMeta = {};
      for (k in genomes.visibleMeta) {
        fullMeta[k] = true;
      }
      output = '';
      header = (function() {
        var _results;
        _results = [];
        for (k in fullMeta) {
          _results.push(genomes.metaMap[k]);
        }
        return _results;
      })();
      header.unshift("Genome name");
      output += "#" + header.join("\t") + "\n";
      _ref = genomes.public_genomes;
      for (id in _ref) {
        g = _ref[id];
        output += genomes.label(g, fullMeta, "\t") + "\n";
      }
      _ref1 = genomes.private_genomes;
      for (id in _ref1) {
        g = _ref1[id];
        output += genomes.label(g, fullMeta, "\t") + "\n";
      }
      return {
        ext: 'csv',
        type: 'text/plain',
        data: output
      };
    };

    return ListView;

  })(ViewTemplate);


  /*
   CLASS GroupView
   
   A special type of genome list that is used to temporarily store the user's
   selected genomes.
   
   Only one 'style' which provides a remove button to remove group from group.
   Will be updated by changes to the meta-display options but not by filtering.
   */

  GroupView = (function(_super) {
    __extends(GroupView, _super);

    function GroupView() {
      return GroupView.__super__.constructor.apply(this, arguments);
    }

    GroupView.prototype.type = 'group';

    GroupView.prototype.elName = 'group';

    GroupView.prototype.update = function(genomes) {
      var ingrp, listElem;
      listElem = jQuery("#" + this.elID);
      if (listElem.length) {
        listElem.empty();
      } else {
        listElem = jQuery("<ul id='" + this.elID + "'/>");
        jQuery(this.parentElem).append(listElem);
      }
      ingrp = genomes.grouped(this.elNum);
      this._appendGenomes(listElem, ingrp["public"], genomes.public_genomes);
      this._appendGenomes(listElem, ingrp["private"], genomes.private_genomes);
      return true;
    };

    GroupView.prototype.add = function(genomeSet, genomes) {
      var listElem;
      listElem = jQuery("#" + this.elID);
      if (!listElem.length) {
        listElem = jQuery("<ul id='" + this.elID + "'/>");
        jQuery(this.parentElem).append(listElem);
      }
      if (genomeSet["public"] != null) {
        this._appendGenomes(listElem, genomeSet["public"], genomes.public_genomes);
      }
      if (genomeSet["private"] != null) {
        return this._appendGenomes(listElem, genomeSet["private"], genomes.private_genomes);
      }
    };

    GroupView.prototype._appendGenomes = function(el, visibleG, genomes) {
      var actionEl, cls, g, listEl, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        listEl = jQuery(("<li class='" + cls + "'>") + genomes[g].viewname + '</li>');
        actionEl = jQuery("<a href='#' data-genome='" + g + "' data-genome-group='" + this.elNum + "'> remove</a>");
        actionEl.click(function(e) {
          var gid, grp;
          e.preventDefault();
          gid = this.dataset.genome;
          grp = this.dataset.genomeGroup;
          console.log('clicked remove on ' + gid);
          return viewController.removeFromGroup(gid, grp);
        });
        listEl.append(actionEl);
        el.append(listEl);
      }
      return true;
    };

    GroupView.prototype.remove = function(gid) {
      var descriptor, linkEl, listEl;
      listEl = jQuery("#" + this.elID);
      if (!((listEl != null) && listEl.length)) {
        throw new SuperphyError("DOM element for group view " + this.elID + " not found. Cannot call GroupView method remove().");
      }
      descriptor = "li > a[data-genome='" + gid + "']";
      linkEl = listEl.find(descriptor);
      if (!((linkEl != null) && linkEl.length)) {
        throw new SuperphyError("List item element for genome " + gid + " not found in GroupView " + this.elID);
        return false;
      }
      linkEl.parent('li').remove();
      return true;
    };

    return GroupView;

  })(ViewTemplate);


  /*
   CLASS GenomeController
   
   Manages private/public genome list
   */

  GenomeController = (function() {
    function GenomeController(public_genomes, private_genomes) {
      this.public_genomes = public_genomes;
      this.private_genomes = private_genomes;
      this.update();
      this.filter();
    }

    GenomeController.prototype.pubVisible = [];

    GenomeController.prototype.pvtVisible = [];

    GenomeController.prototype.visibleMeta = {
      strain: false,
      serotype: false,
      isolation_host: false,
      isolation_source: false,
      isolation_date: false,
      accession: false
    };

    GenomeController.prototype.metaMap = {
      'strain': 'Strain',
      'serotype': 'Serotype',
      'isolation_host': 'Host',
      'isolation_source': 'Source',
      'isolation_date': 'Date of isolation',
      'accession': 'Accession ID'
    };

    GenomeController.prototype.publicRegexp = new RegExp('^public_');

    GenomeController.prototype.privateRegexp = new RegExp('^private_');

    GenomeController.prototype.filtered = false;

    GenomeController.prototype.update = function() {
      var g, id, _ref, _ref1;
      _ref = this.public_genomes;
      for (id in _ref) {
        g = _ref[id];
        g.viewname = this.label(g, this.visibleMeta);
      }
      _ref1 = this.private_genomes;
      for (id in _ref1) {
        g = _ref1[id];
        g.viewname = this.label(g, this.visibleMeta);
      }
      return true;
    };

    GenomeController.prototype.filter = function(searchTerms) {
      var pubGenomeIds, pvtGenomeIds, results;
      if (searchTerms == null) {
        searchTerms = null;
      }
      pubGenomeIds = [];
      pvtGenomeIds = [];
      if (searchTerms != null) {
        results = this._runFilter(searchTerms);
        pubGenomeIds = results["public"];
        pvtGenomeIds = results["private"];
        this.filtered = true;
      } else {
        pubGenomeIds = Object.keys(this.public_genomes);
        pvtGenomeIds = Object.keys(this.private_genomes);
        this.filtered = false;
      }
      this.pubVisible = pubGenomeIds.sort(function(a, b) {
        return cmp(this.public_genomes[a].viewname, this.public_genomes[b].viewname);
      });
      this.pvtVisible = pvtGenomeIds.sort(function(a, b) {
        return cmp(this.private_genomes[a].viewname, this.private_genomes[b].viewname);
      });
      return true;
    };

    GenomeController.prototype._runFilter = function(searchTerms) {
      var firstTerm, id, pubGenomeIds, pubSet, pvtGenomeIds, pvtSet, regex, t, _i, _len;
      if (!typeIsArray(searchTerms)) {
        throw new SuperphyError('Invalid argument. GenomeController method _runFilter() requires array of search term objects as input.');
      }
      pubGenomeIds = Object.keys(this.public_genomes);
      pvtGenomeIds = Object.keys(this.private_genomes);
      firstTerm = true;
      for (_i = 0, _len = searchTerms.length; _i < _len; _i++) {
        t = searchTerms[_i];
        console.log(t);
        if (firstTerm) {
          if (t.op != null) {
            throw new SuperphyError("Invalid filter input. First search term object cannot contain an operator property 'op'.");
          }
          if (t.dataField !== 'isolation_date') {
            if (t.searchTerm == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'searchTerm' property.");
            }
            if (t.dataField == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'dataField' property.");
            }
            if (t.negate == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'negate' property.");
            }
          } else {
            if (t.dataField == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'searchTerm' property.");
            }
            if (t.date == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'date' property.");
            }
            if (t.before == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'before' property.");
            }
          }
          firstTerm = false;
        } else {
          if (t.op == null) {
            throw new SuperphyError("Invalid filter input. Subsequent search term objects must contain an operator property 'op'.");
          }
        }
        if ((t.op != null) && t.op === 'or') {
          pubSet = [];
          pubSet = [];
          if (t.dataField === 'isolation_date') {
            pubSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.public_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.passDate(this.public_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.private_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.passDate(this.private_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
          } else {
            regex = new RegExp(escapeRegExp(t.searchTerm), "i");
            pubSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.public_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.match(this.public_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.private_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.match(this.private_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
          }
          pubGenomeIds = this.union(pubGenomeIds, pubSet);
          pvtGenomeIds = this.union(pvtGenomeIds, pvtSet);
        } else {
          if (t.dataField === 'isolation_date') {
            pubSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pubGenomeIds.length; _j < _len1; _j++) {
                id = pubGenomeIds[_j];
                if (this.passDate(this.public_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
                id = pvtGenomeIds[_j];
                if (this.passDate(this.private_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pubGenomeIds = pubSet;
            pvtGenomeIds = pvtSet;
          } else {
            regex = new RegExp(escapeRegExp(t.searchTerm), "i");
            pubSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pubGenomeIds.length; _j < _len1; _j++) {
                id = pubGenomeIds[_j];
                if (this.match(this.public_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
                id = pvtGenomeIds[_j];
                if (this.match(this.private_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pubGenomeIds = pubSet;
            pvtGenomeIds = pvtSet;
          }
        }
      }
      return {
        "public": pubGenomeIds,
        "private": pvtGenomeIds
      };
    };

    GenomeController.prototype.match = function(genome, key, regex, negate) {
      var val;
      if (genome[key] == null) {
        return false;
      }
      val = genome[key];
      if (typeIsArray(genome[key])) {
        val = genome[key].toString();
      }
      if (regex.test(val)) {
        if (!negate) {
          return true;
        } else {
          return false;
        }
      } else {
        if (negate) {
          return true;
        } else {
          return false;
        }
      }
    };

    GenomeController.prototype.passDate = function(genome, before, date) {
      var d2, val;
      if (genome['isolation_date'] == null) {
        return false;
      }
      val = genome['isolation_date'][0];
      d2 = Date.parse(val);
      if (before) {
        if (d2 < date) {
          return true;
        } else {
          return false;
        }
      } else {
        if (d2 > date) {
          return true;
        } else {
          return false;
        }
      }
    };

    GenomeController.prototype.union = function(arr1, arr2) {
      var arr, i, _i, _len, _ref;
      arr = [];
      _ref = arr1.concat(arr2);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (__indexOf.call(arr, i) < 0) {
          arr.push(i);
        }
      }
      return arr;
    };

    GenomeController.prototype.label = function(genome, visibleMeta, joinStr) {
      var lab, mtypes, na, t, _i, _len, _ref, _ref1;
      if (joinStr == null) {
        joinStr = '|';
      }
      na = 'NA';
      lab = [genome.displayname];
      mtypes = ['strain', 'serotype', 'isolation_host', 'isolation_source', 'isolation_date'];
      for (_i = 0, _len = mtypes.length; _i < _len; _i++) {
        t = mtypes[_i];
        if (visibleMeta[t]) {
          lab.push(((_ref = genome[t]) != null ? _ref : [na]).join(' '));
        }
      }
      if (visibleMeta.accession) {
        lab.push((_ref1 = genome.primary_dbxref) != null ? _ref1 : na);
      }
      return lab.join(joinStr);
    };

    GenomeController.prototype.updateMeta = function(option, checked) {
      if (this.visibleMeta[option] == null) {
        throw new SuperphyError('unrecognized option in GenomeController method updateVisibleMeta()');
        return false;
      }
      if (!(checked === true || checked === false)) {
        throw new SuperphyError('invalid checked argument in GenomeController method updateVisibleMeta()');
        return false;
      }
      this.visibleMeta[option] = checked;
      this.update();
      return true;
    };

    GenomeController.prototype.select = function(g, checked) {
      if (this.publicRegexp.test(g)) {
        this.public_genomes[g].isSelected = checked;
        alert('selected public: ' + g + ' value:' + checked);
      } else {
        this.private_genomes[g].isSelected = checked;
        alert('selected private: ' + g + ' value:' + checked);
      }
      return true;
    };

    GenomeController.prototype.selected = function() {
      var k, pub, pvt, v;
      pub = [];
      pvt = [];
      pub = (function() {
        var _ref, _results;
        _ref = this.public_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.isSelected != null) && v.isSelected === true) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      pvt = (function() {
        var _ref, _results;
        _ref = this.private_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.isSelected != null) && v.isSelected === true) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    GenomeController.prototype.unselectAll = function() {
      var k, v, _ref, _ref1, _results;
      _ref = this.public_genomes;
      for (k in _ref) {
        v = _ref[k];
        if (v.isSelected != null) {
          v.isSelected = false;
        }
      }
      _ref1 = this.private_genomes;
      _results = [];
      for (k in _ref1) {
        v = _ref1[k];
        if (v.isSelected != null) {
          _results.push(v.isSelected = false);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    GenomeController.prototype.assignGroup = function(gset, grpNum) {
      var cls, g, _i, _j, _len, _len1, _ref, _ref1;
      if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
        _ref = gset["public"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          this.public_genomes[g].assignedGroup = grpNum;
          cls = 'genome_group' + grpNum;
          this.public_genomes[g].cssClass = cls;
        }
      }
      if ((gset["private"] != null) && typeof gset["private"] !== 'undefined') {
        _ref1 = gset["private"];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          this.private_genomes[g].assignedGroup = grpNum;
          cls = 'genome_group' + grpNum;
          this.private_genomes[g].cssClass = cls;
        }
      }
      return true;
    };

    GenomeController.prototype.deleteGroup = function(gset) {
      var g, _i, _j, _len, _len1, _ref, _ref1;
      if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
        _ref = gset["public"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          this.public_genomes[g].assignedGroup = null;
          this.public_genomes[g].cssClass = null;
        }
      }
      if ((gset["private"] != null) && typeof gset["public"] !== 'undefined') {
        _ref1 = gset["private"];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          this.private_genomes[g].assignedGroup = null;
          this.private_genomes[g].cssClass = null;
        }
      }
      return true;
    };

    GenomeController.prototype.grouped = function(grpNum) {
      var k, pub, pvt, v;
      pub = [];
      pvt = [];
      pub = (function() {
        var _ref, _results;
        _ref = this.public_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.assignedGroup != null) && v.assignedGroup === grpNum) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      pvt = (function() {
        var _ref, _results;
        _ref = this.private_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.assignedGroup != null) && v.assignedGroup === grpNum) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    GenomeController.prototype.genomeSet = function(gids) {
      var g, pub, pvt;
      pub = [];
      pvt = [];
      pub = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = gids.length; _i < _len; _i++) {
          g = gids[_i];
          if (this.publicRegexp.test(g)) {
            _results.push(g);
          }
        }
        return _results;
      }).call(this);
      pvt = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = gids.length; _i < _len; _i++) {
          g = gids[_i];
          if (this.privateRegexp.test(g)) {
            _results.push(g);
          }
        }
        return _results;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    return GenomeController;

  })();


  /*
  
    HELPER FUNCTIONS
   */

  typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  escapeRegExp = function(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  cmp = function(a, b) {
    if (a > b) {
      return 1;
    } else if (a < b) {
      return -1;
    } else {
      return 0;
    }
  };

  trimInput = function(str, field) {
    var term;
    if (str != null) {
      term = jQuery.trim(str);
      if (term.length) {
        return term;
      } else {
        alert("Error: " + field + " is empty.");
        return null;
      }
    } else {
      alert("Error: " + field + " is empty.");
      return null;
    }
  };

}).call(this);
