// Generated by CoffeeScript 1.7.1

/*
 File: superphy.coffee
 Desc: Objects & functions for managing views in Superphy
 Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
 Date: March 7th, 2013
 */

(function() {
  var GenomeController, ListView, ViewController, ViewTemplate, escapeRegExp, root, typeIsArray,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.Superphy || (root.Superphy = {});


  /*
   ViewController
    
   Captures events. Updates data and views
   */

  ViewController = (function() {
    function ViewController() {
      if (typeof jQuery === "undefined" || jQuery === null) {
        alert('Error: jQuery must be loaded before this libary');
      }
    }

    return ViewController;

  })();

  if (!root.ViewController) {
    root.ViewController = ViewController;
  }


  /*
   ViewTemplate
   
   Genome list
   */

  ViewTemplate = (function() {
    function ViewTemplate() {}

    ViewTemplate.prototype.update = function(elem, genomes) {
      return alert("Error: update() must be defined in child class.");
    };

    return ViewTemplate;

  })();


  /*
   ListView
   
   Genome list
   */

  ListView = (function(_super) {
    __extends(ListView, _super);

    function ListView() {
      return ListView.__super__.constructor.apply(this, arguments);
    }

    ListView.prototype.update = function(elem, gc) {
      return jQuery(elem).append(function() {
        return '<p>HELLO</p>';
      });
    };

    return ListView;

  })(ViewTemplate);

  if (!root.ListView) {
    root.ListView = ListView;
  }


  /*
   GenomeController
   
   Manages private/public genome list
   */

  GenomeController = (function() {
    function GenomeController(public_genomes, private_genomes) {
      this.public_genomes = public_genomes;
      this.private_genomes = private_genomes;
      this.update();
    }

    GenomeController.prototype.pubVisable = [];

    GenomeController.prototype.pvtVisable = [];

    GenomeController.prototype.visibleMeta = {
      strain: false,
      serotype: false,
      isolation_host: false,
      isolation_source: false,
      isolation_date: false,
      accession: false
    };

    GenomeController.prototype.update = function() {
      var g, id, _ref, _results;
      _ref = this.public_genomes;
      _results = [];
      for (id in _ref) {
        g = _ref[id];
        _results.push(g.viewname = this.label(g, this.visibleMeta));
      }
      return _results;
    };

    GenomeController.prototype.filter = function(searchTerm, dataType, negate) {
      var id, pubGenomeIds, pvtGenomeIds, regex;
      if (searchTerm == null) {
        searchTerm = false;
      }
      if (dataType == null) {
        dataType = 'displayname';
      }
      if (negate == null) {
        negate = false;
      }
      pubGenomeIds = [];
      pvtGenomeIds = [];
      if (searchTerm) {
        regex = new RegExp(escapeRegExp(searchTerm), "i");
        pubGenomeIds = (function() {
          var _i, _len, _ref, _results;
          _ref = Object.keys(this.public_genomes);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            id = _ref[_i];
            if (this.match(this.public_genomes[id], dataType, regex, negate)) {
              _results.push(id);
            }
          }
          return _results;
        }).call(this);
      } else {
        pubGenomeIds = Object.keys(this.public_genomes);
        pvtGenomeIds = Object.keys(this.private_genomes);
      }
      this.pubVisable = pubGenomeIds.sort(function(a, b) {
        return this.public_genomes[b].viewname - this.public_genomes[a].viewname;
      });
      return this.pvtVisable = pvtGenomeIds.sort(function(a, b) {
        return this.private_genomes[b].viewname - this.private_genomes[a].viewname;
      });
    };

    GenomeController.prototype.match = function(genome, key, regex, negate) {
      var val;
      if (genome[key] == null) {
        return false;
      }
      val = genome[key];
      if (typeIsArray(genome[key])) {
        val = genome[key].toString;
      }
      if (regex.test(val)) {
        if (!negate) {
          console.log('passed');
          return true;
        } else {
          return false;
        }
      } else {
        if (negate) {
          return true;
        } else {
          console.log('failed');
          return false;
        }
      }
    };

    GenomeController.prototype.label = function(genome, visibleMeta) {
      var lab, mtypes, na, t, _i, _len, _ref, _ref1;
      na = 'NA';
      lab = [genome.displayname];
      mtypes = ['strain', 'serotype', 'isolation_host', 'isolation_source', 'isolation_date'];
      for (_i = 0, _len = mtypes.length; _i < _len; _i++) {
        t = mtypes[_i];
        if (visibleMeta[t]) {
          lab.push(((_ref = genome[t]) != null ? _ref : [na]).join(' '));
        }
      }
      if (visibleMeta.accession) {
        lab.push((_ref1 = genome.primary_dbxref) != null ? _ref1 : na);
      }
      return lab.join('|');
    };

    return GenomeController;

  })();

  if (!root.GenomeController) {
    root.GenomeController = GenomeController;
  }

  typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  escapeRegExp = function(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

}).call(this);
