// Generated by CoffeeScript 1.7.1

/*


 File: superphy.coffee
 Desc: Objects & functions for managing views in Superphy
 Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
 Date: March 7th, 2013
 */

(function() {
  var AlleleTicker, Cartographer, CartographerOverlay, DotCartographer, GenomeController, GroupView, InfoSatelliteCartographer, ListView, LocusController, LocusTicker, MapView, MatrixView, MetaTicker, MsaView, SatelliteCartographer, SelectionView, SuperphyError, TickerTemplate, TreeView, ViewController, ViewTemplate, cmp, escapeRegExp, parseHeader, root, trimInput, typeIsArray,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;


  /*
   CLASS SuperphyError
   
   Error object for this library
   */

  SuperphyError = (function(_super) {
    __extends(SuperphyError, _super);

    function SuperphyError(message, name) {
      this.message = message != null ? message : '';
      this.name = name != null ? name : 'Superphy Error';
    }

    return SuperphyError;

  })(Error);


  /*
   CLASS ViewController
    
   Captures events. Updates data and views
   */

  ViewController = (function() {
    function ViewController() {
      if (typeof jQuery === "undefined" || jQuery === null) {
        throw new SuperphyError('jQuery must be loaded before the SuperPhy libary');
      }
      if (typeof URL === "undefined" || URL === null) {
        throw new SuperphyError('SuperPhy library requires the URL library');
      }
      if (typeof Blob === "undefined" || Blob === null) {
        throw new SuperphyError('SuperPhy library requires the Blob library');
      }
    }

    ViewController.prototype.views = [];

    ViewController.prototype.groups = [];

    ViewController.prototype.tickers = [];

    ViewController.prototype.selectedBox = null;

    ViewController.prototype.actionMode = false;

    ViewController.prototype.action = false;

    ViewController.prototype.maxGroups = 10;

    ViewController.prototype.genomeController = void 0;

    ViewController.prototype.init = function(publicGenomes, privateGenomes, actionMode, action, subset) {
      this.actionMode = actionMode;
      this.action = action;
      if (subset == null) {
        subset = null;
      }
      if (!(this.actionMode === 'single_select' || this.actionMode === 'multi_select' || this.actionMode === 'two_groups')) {
        throw new SuperphyError('Unrecognized actionMode in ViewController init() method.');
      }
      this.genomeController = new GenomeController(publicGenomes, privateGenomes, subset);
      this.views = [];
      this.groups = [];
      return this.tickers = [];
    };

    ViewController.prototype.createView = function() {
      var clickStyle, downloadElem, downloadElemDiv, elem, listView, mapView, matView, msaView, treeView, vNum, viewArgs, viewType;
      viewType = arguments[0], elem = arguments[1], viewArgs = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      clickStyle = 'select';
      vNum = this.views.length + 1;
      if (this.actionMode === 'single_select') {
        clickStyle = 'redirect';
      }
      if (viewType === 'list') {
        listView = new ListView(elem, clickStyle, vNum, viewArgs);
        listView.update(this.genomeController);
        this.views.push(listView);
      } else if (viewType === 'jump2list') {
        listView = new ListView(elem, clickStyle, vNum, viewArgs);
        listView.update(this.genomeController);
        this.views.push(listView);
        return;
      } else if (viewType === 'tree') {
        treeView = new TreeView(elem, clickStyle, vNum, viewArgs);
        treeView.update(this.genomeController);
        this.views.push(treeView);
      } else if (viewType === 'msa') {
        msaView = new MsaView(elem, clickStyle, vNum, viewArgs);
        msaView.update(this.genomeController);
        this.views.push(msaView);
      } else if (viewType === 'matrix') {
        matView = new MatrixView(elem, clickStyle, vNum, this.genomeController, viewArgs);
        matView.update(this.genomeController);
        this.views.push(matView);
      } else if (viewType === 'map') {
        mapView = new MapView(elem, clickStyle, vNum, viewArgs);
        this.views.push(mapView);
        mapView.conscriptCartographger();
        mapView.update(this.genomeController, mapView.cartographer);
      } else {
        throw new SuperphyError('Unrecognized viewType in ViewController createView() method.');
        return false;
      }
      downloadElemDiv = jQuery("<div class='download-view'></div>");
      downloadElem = jQuery("<a class='download-view-link' href='#' data-genome-view='" + vNum + "'>Download <i class='fa fa-download'></a>");
      downloadElem.click(function(e) {
        var data, viewNum;
        viewNum = parseInt(this.dataset.genomeView);
        data = viewController.downloadViews(viewNum);
        this.href = data.href;
        this.download = data.file;
        return true;
      });
      downloadElemDiv.append(downloadElem);
      elem.prepend(downloadElemDiv);
      return true;
    };

    ViewController.prototype.createGroup = function(boxEl, buttonEl) {
      var gNum, grpView;
      gNum = this.groups.length + 1;
      if (gNum > this.maxGroups) {
        return false;
      }
      grpView = new GroupView(boxEl, gNum);
      grpView.update(this.genomeController);
      this.groups.push(grpView);
      buttonEl.click(function(e) {
        e.preventDefault();
        return viewController.addToGroup(gNum);
      });
      return true;
    };

    ViewController.prototype.addToGroup = function(grp) {
      var i, selected, v, _i, _len, _ref;
      selected = this.genomeController.selected();
      console.log(selected);
      this.genomeController.assignGroup(selected, grp);
      this.genomeController.unselectAll();
      i = grp - 1;
      this.groups[i].add(selected, this.genomeController);
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.update(this.genomeController);
      }
      if (this.selectedBox != null) {
        return this.selectedBox.update(this.genomeController);
      }
    };

    ViewController.prototype.createTicker = function() {
      var alTicker, elem, locTicker, metaTicker, tNum, tickerArgs, tickerType;
      tickerType = arguments[0], elem = arguments[1], tickerArgs = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      tNum = this.tickers.length + 1;
      if (tickerType === 'meta') {
        metaTicker = new MetaTicker(elem, tNum, tickerArgs);
        metaTicker.update(this.genomeController);
        this.tickers.push(metaTicker);
      } else if (tickerType === 'locus') {
        locTicker = new LocusTicker(elem, tNum, tickerArgs);
        locTicker.update(this.genomeController);
        this.tickers.push(locTicker);
      } else if (tickerType === 'allele') {
        alTicker = new AlleleTicker(elem, tNum, this.genomeController, tickerArgs);
        alTicker.update(this.genomeController);
        this.tickers.push(alTicker);
      } else {
        throw new SuperphyError('Unrecognized tickerType in ViewController createTicker() method.');
        return false;
      }
      return true;
    };

    ViewController.prototype.select = function(g, checked) {
      var v, _i, _len, _ref;
      if (this.actionMode === 'single_select') {
        this.redirect(g);
      } else {
        this.genomeController.select(g, checked);
        _ref = this.views;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          v.select(g, checked);
        }
        if (this.selectedBox != null) {
          this.selectedBox.select(g, this.genomeController, checked);
        }
      }
      return true;
    };

    ViewController.prototype.redirect = function(g) {
      var buttonCloseEl, buttonSubmitEl, displayName, modalView, _ref, _ref1;
      displayName = (_ref = (_ref1 = this.genomeController.private_genomes[g]) != null ? _ref1.displayname : void 0) != null ? _ref : this.genomeController.public_genomes[g].displayname;
      modalView = jQuery('<div class="modal fade" id="view-redirect-modal" tabindex="-1" role="dialog" aria-labelledby="viewRedirectModalLabel" aria-hidden="true"> <div class="modal-dialog modal-sm"> <div class="modal-content"> <div class="modal-header"> <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button> <h4 class="modal-title" id="viewRedirectModalLabel">Retrieve selected genome?</h4> </div> <div class="modal-body"> Would you like to retrieve genome information for the selected genome: <form id="view-redirect-form"> <div class="well well-sm">' + displayName + '</div> <input type="hidden" name="genome" value="' + g + '"/> </form> </div> <div class="modal-footer"> </div> </div> </div> </div>');
      buttonCloseEl = jQuery('<button type="button" class="btn btn-danger" data-dismiss="modal" form="view-redirect-form" value="Cancel">Cancel</button>');
      buttonSubmitEl = jQuery('<button type="submit" id="view-redirect-submit" class="btn btn-success" value="Submit" form="view-redirect-form" formmethod="post" formaction="' + viewController.action + '"> Submit </button>');
      buttonSubmitEl.click(function() {
        return modalView.find('.modal-body').append('<div class="alert alert-success">Retrieving genome, please dont hit the ESC key</div>');
      });
      modalView.find('.modal-footer').append(buttonCloseEl);
      modalView.find('.modal-footer').append(buttonSubmitEl);
      modalView.modal('show');
      return true;
    };

    ViewController.prototype.removeFromGroup = function(genomeID, grp) {
      var gset, i, v, _i, _len, _ref;
      console.log('deleting ' + genomeID);
      gset = this.genomeController.genomeSet([genomeID]);
      this.genomeController.deleteGroup(gset);
      i = grp - 1;
      this.groups[i].remove(genomeID);
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.updateCSS(gset, this.genomeController);
      }
      return true;
    };

    ViewController.prototype.groupForm = function(elem, addMoreOpt) {
      var addEl, blockEl, buttEl, divEl;
      blockEl = jQuery("<div id='group-form-block'></div>").appendTo(elem);
      this.addGroupFormRow(blockEl);
      if (addMoreOpt) {
        addEl = jQuery("<div class='add-genome-groups row'></div>");
        divEl = jQuery("<div class='col-md-12'></div>").appendTo(addEl);
        buttEl = jQuery("<button class='btn' type='button'>More Genome Groups...</button>").appendTo(divEl);
        buttEl.click(function(e) {
          var reachedMax;
          reachedMax = viewController.addGroupFormRow(jQuery("#group-form-block"));
          if (!reachedMax) {
            jQuery(this).text('Max groups reached').css('color', 'darkgrey');
            return e.preventDefault();
          }
        });
        elem.append(addEl);
      }
      return true;
    };

    ViewController.prototype.addGroupFormRow = function(elem) {
      var buttEl, formEl, gNum, i, listEl, ok, rowEl, _i, _len, _ref;
      if (typeof elem === 'string') {
        elem = jQuery(elem);
      }
      gNum = this.groups.length + 1;
      if (gNum > this.maxGroups) {
        return false;
      }
      rowEl = jQuery("<div class='group-form-row row'></div>").appendTo(elem);
      ok = true;
      _ref = [gNum, gNum + 1];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        formEl = jQuery("<div id='genome-group-form" + i + "' class='genome-group-form col-md-6'></div>");
        listEl = jQuery("<div id='genome-group-list" + i + "'></div>").appendTo(formEl);
        buttEl = jQuery("<button id='genome-group-add" + i + "' class='btn' type='button'>Add to Group " + i + "</button>").appendTo(formEl);
        rowEl.append(formEl);
        ok = this.createGroup(listEl, buttEl);
      }
      return ok;
    };

    ViewController.prototype.viewAction = function() {
      var vNum, viewArgs;
      vNum = arguments[0], viewArgs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      this.views[vNum].viewAction(this.genomeController, viewArgs);
      return true;
    };

    ViewController.prototype.getView = function(vNum) {
      return this.views[vNum];
    };

    ViewController.prototype.updateViews = function(option, checked) {
      var t, v, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      this.genomeController.updateMeta(option, checked);
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.update(this.genomeController);
      }
      _ref1 = this.groups;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        v = _ref1[_j];
        v.update(this.genomeController);
      }
      _ref2 = this.tickers;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        t = _ref2[_k];
        t.update(this.genomeController);
      }
      if (this.selectedBox != null) {
        this.selectedBox.update(this.genomeController);
      }
      return true;
    };

    ViewController.prototype.downloadViews = function(viewNum) {
      var blob, dump, file, href, url;
      url = window.URL || window.webkitURL;
      blob = window.Blob;
      dump = this.views[viewNum - 1].dump(this.genomeController);
      file = new blob([dump.data], {
        type: dump.type
      });
      href = url.createObjectURL(file);
      file = "superphy_download." + dump.ext;
      return {
        href: href,
        file: file
      };
    };

    ViewController.prototype.sideBar = function(elem) {
      var form1, form2, parentTarget, wrapper;
      parentTarget = 'sidebar-accordion';
      wrapper = jQuery('<div class="panel-group" id="' + parentTarget + '"></div>');
      elem.append(wrapper);
      form1 = jQuery('<div class="panel panel-default"></div>');
      wrapper.append(form1);
      this.metaForm(form1, parentTarget);
      form2 = jQuery('<div class="panel panel-default"></div>');
      wrapper.append(form2);
      this.filterForm(form2, parentTarget);
      return true;
    };

    ViewController.prototype.sideBarRight = function(elem) {
      return true;
    };

    ViewController.prototype.metaForm = function(elem, parentStr) {
      var form;
      form = '<div class="panel-heading">' + '<div class="panel-title">' + '<a data-toggle="collapse" data-parent="#' + parentStr + '" href="#meta-form"><i class="fa fa-eye"></i> Meta-data ' + '<span class="caret"></span></a>' + '</div></div>' + '<div id="meta-form" class="panel-collapse collapse out">' + '<div class="panel-body">' + '<p>Select meta-data displayed:</p>' + '<form class="form-inline">' + '<fieldset>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="accession"> Accession # </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="strain"> Strain </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="serotype"> Serotype </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="isolation_host"> Isolation Host </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="isolation_source"> Isolation Source </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="isolation_date"> Isolation Date </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="syndrome"> Symptoms / Diseases </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="stx1_subtype"> Stx1 Subtype </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="stx2_subtype"> Stx2 Subtype </label></div>' + '</fieldset>' + '</form>' + '</div></div>';
      elem.append(form);
      jQuery('input[name="meta-option"]').change(function() {
        return viewController.updateViews(this.value, this.checked);
      });
      return true;
    };

    ViewController.prototype.filterViews = function(filterForm) {
      var searchTerms, t, term, v, _i, _j, _len, _len1, _ref, _ref1;
      if (filterForm === 'selection') {
        this.genomeController.filterBySelection();
      } else {
        searchTerms = null;
        if (filterForm === 'fast') {
          term = jQuery("#fast-filter > input").val().toLowerCase();
          if ((term != null) && term.length) {
            searchTerms = [];
            searchTerms.push({
              searchTerm: term,
              dataField: 'viewname',
              negate: false
            });
          }
        } else {
          searchTerms = this._parseFilterForm();
        }
        this.genomeController.filter(searchTerms);
      }
      this._toggleFilterStatus();
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.update(this.genomeController);
      }
      _ref1 = this.tickers;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        t = _ref1[_j];
        t.update(this.genomeController);
      }
      return true;
    };

    ViewController.prototype.resetFilter = function() {
      var t, v, _i, _j, _len, _len1, _ref, _ref1, _results;
      this.genomeController.filter();
      this._toggleFilterStatus();
      this._clearFilterForm();
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.update(this.genomeController);
      }
      _ref1 = this.tickers;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        t = _ref1[_j];
        _results.push(t.update(this.genomeController));
      }
      return _results;
    };

    ViewController.prototype.filterForm = function(elem, parentStr) {
      var advForm, advLab, advRadio, container, delButton, fastLab, fastRadio, fbs, filtButton, filtType, filterOff, filterOn, filterStatus, header, numVisible, selLab, selRadio, sf;
      header = jQuery('<div class="panel-heading">' + '<div class="panel-title">' + '<a data-toggle="collapse" data-parent="#' + parentStr + '" href="#filter-form"><i class="fa fa-filter"></i> Filter ' + '<span class="caret"></span></a>' + '</div></div>').appendTo(elem);
      container = jQuery('<div id="filter-form" class="panel-collapse collapse out"></div>');
      numVisible = this.genomeController.filtered;
      filterStatus = jQuery('<div id="filter-status"></div>');
      filterOn = jQuery("<div id='filter-on'><div id='filter-on-text' class='alert alert-warning'>Filter active. " + numVisible + " genomes visible.</div></div>");
      filterOff = jQuery('<div id="filter-off"></div>');
      delButton = jQuery('<button id="remove-filter" type="button" class="btn btn-sm">Clear</button>');
      delButton.click(function(e) {
        e.preventDefault();
        return viewController.resetFilter();
      });
      delButton.appendTo(filterOn);
      if (numVisible > 0) {
        filterOn.show();
        filterOff.hide();
      } else {
        filterOn.hide();
        filterOff.show();
      }
      filterStatus.append(filterOn);
      filterStatus.append(filterOff);
      container.append(filterStatus);
      container.append('<p>Limit genomes displayed in views by:</p>');
      filtType = jQuery('<form id="select-filter-form" class="form-inline"></form>');
      fastLab = jQuery('<div class="form-group"><label class="radio">Basic</label></div>');
      fastRadio = jQuery('<input type="radio" name="filter-form-type" value="fast" checked>');
      fastRadio.change(function(e) {
        if (this.checked != null) {
          jQuery("#fast-filter").show();
          jQuery("#adv-filter").hide();
          jQuery("#selection-filter").hide();
        }
        return true;
      });
      fastLab.prepend(fastRadio);
      filtType.append(fastLab);
      advLab = jQuery('<div class="form-group"><label class="radio">Advanced</label></div>');
      advRadio = jQuery('<input type="radio" name="filter-form-type" value="advanced">');
      advRadio.change(function(e) {
        if (this.checked != null) {
          jQuery("#fast-filter").hide();
          jQuery("#adv-filter").show();
          jQuery("#selection-filter").hide();
        }
        return true;
      });
      advLab.prepend(advRadio);
      filtType.append(advLab);
      selLab = jQuery('<div class="form-group"><label class="radio">By Selection</label></div>');
      selRadio = jQuery('<input type="radio" name="filter-form-type" value="selection">');
      selRadio.change(function(e) {
        if (this.checked != null) {
          jQuery("#fast-filter").hide();
          jQuery("#adv-filter").hide();
          jQuery("#selection-filter").show();
        }
        return true;
      });
      selLab.prepend(selRadio);
      filtType.append(selLab);
      container.append(filtType);
      sf = jQuery("<div id='fast-filter'></div>");
      this.addFastFilter(sf);
      container.append(sf);
      advForm = jQuery("<div id='adv-filter'></div>");
      this.addAdvancedFilter(advForm);
      advForm.hide();
      container.append(advForm);
      fbs = jQuery("<div id='selection-filter'>" + "<p>A selection in one of the views (i.e. genomes selected in a clade or map region)</p>" + "</div>");
      filtButton = jQuery('<button id="filter-selection-button" type="button" class="btn btn-sm">Filter by Selection</button>');
      filtButton.click(function(e) {
        e.preventDefault();
        return viewController.filterViews('selection');
      });
      fbs.append(filtButton);
      fbs.hide();
      container.append(fbs);
      container.appendTo(elem);
      return true;
    };

    ViewController.prototype._toggleFilterStatus = function() {
      var filterOff, filterOn, numVisible;
      numVisible = this.genomeController.filtered;
      filterOn = jQuery('#filter-on');
      filterOff = jQuery('#filter-off');
      if (numVisible > 0) {
        filterOn.find('#filter-on-text').text("Filter active. " + numVisible + " genomes visible.");
        filterOn.show();
        filterOff.hide();
      } else {
        filterOn.hide();
        filterOff.show();
      }
      return true;
    };

    ViewController.prototype._clearFilterForm = function() {
      var advForm, sf;
      sf = jQuery("#fast-filter");
      sf.empty();
      this.addFastFilter(sf);
      advForm = jQuery("#adv-filter");
      advForm.empty();
      this.addAdvancedFilter(advForm);
      return true;
    };

    ViewController.prototype.addAdvancedFilter = function(elem) {
      var addRow, advButton, advRows;
      elem.append("<p>Boolean keyword search of specified meta-data fields</p>");
      advRows = jQuery("<div id='adv-filter-rows'></div>");
      elem.append(advRows);
      this.addFilterRow(advRows, 1);
      advButton = jQuery('<button id="adv-filter-submit" type="button" class="btn btn-sm">Filter</button>');
      elem.append(advButton);
      advButton.click(function(e) {
        e.preventDefault;
        return viewController.filterViews('advanced');
      });
      addRow = jQuery('<a href="#" class="adv-filter-addition">Add term</a>');
      addRow.click(function(e) {
        var rowI, rows;
        e.preventDefault();
        rows = jQuery('.adv-filter-row');
        rowI = rows.length + 1;
        return viewController.addFilterRow(jQuery('#adv-filter-rows'), rowI);
      });
      elem.append(addRow);
      return true;
    };

    ViewController.prototype.addFilterRow = function(elem, rowNum) {
      var delRow, dropDown, dt, k, keyw, row, v, _ref;
      row = jQuery('<div class="adv-filter-row" data-filter-row="' + rowNum + '"></div>').appendTo(elem);
      if (rowNum !== 1) {
        jQuery('<select name="adv-filter-op" data-filter-row="' + rowNum + '">' + '<option value="and" selected="selected">AND</option>' + '<option value="or">OR</option>' + '<option value="not">NOT</option>' + '</select>').appendTo(row);
      }
      dropDown = jQuery('<select name="adv-filter-field" data-filter-row="' + rowNum + '"></select>').appendTo(row);
      _ref = this.genomeController.metaMap;
      for (k in _ref) {
        v = _ref[k];
        dropDown.append('<option value="' + k + '">' + v + '</option>');
      }
      dropDown.append('<option value="displayname" selected="selected">Genome name</option>');
      dropDown.change(function() {
        var thisRow;
        thisRow = this.dataset.filterRow;
        if (this.value === 'isolation_date') {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').show();
        } else {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').show();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
        }
        return true;
      });
      keyw = jQuery('<div class="adv-filter-keyword" data-filter-row="' + rowNum + '"></div>)');
      jQuery('<input type="text" name="adv-filter-term" data-filter-row="' + rowNum + '" placeholder="Keyword"></input>').appendTo(keyw);
      keyw.appendTo(row);
      dt = jQuery('<div class="adv-filter-date" data-filter-row="' + rowNum + '"></div>)');
      dt.append('<select name="adv-filter-before" data-filter-row="' + rowNum + '">' + '<option value="before" selected="selected">before</option>' + '<option value="after">after</option>' + '</select>');
      dt.append('<input type="text" name="adv-filter-year" data-filter-row="' + rowNum + '" placeholder="YYYY"></input>');
      dt.append('<input type="text" name="adv-filter-mon" data-filter-row="' + rowNum + '" placeholder="MM"></input>');
      dt.append('<input type="text" name="adv-filter-day" data-filter-row="' + rowNum + '" placeholder="DD"></input>');
      dt.hide();
      dt.appendTo(row);
      if (rowNum !== 1) {
        delRow = jQuery('<a href="#" class="adv-filter-subtraction" data-filter-row="' + rowNum + '">Remove term</a>');
        delRow.appendTo(row);
        delRow.click(function(e) {
          var thisRow;
          e.preventDefault();
          thisRow = this.dataset.filterRow;
          return jQuery('.adv-filter-row[data-filter-row="' + thisRow + '"]').remove();
        });
      }
      return true;
    };

    ViewController.prototype.addFastFilter = function(elem) {
      var fastButton, tBox;
      elem.append("<p>Basic genome name filter</p>");
      tBox = jQuery('<input type="text" name="fast-filter-term" placeholder="Filter by..."></input>');
      fastButton = jQuery('<button id="fast-filter-submit" type="button" class="btn btn-sm">Filter</button>');
      fastButton.click(function(e) {
        e.preventDefault;
        return viewController.filterViews('fast');
      });
      tBox.appendTo(elem);
      fastButton.appendTo(elem);
      return true;
    };

    ViewController.prototype._parseFilterForm = function() {
      var bef, date, df, dy, isBefore, isDate, mn, negate, op, row, rowNum, rows, searchTerms, t, term, yr, _i, _len;
      rows = jQuery('.adv-filter-row');
      searchTerms = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        t = {};
        rowNum = parseInt(row.dataset.filterRow);
        df = jQuery("[name='adv-filter-field'][data-filter-row='" + rowNum + "']").val();
        t.dataField = df;
        isDate = false;
        if (df === 'isolation_date') {
          isDate = true;
        }
        if (!isDate) {
          term = jQuery("[name='adv-filter-term'][data-filter-row='" + rowNum + "']").val();
          term = trimInput(term, 'keyword');
          if (term == null) {
            return null;
          }
          t.searchTerm = term;
        } else {
          bef = jQuery("[name='adv-filter-before'][data-filter-row='" + rowNum + "']").val();
          if (!(bef === 'before' || bef === 'after')) {
            throw new SuperphyError('Invalid input in advanced filter form. Element "adv-filter-before" must contain strings "before","after".');
          }
          isBefore = true;
          if (bef === 'after') {
            isBefore = false;
          }
          yr = jQuery("[name='adv-filter-year'][data-filter-row='" + rowNum + "']").val();
          yr = trimInput(yr, 'Year');
          if (yr == null) {
            return null;
          }
          if (!/^[1-9][0-9]{3}$/.test(yr)) {
            alert('Error: invalid Year.');
            return null;
          }
          mn = jQuery("[name='adv-filter-mon'][data-filter-row='" + rowNum + "']").val();
          if (mn != null) {
            mn = jQuery.trim(mn);
          }
          if ((mn != null) && mn.length) {
            if (!/^[0-9]{1,2}$/.test(mn)) {
              alert('Error: invalid Month.');
              return null;
            }
          } else {
            mn = '01';
          }
          dy = jQuery("[name='adv-filter-day'][data-filter-row='" + rowNum + "']").val();
          if (dy != null) {
            dy = jQuery.trim(dy);
          }
          if ((dy != null) && dy.length) {
            if (!/^[0-9]{1,2}$/.test(dy)) {
              alert('Error: invalid Day.');
              return null;
            }
          } else {
            dy = '01';
          }
          date = Date.parse("" + yr + "-" + mn + "-" + dy);
          if (isNaN(date)) {
            alert('Error: invalid date.');
            return null;
          }
          t.date = date;
          t.before = isBefore;
        }
        if (rowNum !== 1) {
          op = jQuery("[name='adv-filter-op'][data-filter-row='" + rowNum + "']").val();
          negate = false;
          if (!(op === 'or' || op === 'and' || op === 'not')) {
            throw new SuperphyError('Invalid input in advanced filter form. Element "adv-filter-op" must contain strings "and","or","not".');
          }
          if (op === 'not') {
            op = 'and';
            negate = true;
          }
          t.op = op;
          t.negate = negate;
          searchTerms.push(t);
        } else {
          t.negate = false;
          searchTerms.unshift(t);
        }
      }
      return searchTerms;
    };

    ViewController.prototype.createSelectionView = function(boxEl, countEl) {
      var selView;
      if (countEl == null) {
        countEl = null;
      }
      if (this.selectedBox != null) {
        throw new SuperphyError('Existing SelectionView. Cannot create multiple views of this type.');
      }
      selView = new SelectionView(boxEl, countEl);
      selView.update(this.genomeController);
      this.selectedBox = selView;
      return true;
    };

    ViewController.prototype.submitGenomes = function(formEl, paramType) {
      var g, genomes, gset, input, k, v, _i, _len, _ref, _ref1, _results, _results1;
      if (paramType == null) {
        paramType = 'selected';
      }
      if (paramType === 'selected') {
        gset = this.genomeController.selected();
        genomes = gset["public"].concat(gset["private"]);
        _results = [];
        for (_i = 0, _len = genomes.length; _i < _len; _i++) {
          g = genomes[_i];
          input = jQuery('<input></input>');
          input.attr('type', 'hidden');
          input.attr('name', 'genome');
          input.val(g);
          _results.push(formEl.append(input));
        }
        return _results;
      } else if (paramType === 'grouped') {
        _ref = this.genomeController.public_genomes;
        for (k in _ref) {
          v = _ref[k];
          if (!(v.assignedGroup != null)) {
            continue;
          }
          input = jQuery('<input></input>');
          input.attr('type', 'hidden');
          input.attr('name', "group" + v.assignedGroup);
          input.val(g);
          formEl.append(input);
        }
        _ref1 = this.genomeController.private_genomes;
        _results1 = [];
        for (k in _ref1) {
          v = _ref1[k];
          if (!(v.assignedGroup != null)) {
            continue;
          }
          input = jQuery('<input></input>');
          input.attr('type', 'hidden');
          input.attr('name', "group" + v.assignedGroup);
          input.val(g);
          _results1.push(formEl.append(input));
        }
        return _results1;
      } else {
        throw new SuperphyError("Unknown paramType parameter: " + paramType);
      }
    };

    return ViewController;

  })();

  if (!root.ViewController) {
    root.viewController = new ViewController;
  }


  /*
   CLASS ViewTemplate
   
   Template object for views. Defines required and
   common properties/methods. All view objects
   are descendants of the ViewTemplate.
   */

  ViewTemplate = (function() {
    function ViewTemplate(parentElem, style, elNum) {
      this.parentElem = parentElem;
      this.style = style != null ? style : 'select';
      this.elNum = elNum != null ? elNum : 1;
      this.elID = this.elName + this.elNum;
    }

    ViewTemplate.prototype.type = void 0;

    ViewTemplate.prototype.elNum = 1;

    ViewTemplate.prototype.elName = 'view';

    ViewTemplate.prototype.elID = void 0;

    ViewTemplate.prototype.parentElem = void 0;

    ViewTemplate.prototype.style = 'select';

    ViewTemplate.prototype.update = function(genomes) {
      throw new SuperphyError("ViewTemplate method update() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.updateCSS = function(gset, genomes) {
      throw new SuperphyError("ViewTemplate method updateCSS() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.select = function(genome, isSelected) {
      throw new SuperphyError("ViewTemplate method select() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.dump = function(genomes) {
      throw new SuperphyError("ViewTemplate method dump() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.viewAction = function() {
      var args, genomes;
      genomes = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      throw new SuperphyError("viewAction method has not been defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.cssClass = function() {
      return this.elName + '_item';
    };

    return ViewTemplate;

  })();


  /*
   CLASS ListView
   
   Genome list
   
   Always genome-based
   Returns genome ID to redirect/select when genome list item is clicked
   */

  ListView = (function(_super) {
    __extends(ListView, _super);

    function ListView(parentElem, style, elNum, listArgs) {
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      if ((listArgs != null) && (listArgs[0] != null)) {
        this.locusData = listArgs[0];
      }
      ListView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
    }

    ListView.prototype.type = 'list';

    ListView.prototype.elName = 'genome_list';

    ListView.prototype.locusData = null;

    ListView.prototype.update = function(genomes) {
      var ft, listElem, t1, t2;
      listElem = jQuery("#" + this.elID);
      if (listElem.length) {
        listElem.empty();
      } else {
        listElem = jQuery("<ul id='" + this.elID + "'/>");
        jQuery(this.parentElem).append(listElem);
      }
      t1 = new Date();
      this._appendGenomes(listElem, genomes.pubVisible, genomes.public_genomes, this.style, false);
      this._appendGenomes(listElem, genomes.pvtVisible, genomes.private_genomes, this.style, true);
      t2 = new Date();
      ft = t2 - t1;
      console.log('ListView update elapsed time: ' + ft);
      return true;
    };

    ListView.prototype._appendGenomes = function(el, visibleG, genomes, style, priv) {
      var actionEl, checked, cls, g, labEl, listEl, name, thiscls, _i, _len;
      cls = this.cssClass();
      if (priv && visibleG.length) {
        el.append("<li class='genome_list_spacer'>---- USER-SUBMITTED GENOMES ----</li>");
      }
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        name = genomes[g].viewname;
        if (this.locusData != null) {
          name += this.locusData.genomeString(g);
        }
        if (style === 'redirect') {
          listEl = jQuery("<li class='" + thiscls + "'>" + name + "</li>");
          actionEl = jQuery("<a href='#' data-genome='" + g + "'> <span class='fa fa-search'></span>info</a>");
          actionEl.click(function(e) {
            var gid;
            e.preventDefault();
            gid = this.dataset.genome;
            return viewController.select(gid, true);
          });
          listEl.append(actionEl);
          el.append(listEl);
        } else if (style === 'select') {
          checked = '';
          if (genomes[g].isSelected) {
            checked = 'checked';
          }
          listEl = jQuery("<li class='" + thiscls + "'></li>");
          labEl = jQuery("<label class='checkbox'>" + name + "</label>");
          actionEl = jQuery("<input class='checkbox' type='checkbox' value='" + g + "' " + checked + "/>");
          actionEl.change(function(e) {
            e.preventDefault();
            return viewController.select(this.value, this.checked);
          });
          labEl.append(actionEl);
          listEl.append(labEl);
          el.append(listEl);
        } else {
          return false;
        }
      }
      return true;
    };

    ListView.prototype.updateCSS = function(gset, genomes) {
      var listEl;
      listEl = jQuery("#" + this.elID);
      if (!((listEl != null) && listEl.length)) {
        throw new SuperphyError("DOM element for list view " + this.elID + " not found. Cannot call ListView method updateCSS().");
      }
      if (gset["public"] != null) {
        this._updateGenomeCSS(listEl, gset["public"], genomes.public_genomes);
      }
      if (gset["private"] != null) {
        this._updateGenomeCSS(listEl, gset["private"], genomes.private_genomes);
      }
      return true;
    };

    ListView.prototype._updateGenomeCSS = function(el, changedG, genomes) {
      var cls, descriptor, g, itemEl, liEl, thiscls, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = changedG.length; _i < _len; _i++) {
        g = changedG[_i];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        itemEl = null;
        if (this.style === 'redirect') {
          descriptor = "li > a[data-genome='" + g + "']";
          itemEl = el.find(descriptor);
        } else if (this.style === 'select') {
          descriptor = "li input[value='" + g + "']";
          itemEl = el.find(descriptor);
        } else {
          return false;
        }
        if (!((itemEl != null) && itemEl.length)) {
          throw new SuperphyError("List element for genome " + g + " not found in ListView " + this.elID);
          return false;
        }
        liEl = itemEl.parents().eq(1);
        liEl.attr('class', thiscls);
      }
      return true;
    };

    ListView.prototype.select = function(genome, isSelected) {
      var descriptor, itemEl;
      itemEl = null;
      if (this.style === 'select') {
        descriptor = "li input[value='" + genome + "']";
        itemEl = jQuery(descriptor);
      } else {
        return false;
      }
      if (!((itemEl != null) && itemEl.length)) {
        throw new SuperphyError("List element for genome " + genome + " not found in ListView " + this.elID);
        return false;
      }
      itemEl.prop('checked', isSelected);
      return true;
    };

    ListView.prototype.dump = function(genomes) {
      var fullMeta, g, header, id, k, output, _ref, _ref1;
      fullMeta = {};
      for (k in genomes.visibleMeta) {
        fullMeta[k] = true;
      }
      output = '';
      header = (function() {
        var _results;
        _results = [];
        for (k in fullMeta) {
          _results.push(genomes.metaMap[k]);
        }
        return _results;
      })();
      header.unshift("Genome name");
      output += "#" + header.join("\t") + "\n";
      _ref = genomes.public_genomes;
      for (id in _ref) {
        g = _ref[id];
        output += genomes.label(g, fullMeta, "\t") + "\n";
      }
      _ref1 = genomes.private_genomes;
      for (id in _ref1) {
        g = _ref1[id];
        output += genomes.label(g, fullMeta, "\t") + "\n";
      }
      return {
        ext: 'csv',
        type: 'text/plain',
        data: output
      };
    };

    return ListView;

  })(ViewTemplate);


  /*
   CLASS GroupView
   
   A special type of genome list that is used to temporarily store the user's
   selected genomes.
   
   Only one 'style' which provides a remove button to remove group from group.
   Will be updated by changes to the meta-display options but not by filtering.
   */

  GroupView = (function() {
    function GroupView(parentElem, elNum) {
      this.parentElem = parentElem;
      this.elNum = elNum != null ? elNum : 1;
      this.elID = this.elName + this.elNum;
    }

    GroupView.prototype.type = 'group';

    GroupView.prototype.elNum = 1;

    GroupView.prototype.elName = 'genome_group';

    GroupView.prototype.elID = void 0;

    GroupView.prototype.update = function(genomes) {
      var ingrp, listElem;
      listElem = jQuery("#" + this.elID);
      if (listElem.length) {
        listElem.empty();
      } else {
        listElem = jQuery("<ul id='" + this.elID + "' class='genome-group-list'/>");
        jQuery(this.parentElem).append(listElem);
      }
      ingrp = genomes.grouped(this.elNum);
      this._appendGenomes(listElem, ingrp["public"], genomes.public_genomes);
      this._appendGenomes(listElem, ingrp["private"], genomes.private_genomes);
      return true;
    };

    GroupView.prototype.add = function(genomeSet, genomes) {
      var listElem;
      listElem = jQuery("#" + this.elID);
      if (!listElem.length) {
        listElem = jQuery("<ul id='" + this.elID + "' class='genome-group-list'/>");
        jQuery(this.parentElem).append(listElem);
      }
      if (genomeSet["public"] != null) {
        this._appendGenomes(listElem, genomeSet["public"], genomes.public_genomes);
      }
      if (genomeSet["private"] != null) {
        return this._appendGenomes(listElem, genomeSet["private"], genomes.private_genomes);
      }
    };

    GroupView.prototype._appendGenomes = function(el, visibleG, genomes) {
      var actionEl, cls, g, listEl, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        listEl = jQuery(("<li class='" + cls + "'>") + genomes[g].viewname + '</li>');
        actionEl = jQuery("<a href='#' data-genome='" + g + "' data-genome-group='" + this.elNum + "'> <i class='fa fa-times'></a>");
        actionEl.click(function(e) {
          var gid, grp;
          e.preventDefault();
          gid = this.dataset.genome;
          grp = this.dataset.genomeGroup;
          console.log('clicked remove on ' + gid);
          return viewController.removeFromGroup(gid, grp);
        });
        listEl.append(actionEl);
        el.append(listEl);
      }
      return true;
    };

    GroupView.prototype.remove = function(gid) {
      var descriptor, linkEl, listEl;
      listEl = jQuery("#" + this.elID);
      if (!((listEl != null) && listEl.length)) {
        throw new SuperphyError("DOM element for group view " + this.elID + " not found. Cannot call GroupView method remove().");
      }
      descriptor = "li > a[data-genome='" + gid + "']";
      linkEl = listEl.find(descriptor);
      if (!((linkEl != null) && linkEl.length)) {
        throw new SuperphyError("List item element for genome " + gid + " not found in GroupView " + this.elID);
        return false;
      }
      linkEl.parent('li').remove();
      return true;
    };

    GroupView.prototype.cssClass = function() {
      return this.elName + '_item';
    };

    return GroupView;

  })();


  /*
   CLASS GenomeController
   
   Manages private/public genome list
   */

  GenomeController = (function() {
    function GenomeController(public_genomes, private_genomes, subset) {
      var i, newPri, newPub, _i, _len;
      this.public_genomes = public_genomes;
      this.private_genomes = private_genomes;
      if (subset == null) {
        subset = null;
      }
      if (subset != null) {
        newPub = {};
        newPri = {};
        for (_i = 0, _len = subset.length; _i < _len; _i++) {
          i = subset[_i];
          if (this.public_genomes[i] != null) {
            newPub[i] = this.public_genomes[i];
          } else if (this.private_genomes[i] != null) {
            newPri[i] = this.private_genomes[i];
          }
        }
        this.public_genomes = newPub;
        this.private_genomes = newPri;
      }
      this.update();
      this.filter();
      this.genomeSetId = 0;
    }

    GenomeController.prototype.pubVisible = [];

    GenomeController.prototype.pvtVisible = [];

    GenomeController.prototype.visibleMeta = {
      strain: false,
      serotype: false,
      isolation_host: false,
      isolation_source: false,
      isolation_date: false,
      accession: false,
      syndrome: false,
      stx1_subtype: false,
      stx2_subtype: false
    };

    GenomeController.prototype.metaMap = {
      'strain': 'Strain',
      'serotype': 'Serotype',
      'isolation_host': 'Host',
      'isolation_source': 'Source',
      'isolation_date': 'Date of isolation',
      'accession': 'Accession ID',
      'syndrome': 'Symptom / Disease',
      'stx1_subtype': 'Stx1 Subtype',
      'stx2_subtype': 'Stx2 Subtype'
    };

    GenomeController.prototype.publicRegexp = new RegExp('^public_');

    GenomeController.prototype.privateRegexp = new RegExp('^private_');

    GenomeController.prototype.filtered = 0;

    GenomeController.prototype.update = function() {
      var g, id, _ref, _ref1;
      _ref = this.public_genomes;
      for (id in _ref) {
        g = _ref[id];
        g.viewname = this.label(g, this.visibleMeta);
        g.htmlname = this.labelHTML(g, this.visibleMeta);
      }
      _ref1 = this.private_genomes;
      for (id in _ref1) {
        g = _ref1[id];
        g.viewname = this.label(g, this.visibleMeta);
        g.htmlname = this.labelHTML(g, this.visibleMeta);
      }
      return true;
    };

    GenomeController.prototype.filter = function(searchTerms) {
      var g, i, pubGenomeIds, pvtGenomeIds, results, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      if (searchTerms == null) {
        searchTerms = null;
      }
      pubGenomeIds = [];
      pvtGenomeIds = [];
      if (searchTerms != null) {
        results = this._runFilter(searchTerms);
        pubGenomeIds = results["public"];
        pvtGenomeIds = results["private"];
        this.filtered = pubGenomeIds.length + pvtGenomeIds.length;
        _ref = this.public_genomes;
        for (i in _ref) {
          g = _ref[i];
          g.visible = false;
        }
        _ref1 = this.private_genomes;
        for (i in _ref1) {
          g = _ref1[i];
          g.visible = false;
        }
        for (_i = 0, _len = pubGenomeIds.length; _i < _len; _i++) {
          g = pubGenomeIds[_i];
          this.public_genomes[g].visible = true;
        }
        for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
          g = pvtGenomeIds[_j];
          this.private_genomes[g].visible = true;
        }
      } else {
        pubGenomeIds = Object.keys(this.public_genomes);
        pvtGenomeIds = Object.keys(this.private_genomes);
        this.filtered = 0;
        _ref2 = this.public_genomes;
        for (i in _ref2) {
          g = _ref2[i];
          g.visible = true;
        }
        _ref3 = this.private_genomes;
        for (i in _ref3) {
          g = _ref3[i];
          g.visible = true;
        }
      }
      this.pubVisible = pubGenomeIds.sort((function(_this) {
        return function(a, b) {
          return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
        };
      })(this));
      this.pvtVisible = pvtGenomeIds.sort((function(_this) {
        return function(a, b) {
          return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
        };
      })(this));
      this.genomeSetId++;
      return true;
    };

    GenomeController.prototype.filterBySelection = function() {
      var g, gset, i, pubGenomeIds, pvtGenomeIds, _i, _j, _len, _len1, _ref, _ref1;
      gset = this.selected();
      pubGenomeIds = gset["public"];
      pvtGenomeIds = gset["private"];
      this.filtered = pubGenomeIds.length + pvtGenomeIds.length;
      if (this.filtered === 0) {
        this.filter();
      } else {
        _ref = this.public_genomes;
        for (i in _ref) {
          g = _ref[i];
          g.visible = false;
        }
        _ref1 = this.private_genomes;
        for (i in _ref1) {
          g = _ref1[i];
          g.visible = false;
        }
        for (_i = 0, _len = pubGenomeIds.length; _i < _len; _i++) {
          g = pubGenomeIds[_i];
          this.public_genomes[g].visible = true;
          this.public_genomes[g].isSelected = false;
        }
        for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
          g = pvtGenomeIds[_j];
          this.private_genomes[g].visible = true;
          this.private_genomes[g].isSelected = false;
        }
        this.pubVisible = pubGenomeIds.sort((function(_this) {
          return function(a, b) {
            return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
          };
        })(this));
        this.pvtVisible = pvtGenomeIds.sort((function(_this) {
          return function(a, b) {
            return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
          };
        })(this));
      }
      return true;
    };

    GenomeController.prototype._runFilter = function(searchTerms) {
      var firstTerm, id, pubGenomeIds, pubSet, pvtGenomeIds, pvtSet, regex, t, _i, _len;
      if (!typeIsArray(searchTerms)) {
        throw new SuperphyError('Invalid argument. GenomeController method _runFilter() requires array of search term objects as input.');
      }
      pubGenomeIds = Object.keys(this.public_genomes);
      pvtGenomeIds = Object.keys(this.private_genomes);
      firstTerm = true;
      for (_i = 0, _len = searchTerms.length; _i < _len; _i++) {
        t = searchTerms[_i];
        if (firstTerm) {
          if (t.op != null) {
            throw new SuperphyError("Invalid filter input. First search term object cannot contain an operator property 'op'.");
          }
          if (t.dataField !== 'isolation_date') {
            if (t.searchTerm == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'searchTerm' property.");
            }
            if (t.dataField == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'dataField' property.");
            }
            if (t.negate == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'negate' property.");
            }
          } else {
            if (t.dataField == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'searchTerm' property.");
            }
            if (t.date == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'date' property.");
            }
            if (t.before == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'before' property.");
            }
          }
          firstTerm = false;
        } else {
          if (t.op == null) {
            throw new SuperphyError("Invalid filter input. Subsequent search term objects must contain an operator property 'op'.");
          }
        }
        if ((t.op != null) && t.op === 'or') {
          pubSet = [];
          pubSet = [];
          if (t.dataField === 'isolation_date') {
            pubSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.public_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.passDate(this.public_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.private_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.passDate(this.private_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
          } else {
            regex = new RegExp(escapeRegExp(t.searchTerm), "i");
            pubSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.public_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.match(this.public_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.private_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.match(this.private_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
          }
          pubGenomeIds = this.union(pubGenomeIds, pubSet);
          pvtGenomeIds = this.union(pvtGenomeIds, pvtSet);
        } else {
          if (t.dataField === 'isolation_date') {
            pubSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pubGenomeIds.length; _j < _len1; _j++) {
                id = pubGenomeIds[_j];
                if (this.passDate(this.public_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
                id = pvtGenomeIds[_j];
                if (this.passDate(this.private_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pubGenomeIds = pubSet;
            pvtGenomeIds = pvtSet;
          } else {
            regex = new RegExp(escapeRegExp(t.searchTerm), "i");
            pubSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pubGenomeIds.length; _j < _len1; _j++) {
                id = pubGenomeIds[_j];
                if (this.match(this.public_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
                id = pvtGenomeIds[_j];
                if (this.match(this.private_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pubGenomeIds = pubSet;
            pvtGenomeIds = pvtSet;
          }
        }
      }
      return {
        "public": pubGenomeIds,
        "private": pvtGenomeIds
      };
    };

    GenomeController.prototype.match = function(genome, key, regex, negate) {
      var val;
      if (genome[key] == null) {
        return false;
      }
      val = genome[key];
      if (typeIsArray(genome[key])) {
        val = genome[key].toString();
      }
      if (regex.test(val)) {
        if (!negate) {
          return true;
        } else {
          return false;
        }
      } else {
        if (negate) {
          return true;
        } else {
          return false;
        }
      }
    };

    GenomeController.prototype.passDate = function(genome, before, date) {
      var d2, val;
      if (genome['isolation_date'] == null) {
        return false;
      }
      val = genome['isolation_date'][0];
      d2 = Date.parse(val);
      if (before) {
        if (d2 < date) {
          return true;
        } else {
          return false;
        }
      } else {
        if (d2 > date) {
          return true;
        } else {
          return false;
        }
      }
    };

    GenomeController.prototype.union = function(arr1, arr2) {
      var arr, i, _i, _len, _ref;
      arr = [];
      _ref = arr1.concat(arr2);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (__indexOf.call(arr, i) < 0) {
          arr.push(i);
        }
      }
      return arr;
    };

    GenomeController.prototype.label = function(genome, visibleMeta, joinStr) {
      var lab, mtypes, na, t, _i, _len, _ref, _ref1;
      if (joinStr == null) {
        joinStr = '|';
      }
      na = 'NA';
      lab = [genome.displayname];
      mtypes = ['strain', 'serotype', 'isolation_host', 'isolation_source', 'isolation_date', 'syndrome', 'stx1_subtype', 'stx2_subtype'];
      for (_i = 0, _len = mtypes.length; _i < _len; _i++) {
        t = mtypes[_i];
        if (visibleMeta[t]) {
          lab.push(((_ref = genome[t]) != null ? _ref : [na]).join(' '));
        }
      }
      if (visibleMeta.accession) {
        lab.push((_ref1 = genome.primary_dbxref) != null ? _ref1 : na);
      }
      return lab.join(joinStr);
    };

    GenomeController.prototype.labelHTML = function(genome, visibleMeta, joinStr) {
      var i, lab, mtypes, na, t, _i, _j, _len, _len1, _ref, _ref1;
      if (joinStr == null) {
        joinStr = ' ';
      }
      na = 'NA';
      lab = [genome.displayname];
      mtypes = ['strain', 'serotype', 'isolation_host', 'isolation_source', 'isolation_date', 'syndrome', 'stx1_subtype', 'stx2_subtype'];
      for (_i = 0, _len = mtypes.length; _i < _len; _i++) {
        t = mtypes[_i];
        if (visibleMeta[t]) {
          if (genome[t] != null) {
            _ref = genome[t];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              i = _ref[_j];
              lab.push('<span class="label label-default">' + i + '</span>');
            }
          } else {
            lab.push('<span class="label label-default">' + [na] + '</span>');
          }
        }
      }
      if (visibleMeta.accession) {
        lab.push((_ref1 = genome.primary_dbxref) != null ? _ref1 : na);
      }
      return lab.join(joinStr);
    };

    GenomeController.prototype.updateMeta = function(option, checked) {
      console.log(option);
      if (this.visibleMeta[option] == null) {
        throw new SuperphyError('unrecognized option in GenomeController method updateMeta()');
        return false;
      }
      if (!(checked === true || checked === false)) {
        throw new SuperphyError('invalid checked argument in GenomeController method updateMeta()');
        return false;
      }
      this.visibleMeta[option] = checked;
      this.update();
      return true;
    };

    GenomeController.prototype.select = function(g, checked) {
      if (this.publicRegexp.test(g)) {
        this.public_genomes[g].isSelected = checked;
        alert('selected public: ' + g + ' value:' + checked);
      } else {
        this.private_genomes[g].isSelected = checked;
        alert('selected private: ' + g + ' value:' + checked);
      }
      return true;
    };

    GenomeController.prototype.selected = function() {
      var k, pub, pvt, v;
      pub = [];
      pvt = [];
      pub = (function() {
        var _ref, _results;
        _ref = this.public_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.isSelected != null) && v.isSelected === true) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      pvt = (function() {
        var _ref, _results;
        _ref = this.private_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.isSelected != null) && v.isSelected === true) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    GenomeController.prototype.unselectAll = function() {
      var k, v, _ref, _ref1, _results;
      _ref = this.public_genomes;
      for (k in _ref) {
        v = _ref[k];
        if (v.isSelected != null) {
          v.isSelected = false;
        }
      }
      _ref1 = this.private_genomes;
      _results = [];
      for (k in _ref1) {
        v = _ref1[k];
        if (v.isSelected != null) {
          _results.push(v.isSelected = false);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    GenomeController.prototype.assignGroup = function(gset, grpNum) {
      var cls, g, _i, _j, _len, _len1, _ref, _ref1;
      if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
        _ref = gset["public"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          this.public_genomes[g].assignedGroup = grpNum;
          cls = 'genome_group' + grpNum;
          this.public_genomes[g].cssClass = cls;
        }
      }
      if ((gset["private"] != null) && typeof gset["private"] !== 'undefined') {
        _ref1 = gset["private"];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          this.private_genomes[g].assignedGroup = grpNum;
          cls = 'genome_group' + grpNum;
          this.private_genomes[g].cssClass = cls;
        }
      }
      return true;
    };

    GenomeController.prototype.deleteGroup = function(gset) {
      var g, _i, _j, _len, _len1, _ref, _ref1;
      if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
        _ref = gset["public"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          this.public_genomes[g].assignedGroup = null;
          this.public_genomes[g].cssClass = null;
        }
      }
      if ((gset["private"] != null) && typeof gset["public"] !== 'undefined') {
        _ref1 = gset["private"];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          this.private_genomes[g].assignedGroup = null;
          this.private_genomes[g].cssClass = null;
        }
      }
      return true;
    };

    GenomeController.prototype.grouped = function(grpNum) {
      var k, pub, pvt, v;
      pub = [];
      pvt = [];
      pub = (function() {
        var _ref, _results;
        _ref = this.public_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.assignedGroup != null) && v.assignedGroup === grpNum) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      pvt = (function() {
        var _ref, _results;
        _ref = this.private_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.assignedGroup != null) && v.assignedGroup === grpNum) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    GenomeController.prototype.genomeSet = function(gids) {
      var g, pub, pvt;
      pub = [];
      pvt = [];
      pub = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = gids.length; _i < _len; _i++) {
          g = gids[_i];
          if (this.publicRegexp.test(g)) {
            _results.push(g);
          }
        }
        return _results;
      }).call(this);
      pvt = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = gids.length; _i < _len; _i++) {
          g = gids[_i];
          if (this.privateRegexp.test(g)) {
            _results.push(g);
          }
        }
        return _results;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    GenomeController.prototype.genome = function(gid) {
      if (this.publicRegexp.test(gid)) {
        return this.public_genomes[gid];
      } else {
        return this.private_genomes[gid];
      }
    };

    return GenomeController;

  })();


  /*
   CLASS LocusController
   
   Manages locus data
   */

  LocusController = (function() {
    function LocusController(locusData) {
      this.locusData = locusData;
      this.dataValues = {};
      this.format();
    }

    LocusController.prototype.emptyString = "<span class='locus_group0'>NA</span>";

    LocusController.prototype.format = function() {
      var dataGroup, g, grpNum, k, o, val, _ref;
      for (g in this.locusData) {
        _ref = this.locusData[g];
        for (k in _ref) {
          o = _ref[k];
          val = o.data;
          dataGroup = 0;
          if (this.dataValues[val] != null) {
            dataGroup = this.dataValues[val];
          } else {
            grpNum = Object.keys(this.dataValues).length;
            grpNum++;
            this.dataValues[val] = grpNum;
            dataGroup = grpNum;
          }
          o.cls = "locus_group" + dataGroup;
          o.group = dataGroup;
          o.dataString = "<span class='" + o.cls + "'>" + val + "</span>";
        }
      }
      return true;
    };

    LocusController.prototype.locusString = function(id, locusID) {
      var g, genomeID, l, res, str;
      if (locusID == null) {
        locusID = null;
      }
      genomeID;
      if (locusID != null) {
        genomeID = id;
      } else {
        res = parseHeader(id);
        genomeID = res[1];
        locusID = res[2];
        if (!((genomeID != null) && (locusID != null))) {
          throw new SuperphyError("Invalid locus ID format: " + id + ".");
        }
      }
      g = this.locusData[genomeID];
      if (g == null) {
        throw new SuperphyError("Unknown genome: " + genomeID + ".");
      }
      l = g[locusID];
      if (l == null) {
        throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
      }
      str;
      if (l.copy > 1) {
        str = " (" + l.copy + " copy) -  " + l.dataString;
      } else {
        str = ' - ' + l.dataString;
      }
      return str;
    };

    LocusController.prototype.locusNode = function(id, locusID) {
      var g, genomeID, l, res, str;
      if (locusID == null) {
        locusID = null;
      }
      genomeID;
      if (locusID != null) {
        genomeID = id;
      } else {
        res = parseHeader(id);
        genomeID = res[1];
        locusID = res[2];
        if (!((genomeID != null) && (locusID != null))) {
          throw new SuperphyError("Invalid locus ID format: " + id + ".");
        }
      }
      g = this.locusData[genomeID];
      if (g == null) {
        throw new SuperphyError("Unknown genome: " + genomeID + ".");
      }
      l = g[locusID];
      if (l == null) {
        throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
      }
      str;
      if (l.copy > 1) {
        str = " (" + l.copy + " copy) -  " + l.data;
      } else {
        str = ' - ' + l.data;
      }
      return [str, l.group];
    };

    LocusController.prototype.genomeString = function(genomeID) {
      var ds, g, k, str, v;
      str = ' - ';
      g = this.locusData[genomeID];
      if (g != null) {
        ds = (function() {
          var _results;
          _results = [];
          for (k in g) {
            v = g[k];
            _results.push(v.dataString);
          }
          return _results;
        })();
        str += ds.join(',');
      } else {
        str += this.emptyString;
      }
      return str;
    };

    LocusController.prototype.count = function(genomes) {
      var uniqueValues;
      uniqueValues = {
        'NA': 0
      };
      this._count(genomes.pubVisible, uniqueValues);
      this._count(genomes.pvtVisible, uniqueValues);
      return uniqueValues;
    };

    LocusController.prototype._count = function(genomeList, uniqueValues) {
      var g, gID, k, v, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = genomeList.length; _i < _len; _i++) {
        gID = genomeList[_i];
        g = this.locusData[gID];
        if (g != null) {
          _results.push((function() {
            var _results1;
            _results1 = [];
            for (k in g) {
              v = g[k];
              if (uniqueValues[v.data] != null) {
                _results1.push(uniqueValues[v.data]++);
              } else {
                _results1.push(uniqueValues[v.data] = 1);
              }
            }
            return _results1;
          })());
        } else {
          _results.push(uniqueValues['NA']++);
        }
      }
      return _results;
    };

    return LocusController;

  })();

  if (!root.LocusController) {
    root.LocusController = LocusController;
  }


  /*
   CLASS SelectionView
   
   A special type of genome list that is used to temporarily store the user's
   selected genomes.
   
   Only one 'style' which provides a remove button to remove group from group.
   Will be updated by changes to the meta-display options but not by filtering.
   */

  SelectionView = (function() {
    function SelectionView(parentElem, countElem, elNum) {
      this.parentElem = parentElem;
      this.countElem = countElem != null ? countElem : null;
      this.elNum = elNum != null ? elNum : 1;
      this.elID = this.elName + this.elNum;
      this.count = 0;
    }

    SelectionView.prototype.type = 'selected';

    SelectionView.prototype.elNum = 1;

    SelectionView.prototype.elName = 'selected_genomes';

    SelectionView.prototype.elID = void 0;

    SelectionView.prototype.update = function(genomes) {
      var ingrp, listElem;
      listElem = jQuery("#" + this.elID);
      if (listElem.length) {
        listElem.empty();
      } else {
        listElem = jQuery("<ul id='" + this.elID + "' class='selected-group-list'/>");
        jQuery(this.parentElem).append(listElem);
      }
      ingrp = genomes.selected();
      this._appendGenomes(listElem, ingrp["public"], genomes.public_genomes);
      this._appendGenomes(listElem, ingrp["private"], genomes.private_genomes);
      this.count = ingrp["public"].length;
      this.count += ingrp["private"].length;
      this._updateCount();
      return true;
    };

    SelectionView.prototype._appendGenomes = function(el, visibleG, genomes) {
      var actionEl, cls, g, listEl, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        listEl = jQuery(("<li class='" + cls + "'>") + genomes[g].viewname + '</li>');
        actionEl = jQuery("<a href='#' data-genome='" + g + "'> <i class='fa fa-times'></a>");
        actionEl.click(function(e) {
          var gid;
          e.preventDefault();
          gid = this.dataset.genome;
          console.log('clicked unselect on ' + gid);
          return viewController.select(gid, false);
        });
        listEl.append(actionEl);
        el.append(listEl);
      }
      return true;
    };

    SelectionView.prototype.select = function(genomeID, genomes, checked) {
      var gset;
      if (checked) {
        gset = genomes.genomeSet([genomeID]);
        this.add(gset, genomes);
      } else {
        this.remove(genomeID);
      }
      return true;
    };

    SelectionView.prototype.add = function(genomeSet, genomes) {
      var listElem;
      listElem = jQuery("#" + this.elID);
      if (!listElem.length) {
        listElem = jQuery("<ul id='" + this.elID + "' class='selected-group-list'/>");
        jQuery(this.parentElem).append(listElem);
      }
      if (genomeSet["public"] != null) {
        this._appendGenomes(listElem, genomeSet["public"], genomes.public_genomes);
      }
      if (genomeSet["private"] != null) {
        this._appendGenomes(listElem, genomeSet["private"], genomes.private_genomes);
      }
      this.count += genomeSet["public"].length;
      this.count += genomeSet["private"].length;
      return this._updateCount();
    };

    SelectionView.prototype.remove = function(gid) {
      var descriptor, linkEl, listEl;
      listEl = jQuery("#" + this.elID);
      if (!((listEl != null) && listEl.length)) {
        throw new SuperphyError("DOM element for group view " + this.elID + " not found. Cannot call SelectionView method remove().");
      }
      descriptor = "li > a[data-genome='" + gid + "']";
      linkEl = listEl.find(descriptor);
      if (!((linkEl != null) && linkEl.length)) {
        throw new SuperphyError("List item element for genome " + gid + " not found in SelectionView");
        return false;
      }
      linkEl.parent('li').remove();
      this.count--;
      this._updateCount();
      return true;
    };

    SelectionView.prototype.cssClass = function() {
      return this.elName + '_item';
    };

    SelectionView.prototype._updateCount = function() {
      var innerElem;
      if (this.countElem != null) {
        innerElem = this.countElem.find('span.selected_genome_count_text');
        if (!innerElem.length) {
          innerElem = jQuery("<span class='selected_genome_count_text'></span>").appendTo(this.countElem);
        }
        innerElem.text("" + this.count + " genomes selected");
      }
      return true;
    };

    return SelectionView;

  })();


  /*
  
    HELPER FUNCTIONS
   */

  parseHeader = function(str) {
    var match;
    match = /^((?:public|private)_\d+)\|(\d+)/.exec(str);
    return match;
  };

  typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  escapeRegExp = function(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  cmp = function(a, b) {
    if (a > b) {
      return 1;
    } else if (a < b) {
      return -1;
    } else {
      return 0;
    }
  };

  trimInput = function(str, field) {
    var term;
    if (str != null) {
      term = jQuery.trim(str);
      if (term.length) {
        return term;
      } else {
        alert("Error: " + field + " is empty.");
        return null;
      }
    } else {
      alert("Error: " + field + " is empty.");
      return null;
    }
  };


  /*
  
  
   File: superphy_tree.coffee
   Desc: Phylogenetic Tree View Class
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: March 20th, 2013
   */

  d3.selection.prototype.moveToFront = function() {
    return this.each(function() {
      return this.parentNode.appendChild(this);
    });
  };


  /*
   CLASS TreeView
    
   Phylogenetic tree view
   
   Can be genome- or locus-based
   Returns genome ID to redirect/select if leaf node is clicked
   */

  TreeView = (function(_super) {
    __extends(TreeView, _super);

    function TreeView(parentElem, style, elNum, treeArgs) {
      var dialog, legendID, num;
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      if (!(treeArgs.length > 0)) {
        throw new SuperphyError('Missing argument. TreeView constructor requires JSON tree object.');
      }
      this.root = this.trueRoot = treeArgs[0];
      this.currentGenomeSet = -1;
      this.dim = {
        w: 700,
        h: 800
      };
      this.margin = {
        top: 20,
        right: 180,
        bottom: 20,
        left: 20
      };
      if (treeArgs[1] != null) {
        this.locusData = treeArgs[1];
      }
      if (treeArgs[2] != null) {
        this.dim = treeArgs[2];
      }
      if (treeArgs[3] != null) {
        this.margin = treeArgs[3];
      }
      TreeView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this.width = this.dim.w - this.margin.right - this.margin.left;
      this.height = this.dim.h - this.margin.top - this.margin.bottom;
      this.xzoom = d3.scale.linear().domain([0, this.width]).range([0, this.width]);
      this.yzoom = d3.scale.linear().domain([0, this.height]).range([0, this.height]);
      this.cluster = d3.layout.cluster().size([this.width, this.height]).sort(null).value(function(d) {
        return Number(d.length);
      }).separation(function(a, b) {
        return 1;
      });
      legendID = "tree_legend" + this.elNum;
      this.parentElem.append("<div class='tree_legend_link'><a href='#" + legendID + "'>Functions List</a></div>");
      this.parentElem.append("<div id='" + this.elID + "' class='" + (this.cssClass()) + "'></div>");
      this.wrap = d3.select("#" + this.elID).append("svg").attr("width", this.dim.w).attr("height", this.dim.h).style("-webkit-backface-visibility", "hidden");
      this.canvas = this.wrap.append("g").attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");
      num = this.elNum - 1;
      this.wrap.call(d3.behavior.zoom().x(this.xzoom).y(this.yzoom).scaleExtent([1, 8]).on("zoom", function() {
        return viewController.getView(num).zoomed();
      }));
      jQuery("<div id='" + legendID + "' class='genome_tree_legend'></div>").appendTo(this.parentElem);
      this.wrap2 = d3.select("#" + legendID).append("svg").attr("width", this.dim.w).attr("height", 100).style("-webkit-backface-visibility", "hidden");
      this.legend = this.wrap2.append("g").attr("transform", "translate(" + 5 + "," + 5 + ")");
      this._legend(this.legend);
      if (this.style === 'select') {
        dialog = jQuery('#dialog-clade-select');
        if (!dialog.length) {
          dialog = jQuery('<div id="dialog-clade-select"></div>').appendTo('body');
          dialog.text("Select/unselect genomes in clade:").dialog({
            dialogClass: 'noTitleStuff',
            autoOpen: false,
            resizable: false,
            height: 120,
            modal: true,
            buttons: {
              Select: function() {
                var node;
                node = jQuery(this).data("clade-node");
                viewController.getView(num).selectClade(node, true);
                return jQuery(this).dialog("close");
              },
              Unselect: function() {
                var node;
                node = jQuery(this).data("clade-node");
                viewController.getView(num).selectClade(node, false);
                return jQuery(this).dialog("close");
              },
              Cancel: function() {
                return jQuery(this).dialog("close");
              }
            }
          });
        }
      }
      this._prepTree();
      true;
    }

    TreeView.prototype.type = 'tree';

    TreeView.prototype.elName = 'genome_tree';

    TreeView.prototype.nodeId = 0;

    TreeView.prototype.duration = 1000;

    TreeView.prototype.expandDepth = 5;

    TreeView.prototype.x_factor = 1.5;

    TreeView.prototype.y_factor = 5000;

    TreeView.prototype.update = function(genomes, sourceNode) {
      var branch_scale_factor_x, branch_scale_factor_y, cladeSelect, cmdBox, currLeaves, dt, elID, farthest, iNodes, id, leaves, linksEnter, lowest, n, nodesEnter, nodesExit, nodesUpdate, num, oldRoot, svgLinks, svgNode, svgNodes, t1, t2, xedge, yedge, _i, _j, _len, _len1, _ref, _ref1;
      if (sourceNode == null) {
        sourceNode = null;
      }
      t1 = new Date();
      oldRoot = this.root;
      this._sync(genomes);
      this.nodes = this.cluster.nodes(this.root);
      if (sourceNode == null) {
        sourceNode = this.root;
      }
      this.launchPt = {
        x: sourceNode.x,
        y: sourceNode.y,
        x0: sourceNode.x0,
        y0: sourceNode.y0
      };
      farthest = d3.max(this.nodes, function(d) {
        return d.sum_length * 1;
      });
      lowest = d3.max(this.nodes, function(d) {
        return d.x;
      });
      yedge = this.width - 20;
      xedge = this.height - 20;
      branch_scale_factor_y = this.y_factor;
      if ((branch_scale_factor_y * farthest) > yedge) {
        branch_scale_factor_y = yedge / farthest;
      }
      branch_scale_factor_x = this.x_factor;
      if ((branch_scale_factor_x * lowest) > xedge) {
        branch_scale_factor_x = xedge / lowest;
      }
      console.log('y' + branch_scale_factor_y);
      console.log('x' + branch_scale_factor_x);
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        n.y = n.sum_length * branch_scale_factor_y;
        n.x = n.x * branch_scale_factor_x;
      }
      svgNodes = this.canvas.selectAll("g.treenode").data(this.nodes, function(d) {
        return d.id;
      });
      svgLinks = this.canvas.selectAll("path.treelink").data(this.cluster.links(this.nodes), function(d) {
        return d.target.id;
      });
      linksEnter = svgLinks.enter().insert("path").attr("class", "treelink").attr("d", (function(_this) {
        return function(d) {
          var p;
          p = {
            x: _this.launchPt.x0,
            y: _this.launchPt.y0
          };
          return _this._step({
            source: p,
            target: p
          });
        };
      })(this));
      svgLinks.transition().duration(this.duration).attr("d", this._step);
      svgLinks.exit().transition().duration(this.duration).attr("d", (function(_this) {
        return function(d) {
          var o;
          o = {
            x: _this.launchPt.x,
            y: _this.launchPt.y
          };
          return _this._step({
            source: o,
            target: o
          });
        };
      })(this)).remove();
      currLeaves = svgNodes.filter(function(d) {
        return d.leaf;
      }).attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this)).on("click", function(d) {
        if (d.assignedGroup == null) {
          return viewController.select(d.genome, !d.selected);
        } else {
          return null;
        }
      });
      currLeaves.select("circle").style("fill", function(d) {
        if (d.selected) {
          return "lightsteelblue";
        } else {
          return "#fff";
        }
      });
      svgNodes.select("text").text(function(d) {
        if (d.leaf) {
          return d.viewname;
        } else {
          return d.label;
        }
      });
      nodesEnter = svgNodes.enter().append("g").attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this)).attr("id", function(d) {
        return "treenode" + d.id;
      }).attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.launchPt.y0 + "," + _this.launchPt.x0 + ")";
        };
      })(this));
      leaves = nodesEnter.filter(function(d) {
        return d.leaf;
      });
      leaves.append("circle").attr("r", 1e-6).style("fill", function(d) {
        if (d.selected) {
          return "lightsteelblue";
        } else {
          return "#fff";
        }
      });
      if (this.style === 'select') {
        leaves.on("click", function(d) {
          if (d.assignedGroup == null) {
            return viewController.select(d.genome, !d.selected);
          } else {
            return null;
          }
        });
      } else {
        leaves.on("click", function(d) {
          return viewController.redirect(d.genome);
        });
      }
      nodesEnter.append("text").attr("class", "treelabel").attr("dx", ".6em").attr("dy", ".4em").attr("text-anchor", "start").text(function(d) {
        if (d.leaf) {
          return d.viewname;
        } else {
          return d.label;
        }
      }).style("fill-opacity", 1e-6);
      iNodes = nodesEnter.filter(function(n) {
        return !n.leaf && !n.root;
      });
      num = this.elNum - 1;
      cmdBox = iNodes.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("y", 4).attr("x", -8).text(function(d) {
        return "\uf0fe";
      });
      cmdBox.on("click", function(d) {
        return viewController.viewAction(num, 'expand_collapse', d, this.parentNode);
      });
      if (this.style === 'select') {
        cladeSelect = iNodes.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -25);
        cladeSelect.on("click", function(d) {
          return jQuery('#dialog-clade-select').data('clade-node', d).dialog('open');
        });
      }
      nodesUpdate = svgNodes.transition().duration(this.duration).attr("transform", function(d) {
        return "translate(" + d.y + "," + d.x + ")";
      });
      nodesUpdate.select("circle").attr("r", 4);
      nodesUpdate.filter(function(d) {
        return !d.children;
      }).select("text").style("fill-opacity", 1);
      nodesUpdate.select(".expandcollapse").text(function(d) {
        if (d._children != null) {
          return "\uf0fe";
        } else {
          return "\uf146";
        }
      });
      nodesExit = svgNodes.exit().transition().duration(this.duration).attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.launchPt.y + "," + _this.launchPt.x + ")";
        };
      })(this)).remove();
      nodesExit.select("circle").attr("r", 1e-6);
      nodesExit.select("text").style("fill-opacity", 1e-6);
      nodesExit.select("rect").attr("width", 1e-6).attr("height", 1e-6);
      if (!oldRoot.root && this.root !== oldRoot) {
        id = oldRoot.id;
        elID = "treenode" + id;
        svgNode = this.canvas.select("#" + elID);
        svgNode.moveToFront();
      }
      _ref1 = this.nodes;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        n = _ref1[_j];
        n.x0 = n.x;
        n.y0 = n.y;
      }
      t2 = new Date();
      dt = new Date(t2 - t1);
      console.log('TreeView update elapsed time (sec): ' + dt.getSeconds());
      return true;
    };

    TreeView.prototype.updateCSS = function(gset, genomes) {
      var g, genomeList, svgNodes, updateNodes, _i, _j, _len, _len1, _ref, _ref1;
      genomeList = {};
      if (gset["public"] != null) {
        _ref = gset["public"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          genomeList[g] = genomes.public_genomes[g];
        }
      }
      if (gset["private"] != null) {
        _ref1 = gset["private"];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          genomeList[g] = genomes.private_genomes[g];
        }
      }
      svgNodes = this.canvas.selectAll("g.treenode");
      updateNodes = svgNodes.filter(function(d) {
        return genomeList[d.genome] != null;
      }).attr("class", (function(_this) {
        return function(d) {
          g = genomeList[d.genome];
          d.selected = (g.isSelected != null) && g.isSelected;
          d.assignedGroup = g.assignedGroup;
          return _this._classList(d);
        };
      })(this));
      updateNodes.on("click", function(d) {
        if (d.assignedGroup == null) {
          return viewController.select(d.genome, !d.selected);
        } else {
          return null;
        }
      });
      return true;
    };

    TreeView.prototype.viewAction = function(genomes, argArray) {
      var event;
      event = argArray.shift();
      if (event === 'expand_collapse') {
        this._expandCollapse(genomes, argArray[0], argArray[1]);
      } else {
        throw new SuperphyError("Unrecognized event type: " + event + " in TreeView viewAction method.");
      }
      return true;
    };

    TreeView.prototype.selectClade = function(node, checked) {
      var c, _i, _j, _len, _len1, _ref, _ref1, _results, _results1;
      if (node.leaf) {
        return viewController.select(node.genome, checked);
      } else {
        if (node.children != null) {
          _ref = node.children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(this.selectClade(c, checked));
          }
          return _results;
        } else if (node._children != null) {
          _ref1 = node._children;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            c = _ref1[_j];
            _results1.push(this.selectClade(c, checked));
          }
          return _results1;
        }
      }
    };

    TreeView.prototype.select = function(genome, isSelected) {
      var d, svgNodes, updateNode;
      svgNodes = this.canvas.selectAll("g.treenode");
      updateNode = svgNodes.filter(function(d) {
        return d.genome === genome;
      }).attr("class", (function(_this) {
        return function(d) {
          d.selected = isSelected;
          return _this._classList(d);
        };
      })(this));
      updateNode.select("circle").style("fill", function(d) {
        if (d.selected) {
          return "lightsteelblue";
        } else {
          return "#fff";
        }
      });
      d = updateNode.datum();
      console.log(updateNode);
      console.log(d.parent);
      this._percolateSelected(d.parent, isSelected);
      svgNodes.filter(function(d) {
        return !d.leaf;
      }).attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this));
      return true;
    };

    TreeView.prototype._percolateSelected = function(node, checked) {
      if (node == null) {
        return true;
      }
      if (checked) {
        node.num_selected++;
      } else {
        node.num_selected--;
      }
      if (node.num_selected === node.num_leaves) {
        node.internal_node_selected = 2;
      } else if (node.num_selected > 0) {
        node.internal_node_selected = 1;
      } else {
        node.internal_node_selected = 0;
      }
      this._percolateSelected(node.parent, checked);
      return true;
    };

    TreeView.prototype.dump = function(genomes) {
      var output, tokens;
      tokens = [];
      this._printNode(genomes, this.root, tokens);
      output = tokens.join('');
      return {
        ext: 'newick',
        type: 'text/plain',
        data: output
      };
    };

    TreeView.prototype._printNode = function(genomes, node, tokens) {
      var c, children, g, lab, _i, _len;
      if (node.leaf) {
        g = genomes.genome(node.genome);
        lab = genomes.label(g, genomes.visibleMeta);
        tokens.push("\"" + lab + "\"", ':', node.length);
      } else {
        children = node.children;
        if (node._children != null) {
          children = node._children;
        }
        tokens.push('(');
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          c = children[_i];
          this._printNode(genomes, c, tokens);
          tokens.push(',');
        }
        tokens[tokens.length - 1] = ')';
        tokens.push("\"" + node.name + "\"", ':', node.length);
      }
      return true;
    };

    TreeView.prototype._step = function(d) {
      return "M" + d.source.y + "," + d.source.x + "L" + d.source.y + "," + d.target.x + "L" + d.target.y + "," + d.target.x;
    };

    TreeView.prototype._prepTree = function() {
      var gPattern;
      this.trueRoot.root = true;
      this.trueRoot.x0 = this.height / 2;
      this.trueRoot.y0 = 0;
      gPattern = /^((?:public_|private_)\d+)\|/;
      return this._assignKeys(this.trueRoot, 0, gPattern);
    };

    TreeView.prototype._assignKeys = function(n, i, gPattern) {
      var m, res, _i, _j, _len, _len1, _ref, _ref1;
      n.id = i;
      n.storage = n.length * 1;
      i++;
      if (n.children != null) {
        n.num_selected = 0;
        n.daycare = n.children.slice();
        _ref = n.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          m = _ref[_i];
          i = this._assignKeys(m, i, gPattern);
        }
      } else if (n._children != null) {
        n.num_selected = 0;
        n.daycare = n._children.slice();
        _ref1 = n._children;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          m = _ref1[_j];
          i = this._assignKeys(m, i, gPattern);
        }
      }
      if ((n.leaf != null) && n.leaf === "true") {
        if (this.locusData != null) {
          res = gPattern.exec(n.name);
          if (res == null) {
            throw new SuperphyError("Invalid tree node key. Expecting: genome|locus. Recieved: " + n.name);
          }
          n.genome = res[1];
        } else {
          n.genome = n.name;
        }
      }
      return i;
    };

    TreeView.prototype._sync = function(genomes) {
      console.log('sync');
      this.root = this._syncNode(this.trueRoot, genomes, 0);
      if (genomes.genomeSetId !== this.currentGenomeSet) {
        this._expansionLayout();
        this.currentGenomeSet = genomes.genomeSetId;
      }
      return true;
    };

    TreeView.prototype._syncNode = function(node, genomes, sumLengths) {
      var c, child, children, g, isExpanded, ld, u, _i, _len, _ref;
      node.length = node.storage * 1;
      node.sum_length = sumLengths + node.length;
      if ((node.leaf != null) && node.leaf === "true") {
        g = genomes.genome(node.genome);
        if ((g != null) && g.visible) {
          node.viewname = g.viewname;
          node.selected = (g.isSelected != null) && g.isSelected;
          node.assignedGroup = g.assignedGroup;
          node.hidden = false;
          if (this.locusData != null) {
            ld = this.locusData.locusNode(node.name);
            node.viewname += ld[0];
            node.assignedGroup = ld[1];
          }
        } else {
          node.hidden = true;
        }
      } else {
        isExpanded = true;
        if (node._children != null) {
          isExpanded = false;
        }
        children = [];
        _ref = node.daycare;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          u = this._syncNode(c, genomes, node.sum_length);
          if (!u.hidden) {
            children.push(u);
          }
        }
        if (children.length === 0) {
          node.hidden = true;
        } else if (children.length === 1) {
          node.hidden = true;
          child = children[0];
          child.length += node.length;
          return child;
        } else {
          node.hidden = false;
          if (isExpanded) {
            node.children = children;
          } else {
            node._children = children;
          }
        }
      }
      return node;
    };

    TreeView.prototype._cloneNode = function(node) {
      var copy, k, v;
      copy = {};
      for (k in node) {
        v = node[k];
        if (!(k === 'children' || k === '_children')) {
          copy[k] = v;
        }
      }
      return copy;
    };

    TreeView.prototype._expansionLayout = function(focusNode) {
      if (focusNode == null) {
        focusNode = null;
      }
      this._formatNode(this.root, 0, focusNode);
      this.root.x0 = this.height / 2;
      this.root.y0 = 0;
      this.root.root = true;
      return true;
    };

    TreeView.prototype._formatNode = function(node, depth, parentNode, focusNode) {
      var c, children, current_depth, isExpanded, r, record, _i, _len, _ref;
      if (parentNode == null) {
        parentNode = null;
      }
      if (focusNode == null) {
        focusNode = null;
      }
      if (node.hidden) {
        return null;
      }
      current_depth = depth + 1;
      record = {};
      node.parent = parentNode;
      node.root = false;
      if ((node.leaf != null) && node.leaf === "true") {
        record['num_leaves'] = 1;
        record['outgroup'] = node.label;
        record['depth'] = current_depth;
        record['length'] = node.length;
        record['num_selected'] = (_ref = node.selected) != null ? _ref : {
          1: 0
        };
        return record;
      } else {
        isExpanded = true;
        children = node.children;
        if (node._children != null) {
          isExpanded = false;
          children = node._children;
        }
        if (current_depth < this.expandDepth) {
          node.children = children;
          node._children = null;
        } else if (isExpanded) {
          node.children = children;
          node._children = null;
        } else {
          node._children = children;
          node.children = null;
        }
        record = {
          num_leaves: 0,
          num_selected: 0,
          outgroup: '',
          depth: 1e6,
          length: 0
        };
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          c = children[_i];
          r = this._formatNode(c, current_depth, node, focusNode);
          record['num_leaves'] += r['num_leaves'];
          record['num_leaves'] += r['num_selected'];
          if ((record['depth'] > r['depth']) || (record['depth'] === r['depth'] && record['length'] < r['length'])) {
            record['depth'] = r['depth'];
            record['length'] = r['length'];
            record['outgroup'] = r['outgroup'];
          }
        }
        node.label = "" + record['num_leaves'] + " genomes (outgroup: " + record['outgroup'] + ")";
        node.num_leaves = record['num_leaves'];
        node.num_selected = record['num_selected'];
        if (node.num_selected === node.num_leaves) {
          node.internal_node_selected = 2;
        } else if (node.num_selected > 0) {
          node.internal_node_selected = 1;
        } else {
          node.internal_node_selected = 0;
        }
      }
      return record;
    };

    TreeView.prototype._expandCollapse = function(genomes, d, el) {
      var c, svgNode, _i, _len, _ref;
      svgNode = d3.select(el);
      if (d.children != null) {
        d._children = d.children;
        d.children = null;
      } else {
        d.children = d._children;
        d._children = null;
        svgNode.select("text").transition().duration(this.duration).style("fill-opacity", 1e-6);
        _ref = d.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          if (c._children != null) {
            c.children = c._children;
            c._children = null;
            d3.select("#treenode" + c.id).select("text").transition().duration(this.duration).style("fill-opacity", 1e-6);
          }
        }
      }
      this.update(genomes, d);
      return true;
    };

    TreeView.prototype.zoomed = function() {
      this.canvas.selectAll("g.treenode").attr("transform", (function(_this) {
        return function(d) {
          return _this._zTransform(d, _this.xzoom, _this.yzoom);
        };
      })(this));
      this.canvas.selectAll("path.treelink").attr("d", (function(_this) {
        return function(d) {
          return _this._zTranslate(d, _this.xzoom, _this.yzoom);
        };
      })(this));
      return true;
    };

    TreeView.prototype._zTranslate = function(d, xzoom, yzoom) {
      var sourceX, sourceY, targetX, targetY;
      sourceX = xzoom(d.source.y);
      sourceY = yzoom(d.source.x);
      targetX = xzoom(d.target.y);
      targetY = yzoom(d.target.x);
      return "M" + sourceX + "," + sourceY + "L" + sourceX + "," + targetY + "L" + targetX + "," + targetY;
    };

    TreeView.prototype._zTransform = function(d, xzoom, yzoom) {
      return "translate(" + xzoom(d.y) + "," + yzoom(d.x) + ")";
    };

    TreeView.prototype._classList = function(d) {
      var clsList;
      clsList = ['treenode'];
      if (d.selected) {
        clsList.push("selectedNode");
      }
      if (d.focus) {
        clsList.push("focusNode");
      }
      if (d.assignedGroup != null) {
        clsList.push("groupedNode" + d.assignedGroup);
      }
      if (d.internal_node_selected != null) {
        if (d.internal_node_selected === 2) {
          clsList.push("internalSNodeFull");
        } else if (d.internal_node_selected === 1) {
          clsList.push("internalSNodePart");
        }
      }
      return clsList.join(' ');
    };

    TreeView.prototype._legend = function(el) {
      var cladeExpand, cladeSelect, colw, colw2, csColumn, ecColumn, expandCollapse, focusNode, genomeSelect, gsColumn, indent, lineh, lineh2, lineh3, lineh4, panZoom, pzRow, pzdx, pzdx2, pzdy, textdx, textdx2, textdy;
      lineh = 25;
      lineh2 = 40;
      lineh3 = 55;
      lineh4 = 80;
      textdx = ".6em";
      textdx2 = "2.5em";
      textdy = ".4em";
      pzdx = "3.2em";
      pzdx2 = "3.7em";
      pzdy = ".5em";
      indent = 8;
      colw = 245;
      colw2 = 480;
      if (this.style === 'select') {
        gsColumn = el.append("g").attr("transform", "translate(5," + lineh + ")");
        genomeSelect = gsColumn.append("g").attr("class", 'treenode');
        genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("fill", "#fff");
        genomeSelect.append("text").attr("class", "legendlabel1").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Click to select / unselect genome');
        genomeSelect = gsColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh + ")");
        genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("fill", "lightsteelblue");
        genomeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Selected genome');
        genomeSelect = gsColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh2 + ")");
        genomeSelect.append("circle").attr("r", 4).attr("cx", 0).attr("cy", 0).style("fill", "#fff");
        genomeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Unselected genome');
        csColumn = el.append("g").attr("transform", "translate(" + colw + "," + lineh + ")");
        cladeSelect = csColumn.append("g").attr("class", 'treenode');
        cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
        cladeSelect.append("text").attr("class", "legendlabel1").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Click to select / unselect clade');
        cladeSelect = csColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh + ")");
        cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
        cladeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('No genomes selected in clade');
        cladeSelect = csColumn.append("g").attr("class", 'treenode internalSNodePart').attr("transform", "translate(" + indent + "," + lineh2 + ")");
        cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
        cladeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Some genomes selected in clade');
        cladeSelect = csColumn.append("g").attr("class", 'treenode internalSNodeFull').attr("transform", "translate(" + indent + "," + lineh3 + ")");
        cladeSelect.append('rect').attr("class", "selectClade").attr("width", 8).attr("height", 8).attr("y", -4).attr("x", -4);
        cladeSelect.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('All genomes selected in clade');
        ecColumn = el.append("g").attr("transform", "translate(" + colw2 + "," + lineh + ")");
        expandCollapse = ecColumn.append("g").attr("class", 'treenode');
        expandCollapse.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("dy", 4).attr("dx", -1).text(function(d) {
          return "\uf0fe";
        });
        expandCollapse.append("text").attr("class", "legendlabel1").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Click to collapse / expand clade');
        expandCollapse = ecColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh + ")");
        expandCollapse.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("dy", 4).attr("dx", -1).text(function(d) {
          return "\uf146";
        });
        expandCollapse.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Expanded clade');
        expandCollapse = ecColumn.append("g").attr("class", 'treenode').attr("transform", "translate(" + indent + "," + lineh2 + ")");
        expandCollapse.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("dy", 4).attr("dx", -1).text(function(d) {
          return "\uf0fe";
        });
        expandCollapse.append("text").attr("class", "legendlabel2").attr("dx", textdx).attr("dy", textdy).attr("text-anchor", "start").text('Collapsed clade');
        pzRow = el.append("g").attr("transform", "translate(0,0)");
        panZoom = pzRow.append("g").attr("class", 'treenode');
        panZoom.append("text").attr("class", "slash").attr("dx", 0).attr("dy", ".5em").attr("text-anchor", "start").text('Pan');
        panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx).attr("dy", pzdy).attr("text-anchor", "start").text('Click & Drag');
        panZoom = pzRow.append("g").attr("class", 'treenode').attr("transform", "translate(" + colw + ",0)");
        panZoom.append("text").attr("class", "slash").attr("dx", "-.4em").attr("dy", ".5em").attr("text-anchor", "start").text('Zoom');
        return panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx).attr("dy", pzdy).attr("text-anchor", "start").text('Scroll');
      } else {
        genomeSelect = el.append("g").attr("class", 'treenode').attr("transform", "translate(5,0)");
        genomeSelect.append("circle").attr("r", 4).attr("cx", 8).attr("cy", 0).style("fill", "#fff");
        genomeSelect.append("text").attr("class", "legendlabel1").attr("dx", textdx2).attr("dy", textdy).attr("text-anchor", "start").text('Select genome');
        cladeExpand = el.append("g").attr("class", 'treenode').attr("transform", "translate(5, " + lineh + ")");
        cladeExpand.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("y", 4).attr("x", -1).text(function(d) {
          return "\uf0fe";
        });
        cladeExpand.append("text").attr("class", "slash").attr("dx", ".5em").attr("dy", ".5em").attr("text-anchor", "start").text('/');
        cladeExpand.append('text').attr("class", "treeicon expandcollapse").attr("text-anchor", 'middle').attr("y", 8).attr("x", 17).text(function(d) {
          return "\uf146";
        });
        cladeExpand.append("text").attr("class", "legendlabel1").attr("dx", textdx2).attr("dy", textdy).attr("text-anchor", "start").text('Expand / Collapse clade');
        panZoom = el.append("g").attr("class", 'treenode').attr("transform", "translate(" + colw + ",0)");
        panZoom.append("text").attr("class", "slash").attr("dx", 0).attr("dy", ".5em").attr("text-anchor", "start").text('Pan ');
        panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx2).attr("dy", pzdy).attr("text-anchor", "start").text('Click & Drag');
        panZoom = el.append("g").attr("class", 'treenode').attr("transform", "translate(" + colw + "," + lineh + ")");
        panZoom.append("text").attr("class", "slash").attr("dx", 0).attr("dy", ".5em").attr("text-anchor", "start").text('Zoom');
        panZoom.append("text").attr("class", "legendlabel1").attr("dx", pzdx2).attr("dy", pzdy).attr("text-anchor", "start").text('Scroll');
        focusNode = el.append("g").attr("class", 'treenode focusNode').attr("transform", "translate(" + colw2 + ",0)");
        focusNode.append("circle").attr("r", 4).attr("cx", 8).attr("cy", 2);
        return focusNode.append("text").attr("class", "legendlabel1").attr("dx", textdx2).attr("dy", textdy).attr("text-anchor", "start").text('Target genome');
      }
    };

    return TreeView;

  })(ViewTemplate);


  /*
  
  
   File: superphy_msa.coffee
   Desc: Multiple Sequence Alignment View Class
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: April 9th, 2013
   */


  /*
   CLASS MsaView
    
   Multiple Sequence Alignment view
   
   Always locus-based
   Returns nothing to redirect/select (no click behavior defined)
   */

  MsaView = (function(_super) {
    __extends(MsaView, _super);

    function MsaView(parentElem, style, elNum, msaArgs) {
      var alignmentJSON;
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      if (!(msaArgs.length > 0)) {
        throw new SuperphyError('Missing argument. MsaView constructor requires JSON alignment object.');
      }
      alignmentJSON = msaArgs[0];
      this.locusData = null;
      if (msaArgs[1] != null) {
        this.locusData = msaArgs[1];
      }
      MsaView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this._formatAlignment(alignmentJSON);
    }

    MsaView.prototype.type = 'msa';

    MsaView.prototype.elName = 'genome_msa';

    MsaView.prototype.blockLen = 70;

    MsaView.prototype.nameLen = 25;

    MsaView.prototype.consLine = 'conservation_line';

    MsaView.prototype.posLine = 'position_line';

    MsaView.prototype.nuclClasses = {
      'A': 'nuclA',
      'G': 'nuclG',
      'C': 'nuclC',
      'T': 'nuclT',
      '*': 'consM',
      ' ': 'consMM',
      '-': 'nuclGAP'
    };

    MsaView.prototype.cssClass = 'msa_row_name';

    MsaView.prototype._formatAlignment = function(alignmentJSON) {
      var g, i, j, n, pos, posElem, seq, seqLen, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
      this.rowIDs = (function() {
        var _results;
        _results = [];
        for (g in alignmentJSON) {
          _results.push(g);
        }
        return _results;
      })();
      i = this.rowIDs.indexOf(this.consLine);
      if (!(i >= 0)) {
        throw new SuperphyError('Alignment Object missing "conservation_line".');
      }
      this.rowIDs.splice(i, 1);
      seqLen = alignmentJSON[this.rowIDs[0]]['seq'].length;
      this.alignment = {};
      _ref = this.rowIDs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        this.alignment[n] = {
          'alignment': [],
          'seq': alignmentJSON[n]['seq'],
          'genome': alignmentJSON[n]['genome'],
          'locus': alignmentJSON[n]['locus']
        };
      }
      this.alignment[this.consLine] = {
        'alignment': []
      };
      this.alignment[this.posLine] = {
        'alignment': []
      };
      this.numBlock = 0;
      for (j = _j = 0, _ref1 = this.blockLen; _ref1 > 0 ? _j <= seqLen : _j >= seqLen; j = _j += _ref1) {
        this.numBlock++;
        _ref2 = this.rowIDs;
        for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
          n = _ref2[_k];
          seq = alignmentJSON[n]['seq'];
          this.alignment[n]['alignment'].push(this._formatBlock(seq.substr(j, this.blockLen)));
        }
        seq = alignmentJSON[this.consLine]['seq'];
        this.alignment[this.consLine]['alignment'].push(this._formatBlock(seq.substr(j, this.blockLen)));
        pos = j + 1;
        posElem = "<td class='msaPosition'>" + pos + "</td>";
        this.alignment[this.posLine]['alignment'].push(posElem);
      }
      return true;
    };

    MsaView.prototype._formatBlock = function(seq) {
      var c, chr, cls, html, _i, _ref;
      html = '';
      seq.toUpperCase();
      for (c = _i = 0, _ref = seq.length; 0 <= _ref ? _i <= _ref : _i >= _ref; c = 0 <= _ref ? ++_i : --_i) {
        chr = seq.charAt(c);
        cls = this.nuclClasses[chr];
        html += "<td class='" + cls + "'>" + chr + "</td>";
      }
      return html;
    };

    MsaView.prototype.update = function(genomes) {
      var ft, msaElem, t1, t2;
      msaElem = jQuery("#" + this.elID);
      if (msaElem.length) {
        msaElem.empty();
        msaElem.append('<tbody></tbody>');
      } else {
        msaElem = jQuery("<table id='" + this.elID + "'><tbody></tbody></table>");
        jQuery(this.parentElem).append(msaElem);
      }
      t1 = new Date();
      this._appendRows(msaElem, genomes);
      t2 = new Date();
      ft = t2 - t1;
      console.log('MsaView update elapsed time: ' + ft);
      return true;
    };

    MsaView.prototype._appendRows = function(el, genomes) {
      var a, g, genomeElem, genomeID, i, j, name, nameCell, rowEl, thiscls, tmp, visibleRows, _i, _j, _k, _len, _len1, _ref, _ref1;
      genomeElem = {};
      visibleRows = [];
      tmp = {};
      _ref = this.rowIDs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        a = this.alignment[i];
        genomeID = a['genome'];
        g = genomes.genome(genomeID);
        if (g.visible) {
          visibleRows.push(i);
          name = g.viewname;
          tmp[i] = name;
          if (this.locusData != null) {
            name += this.locusData.locusString(i);
          }
          thiscls = this.cssClass;
          if (g.cssClass != null) {
            thiscls = this.cssClass + ' ' + g.cssClass;
          }
          nameCell = "<td class='" + thiscls + "' data-genome='" + genomeID + "'>" + name + "</td>";
          genomeElem[i] = nameCell;
        }
      }
      visibleRows.sort(function(a, b) {
        var aname, bname;
        aname = tmp[a];
        bname = tmp[b];
        if (aname > bname) {
          return 1;
        } else if (aname < bname) {
          return -1;
        } else {
          return 0;
        }
      });
      for (j = _j = 0, _ref1 = this.numBlock; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        for (_k = 0, _len1 = visibleRows.length; _k < _len1; _k++) {
          i = visibleRows[_k];
          rowEl = jQuery('<tr></tr>');
          rowEl.append(genomeElem[i] + this.alignment[i]['alignment'][j]);
          el.append(rowEl);
        }
        rowEl = jQuery('<tr></tr>');
        rowEl.append('<td></td>' + this.alignment[this.consLine]['alignment'][j]);
        el.append(rowEl);
        rowEl = jQuery('<tr></tr>');
        rowEl.append(this.alignment[this.posLine]['alignment'][j]);
        el.append(rowEl);
      }
      return true;
    };

    MsaView.prototype.updateCSS = function(gset, genomes) {
      var msaEl;
      msaEl = jQuery("#" + this.elID);
      if (!((msaEl != null) && msaEl.length)) {
        throw new SuperphyError("DOM element for Msa view " + this.elID + " not found. Cannot call MsaView method updateCSS().");
      }
      if (gset["public"] != null) {
        this._updateGenomeCSS(listEl, gset["public"], genomes.public_genomes);
      }
      if (gset["private"] != null) {
        this._updateGenomeCSS(listEl, gset["private"], genomes.private_genomes);
      }
      return true;
    };

    MsaView.prototype._updateGenomeCSS = function(el, changedG, genomes) {
      var cls, descriptor, g, itemEl, liEl, thiscls, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = changedG.length; _i < _len; _i++) {
        g = changedG[_i];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        descriptor = "td[data-genome='" + g + "']";
        itemEl = el.find(descriptor);
        if (!((itemEl != null) && itemEl.length)) {
          throw new SuperphyError("Msa element for genome " + g + " not found in MsaView " + this.elID);
          return false;
        }
        console.log("Updating class to " + thiscls);
        liEl = itemEl.parents().eq(1);
        liEl.attr('class', thiscls);
      }
      return true;
    };

    MsaView.prototype.select = function(genome, isSelected) {
      return true;
    };

    MsaView.prototype.dump = function(genomes) {
      var a, g, genomeID, i, name, output, seq, _i, _len, _ref;
      output = '';
      _ref = this.rowIDs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        a = this.alignment[i];
        genomeID = a['genome'];
        g = genomes.genome(genomeID);
        if (g.visible) {
          name = g.viewname;
          if ((this.locusData != null) && (this.locusData[i] != null)) {
            name += this.locusData[i];
          }
          seq = a['seq'];
          output += ">" + name + "\n" + seq + "\n";
        }
      }
      return {
        ext: 'fasta',
        type: 'text/plain',
        data: output
      };
    };

    return MsaView;

  })(ViewTemplate);


  /*
  
  
   File: superphy_tickers.coffee
   Desc: Multiple Superphy Ticker Classes. Tickers are single line summaries of current genome data
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: April 16th, 2013
   */


  /*
   CLASS TickerTemplate
   
   Template object for tickers. Defines required and
   common properties/methods. All ticker objects
   are descendants of the TickerTemplate.
   */

  TickerTemplate = (function() {
    function TickerTemplate(parentElem, elNum) {
      this.parentElem = parentElem;
      this.elNum = elNum != null ? elNum : 1;
      this.elID = this.elName + this.elNum;
    }

    TickerTemplate.prototype.elNum = 1;

    TickerTemplate.prototype.elName = 'ticker';

    TickerTemplate.prototype.elID = void 0;

    TickerTemplate.prototype.parentElem = void 0;

    TickerTemplate.prototype.cssClass = void 0;

    TickerTemplate.prototype.flavor = void 0;

    TickerTemplate.prototype.update = function(genomes) {
      throw new SuperphyError("TickerTemplate method update() must be defined in child class (" + this.flavor + ").");
      return false;
    };

    return TickerTemplate;

  })();


  /*
   CLASS MetaTicker
    
   Counts number of a specified meta-data item
   */

  MetaTicker = (function(_super) {
    __extends(MetaTicker, _super);

    function MetaTicker(parentElem, elNum, tickerArgs) {
      this.parentElem = parentElem;
      this.elNum = elNum;
      MetaTicker.__super__.constructor.call(this, this.parentElem, this.elNum);
      if (tickerArgs.length !== 1) {
        throw new SuperphyError('Missing argument. MetaTicker constructor requires a string indicating meta-data type.');
      }
      this.metaType = tickerArgs[0];
    }

    MetaTicker.prototype.elName = 'meta_ticker';

    MetaTicker.prototype.cssClass = 'superphy_ticker_table';

    MetaTicker.prototype.flavor = 'meta';

    MetaTicker.prototype.noDataLabel = 'Not available';

    MetaTicker.prototype.update = function(genomes) {
      var bodyElem, bodyRow, countObj, ft, headElem, headRow, k, ks, t1, t2, tickerElem, v, _i, _len;
      tickerElem = jQuery("#" + this.elID);
      if (tickerElem.length) {
        tickerElem.empty();
      } else {
        tickerElem = jQuery("<table id='" + this.elID + "' class='" + this.cssClass + "'></table>");
        jQuery(this.parentElem).append(tickerElem);
      }
      t1 = new Date();
      countObj = {};
      this._updateCounts(countObj, genomes.pubVisible, genomes.public_genomes);
      this._updateCounts(countObj, genomes.pvtVisible, genomes.private_genomes);
      headElem = jQuery('<thead><tr></tr></thead>').appendTo(tickerElem);
      bodyElem = jQuery('<tbody><tr></tr></tbody>').appendTo(tickerElem);
      headRow = jQuery('<tr></tr>').appendTo(headElem);
      bodyRow = jQuery('<tr></tr>').appendTo(bodyElem);
      ks = ((function() {
        var _results;
        _results = [];
        for (k in countObj) {
          _results.push(k);
        }
        return _results;
      })()).sort(a, b)(function() {
        if (a === this.noDataLabel) {
          return 1;
        }
        if (b === this.noDataLabel) {
          return -1;
        }
        if (a < b) {
          return -1;
        } else if (a > b) {
          return 1;
        } else {
          return 0;
        }
      });
      for (_i = 0, _len = ks.length; _i < _len; _i++) {
        k = ks[_i];
        v = countObj[k];
        headRow.append("<th>" + k + "</th>");
        bodyRow.append("<td>" + v + "</td>");
      }
      t2 = new Date();
      ft = t2 - t1;
      console.log('MetaTicker update elapsed time: ' + ft);
      return true;
    };

    MetaTicker.prototype._updateCounts = function(counts, visibleG, genomes) {
      var g, meta, _i, _len;
      meta = this.metaType;
      console.log('META' + meta);
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        if (genomes[g][meta] != null) {
          if (counts[genomes[g][meta]] != null) {
            counts[genomes[g][meta]]++;
          } else {
            counts[genomes[g][meta]] = 1;
          }
        } else {
          if (counts[this.noDataLabel] != null) {
            counts[this.noDataLabel]++;
          } else {
            counts[this.noDataLabel] = 1;
          }
        }
      }
      return true;
    };

    return MetaTicker;

  })(TickerTemplate);


  /*
   CLASS LocusTicker
    
   Counts number of a specified meta-data item
   */

  LocusTicker = (function(_super) {
    __extends(LocusTicker, _super);

    function LocusTicker(parentElem, elNum, tickerArgs) {
      this.parentElem = parentElem;
      this.elNum = elNum;
      LocusTicker.__super__.constructor.call(this, this.parentElem, this.elNum, this.elNum);
      if (tickerArgs.length !== 1) {
        throw new SuperphyError('Missing argument. LocusTicker constructor requires a LocusController object.');
      }
      this.locusData = tickerArgs[0];
    }

    LocusTicker.prototype.elName = 'locus_ticker';

    LocusTicker.prototype.cssClass = 'superphy_ticker_table';

    LocusTicker.prototype.flavor = 'locus';

    LocusTicker.prototype.noDataLabel = 'NA';

    LocusTicker.prototype.update = function(genomes) {
      var bodyElem, bodyRow, countObj, ft, headElem, headRow, k, ks, t1, t2, tickerElem, v, _i, _len;
      tickerElem = jQuery("#" + this.elID);
      if (tickerElem.length) {
        tickerElem.empty();
      } else {
        tickerElem = jQuery("<table id='" + this.elID + "' class='" + this.cssClass + "'></table>");
        jQuery(this.parentElem).append(tickerElem);
      }
      t1 = new Date();
      countObj = this.locusData.count(genomes);
      headElem = jQuery('<thead></thead>').appendTo(tickerElem);
      bodyElem = jQuery('<tbody></tbody>').appendTo(tickerElem);
      headRow = jQuery('<tr></tr>').appendTo(headElem);
      bodyRow = jQuery('<tr></tr>').appendTo(bodyElem);
      ks = (function() {
        var _results;
        _results = [];
        for (k in countObj) {
          _results.push(k);
        }
        return _results;
      })();
      ks.sort(function(a, b) {
        if (a === this.noDataLabel) {
          return 1;
        }
        if (b === this.noDataLabel) {
          return -1;
        }
        if (a < b) {
          return -1;
        } else if (a > b) {
          return 1;
        } else {
          return 0;
        }
      });
      for (_i = 0, _len = ks.length; _i < _len; _i++) {
        k = ks[_i];
        v = countObj[k];
        headRow.append("<th>" + k + "</th>");
        bodyRow.append("<td>" + v + "</td>");
      }
      t2 = new Date();
      ft = t2 - t1;
      console.log('LocusTicker update elapsed time: ' + ft);
      return true;
    };

    return LocusTicker;

  })(TickerTemplate);


  /*
   CLASS AlleleTicker
    
   Histogram of allele frequency for one or more genes
   */

  AlleleTicker = (function(_super) {
    __extends(AlleleTicker, _super);

    function AlleleTicker(parentElem, elNum, genomes, tickerArgs) {
      var alleles, bins, genes, margin, tmp;
      this.parentElem = parentElem;
      this.elNum = elNum;
      AlleleTicker.__super__.constructor.call(this, this.parentElem, this.elNum, this.elNum);
      if (genomes == null) {
        throw new SuperphyError('Missing argument. AlleleTicker constructor requires GenomeController object.');
      }
      if (tickerArgs.length !== 1) {
        throw new SuperphyError('Missing argument. AlleleTicker constructor requires a JSON object containing: nodes, linksobject.');
      }
      tmp = tickerArgs[0];
      genes = tmp['nodes'];
      alleles = tmp['links'];
      this._doCounts(genomes, genes, alleles);
      margin = {
        top: 40,
        right: 30,
        bottom: 40,
        left: 30
      };
      this.width = 200 - margin.left - margin.right;
      this.height = 200 - margin.top - margin.bottom;
      bins = [
        {
          'val': 0,
          'key': '0'
        }, {
          'val': 1,
          'key': '1'
        }, {
          'val': 2,
          'key': '2'
        }, {
          'val': 3,
          'key': '3'
        }, {
          'val': 4,
          'key': '4'
        }, {
          'val': 5,
          'key': '>=5'
        }
      ];
      this.x = d3.scale.ordinal().domain(bins.map(function(d) {
        return d.val;
      })).rangeRoundBands([0, this.width], .05);
      this.x2 = d3.scale.ordinal().domain(bins.map(function(d) {
        return d.key;
      })).rangeRoundBands([0, this.width], .05);
      this.xAxis = d3.svg.axis().scale(this.x2).orient("bottom");
      this.histogram = d3.layout.histogram().bins([0, 1, 2, 3, 4, 5, 6]);
      this.parentElem.append("<div id='" + this.elID + "' class='" + this.cssClass + "'></div>");
      this.canvas = d3.select("#" + this.elID).append("svg").attr("width", this.width + margin.left + margin.right).attr("height", this.height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
      this.formatCount = d3.format(",.0f");
      this.canvas.append("g").attr("class", "x axis").attr("transform", "translate(0," + this.height + ")").call(this.xAxis).append("text").attr("dy", ".75em").attr("y", 23).attr("x", this.width / 2).attr("text-anchor", "middle").text('Number of Alleles');
    }

    AlleleTicker.prototype.elName = 'allele_ticker';

    AlleleTicker.prototype.cssClass = 'allele_histogram';

    AlleleTicker.prototype.flavor = 'allele';

    AlleleTicker.prototype.noDataLabel = 'NA';

    AlleleTicker.prototype.update = function(genomes) {
      var ft, g, histData, i, maxSteps, maxY, n, newBars, steps, svgBars, t1, t2, values, yTop, _i, _j, _k, _len, _len1, _ref, _ref1;
      t1 = new Date();
      values = [];
      _ref = genomes.pubVisible.concat(genomes.pvtVisible);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        g = _ref[_i];
        _ref1 = this.geneList;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          n = _ref1[_j];
          if (!((this.counts[g] != null) && (this.counts[g][n] != null))) {
            throw new SuperphyError("Count not defined for genome " + g + " and gene " + n + ".");
          }
          values.push(this.counts[g][n]);
        }
      }
      histData = this.histogram(values);
      steps = [10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000];
      maxSteps = steps.length;
      maxY = d3.max(histData, function(d) {
        return d.y;
      });
      yTop = NaN;
      for (i = _k = 0; _k <= maxSteps; i = _k += 1) {
        if (maxY < steps[i]) {
          yTop = steps[i];
          break;
        }
      }
      this.y = d3.scale.linear().domain([0, yTop]).range([this.height, 0]);
      svgBars = this.canvas.selectAll("g.histobar").data(histData);
      svgBars.attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.x(d.x) + "," + _this.y(d.y) + ")";
        };
      })(this));
      svgBars.select("rect").attr("x", 0).attr("width", this.x.rangeBand()).attr("height", (function(_this) {
        return function(d) {
          return _this.height - _this.y(d.y);
        };
      })(this));
      svgBars.select("text").attr("dy", ".75em").attr("y", -14).attr("x", this.x.rangeBand() / 2).attr("text-anchor", "middle").text((function(_this) {
        return function(d) {
          if (d.y > 0) {
            return _this.formatCount(d.y);
          } else {
            return '';
          }
        };
      })(this));
      svgBars.exit().remove();
      newBars = svgBars.enter().append("g").attr("class", "histobar").attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.x(d.x) + "," + _this.y(d.y) + ")";
        };
      })(this));
      newBars.append("rect").attr("x", 0).attr("width", this.x.rangeBand()).attr("height", (function(_this) {
        return function(d) {
          return _this.height - _this.y(d.y);
        };
      })(this));
      newBars.append("text").attr("dy", ".75em").attr("y", -14).attr("x", this.x.rangeBand() / 2).attr("text-anchor", "middle").text((function(_this) {
        return function(d) {
          if (d.y > 0) {
            return _this.formatCount(d.y);
          } else {
            return '';
          }
        };
      })(this));
      t2 = new Date();
      ft = t2 - t1;
      console.log('AlleleTicker update elapsed time: ' + ft);
      return true;
    };

    AlleleTicker.prototype._doCounts = function(genomes, genes, alleles) {
      var g, gList, n, numAlleles, _i, _j, _len, _len1, _ref;
      gList = Object.keys(genomes.public_genomes).concat(Object.keys(genomes.private_genomes));
      this.geneList = Object.keys(genes);
      console.log(alleles);
      this.counts = {};
      for (_i = 0, _len = gList.length; _i < _len; _i++) {
        g = gList[_i];
        this.counts[g] = {};
        _ref = this.geneList;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          n = _ref[_j];
          numAlleles = 0;
          if ((alleles[g] != null) && (alleles[g][n] != null)) {
            numAlleles = alleles[g][n].length;
          }
          this.counts[g][n] = numAlleles;
        }
      }
      console.log(this.counts);
      return true;
    };

    return AlleleTicker;

  })(TickerTemplate);


  /*
  
  
   File: superphy_matrix.coffee
   Desc: Genome x Gene table showing # of alleles
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: April 24th, 2013
   */


  /*
   CLASS MatrixView
    
   Gene Allele Matrix view
   
   Always genome based
   Links to individual genes
   */

  MatrixView = (function(_super) {
    __extends(MatrixView, _super);

    function MatrixView(parentElem, style, elNum, genomes, matrixArgs) {
      var alleles, dd, ddDiv, dialog, dialog2, gList, genes, nList, num, tmp;
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      if (genomes == null) {
        throw new SuperphyError('Missing argument. MatrixView constructor requires GenomeController object.');
      }
      if (!(matrixArgs.length > 0)) {
        throw new SuperphyError('Missing argument. MatrixView constructor requires JSON object containing: nodes, links.');
      }
      tmp = matrixArgs[0];
      genes = tmp['nodes'];
      alleles = tmp['links'];
      gList = Object.keys(genomes.public_genomes).concat(Object.keys(genomes.private_genomes));
      nList = Object.keys(genes);
      this.cellWidth = 20;
      this.margin = {
        top: 150,
        right: 0,
        bottom: 0,
        left: 250
      };
      this.height = gList.length * this.cellWidth;
      this.width = nList.length * this.cellWidth;
      this.dim = {
        w: this.width + this.margin.right + this.margin.left,
        h: this.height + this.margin.top + this.margin.bottom
      };
      MatrixView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this._computeMatrix(gList, genes, alleles);
      this.geneOrders = {
        name: d3.range(this.nGenes).sort((function(_this) {
          return function(a, b) {
            return d3.ascending(_this.geneNodes[a].name, _this.geneNodes[b].name);
          };
        })(this)),
        count: d3.range(this.nGenes).sort((function(_this) {
          return function(a, b) {
            return _this.geneNodes[b].count - _this.geneNodes[a].count;
          };
        })(this))
      };
      this.geneOrders['group'] = this.geneOrders['count'];
      this.orderType = 'name';
      this.z = d3.scale.linear().domain([0, 4]).clamp(true);
      this.x = d3.scale.ordinal().rangeBands([0, this.width]);
      this.parentElem.append("<div id='" + this.elID + "'></div>");
      ddDiv = jQuery('<div class="matrixSort"><span>Order:</span> </div>').appendTo("#" + this.elID);
      dd = jQuery('<select name="matrix-sort">' + '<option value="name" selected="selected"> by Name</option>' + '<option value="count"> by Frequency</option>' + '<option value="group"> by Group</option>' + '</select>').appendTo(ddDiv);
      num = this.elNum - 1;
      dd.change(function() {
        var sortType;
        sortType = this.value;
        return viewController.viewAction(num, 'matrix_sort', sortType);
      });
      this.wrap = d3.select("#" + this.elID).append("svg").attr("width", this.dim.w).attr("height", this.dim.h);
      this.canvas = this.wrap.append("g").attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");
      this.canvas.append("rect").attr("class", "matrixBackground").attr("width", this.width).attr("height", this.height);
      this.formatCount = d3.format(",.0f");
      dialog = jQuery('#dialog-matrix-row-select');
      if (!dialog.length) {
        dialog = jQuery('<div id="dialog-matrix-row-select"></div>').appendTo('body');
        dialog.text("Jump to genome information page?").dialog({
          title: 'Genome Information',
          autoOpen: false,
          resizable: false,
          height: 160,
          modal: true,
          buttons: {
            Yes: function() {
              var id;
              id = jQuery(this).data("row-id");
              console.log("Redirect to " + id + " strain info page");
              return jQuery(this).dialog("close");
            },
            Cancel: function() {
              return jQuery(this).dialog("close");
            }
          }
        });
      }
      dialog2 = jQuery('#dialog-matrix-col-select');
      if (!dialog2.length) {
        dialog2 = jQuery('<div id="dialog-matrix-col-select"></div>').appendTo('body');
        dialog2.text("Jump to gene page?").dialog({
          title: 'Detailed Gene Information',
          autoOpen: false,
          resizable: false,
          height: 160,
          modal: true,
          buttons: {
            Yes: function() {
              var id;
              id = jQuery(this).data("col-id");
              console.log("Redirect to " + id + " gene info page");
              return jQuery(this).dialog("close");
            },
            Cancel: function() {
              return jQuery(this).dialog("close");
            }
          }
        });
      }
      true;
    }

    MatrixView.prototype.type = 'matrix';

    MatrixView.prototype.elName = 'genome_matrix';

    MatrixView.prototype.duration = 500;

    MatrixView.prototype._computeMatrix = function(gList, genes, alleles) {
      var g, gObj, i, n, nList, numAlleles, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
      nList = Object.keys(genes);
      this.nGenomes = gList.length;
      this.nGenes = nList.length;
      this.genomeNodes = [];
      this.matrix = [];
      i = 0;
      for (_i = 0, _len = gList.length; _i < _len; _i++) {
        g = gList[_i];
        gObj = {
          id: i,
          genome: g,
          count: 0
        };
        this.genomeNodes.push(gObj);
        this.matrix[i] = d3.range(this.nGenes).map(function(j) {
          return {
            x: j,
            y: i,
            z: 0,
            i: null
          };
        });
        i++;
      }
      this.geneNodes = [];
      i = 0;
      for (_j = 0, _len1 = nList.length; _j < _len1; _j++) {
        g = nList[_j];
        gObj = {
          id: i,
          gene: g,
          name: genes[g],
          count: 0
        };
        this.geneNodes.push(gObj);
        i++;
      }
      i = 0;
      _ref = this.genomeNodes;
      for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
        g = _ref[_k];
        _ref1 = this.geneNodes;
        for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
          n = _ref1[_l];
          numAlleles = 0;
          if ((alleles[g.genome] != null) && (alleles[g.genome][n.gene] != null)) {
            numAlleles = alleles[g.genome][n.gene].length;
          }
          g.count += numAlleles;
          n.count += numAlleles;
          this.matrix[g.id][n.id].z = numAlleles;
          this.matrix[g.id][n.id].i = i;
          i++;
        }
      }
      return true;
    };

    MatrixView.prototype.update = function(genomes) {
      var dt, genomesExit, newCols, newRows, svgGenes, svgGenomes, t1, t2, that;
      t1 = new Date();
      this._sync(genomes);
      this.height = this.cellWidth * this.currN;
      this.y = d3.scale.ordinal().rangeBands([0, this.height]);
      this.y.domain(this.genomeOrders[this.orderType]);
      this.x.domain(this.geneOrders[this.orderType]);
      this.canvas.selectAll(".matrixBackground").attr("height", this.height);
      svgGenomes = this.canvas.selectAll("g.matrixrow").data(this.currNodes, function(d) {
        return d.id;
      });
      svgGenomes.attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this)).select("text.matrixlabel").text(function(d) {
        return d.viewname;
      });
      that = this;
      newRows = svgGenomes.enter().append("g").attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this)).attr("transform", function(d, i) {
        return "translate(0,0)";
      }).each(function(d) {
        return that._row(this, that.matrix[d.id], that.x, that.y, that.z);
      });
      newRows.append("line").attr("x2", this.width);
      newRows.append("text").attr("class", "matrixlabel").attr("x", -6).attr("y", this.y.rangeBand() / 2).attr("dy", ".32em").attr("text-anchor", "end").text(function(d) {
        return d.viewname;
      }).on("click", function(d) {
        return jQuery('#dialog-matrix-row-select').data('row-id', d.genome).dialog('open');
      });
      svgGenes = this.canvas.selectAll("g.matrixcolumn").data(this.geneNodes, function(d) {
        return d.id;
      });
      svgGenes.selectAll("line").attr("x1", -this.height);
      newCols = svgGenes.enter().append("g").attr("class", "matrixcolumn").attr("transform", function(d, i) {
        return "translate(" + 0 + ")rotate(-90)";
      });
      newCols.append("line").attr("x1", -this.height);
      newCols.append("text").attr("class", "matrixlabel").attr("x", 6).attr("y", this.y.rangeBand() / 2).attr("dy", ".32em").attr("text-anchor", "start").text(function(d) {
        return d.name;
      }).on("click", function(d) {
        return jQuery('#dialog-matrix-col-select').data('col-id', d.gene).dialog('open');
      });
      this._assumePositions();
      genomesExit = svgGenomes.exit().transition().duration(this.duration).attr("transform", function(d) {
        return "translate(0,0)";
      }).remove();
      t2 = new Date();
      dt = new Date(t2 - t1);
      console.log('MatrixView update elapsed time (s): ' + dt.getMilliseconds());
      return true;
    };

    MatrixView.prototype._sync = function(genomes) {
      var g, n, _i, _len, _ref;
      this.currNodes = [];
      this.currN = 0;
      _ref = this.genomeNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        g = genomes.genome(n.genome);
        if (g.visible) {
          n.viewname = g.viewname;
          n.selected = (g.isSelected != null) && g.isSelected;
          if (g.assignedGroup != null) {
            n.assignedGroup = g.assignedGroup;
          } else {
            n.assignedGroup = 0;
          }
          n.index = this.currN;
          this.currNodes.push(n);
          this.currN++;
        }
      }
      this.genomeOrders = {
        name: d3.range(this.currN).sort((function(_this) {
          return function(a, b) {
            return d3.ascending(_this.currNodes[a].viewname, _this.currNodes[b].viewname);
          };
        })(this)),
        count: d3.range(this.currN).sort((function(_this) {
          return function(a, b) {
            return _this.currNodes[b].count - _this.currNodes[a].count;
          };
        })(this)),
        group: d3.range(this.currN).sort((function(_this) {
          return function(a, b) {
            var gdiff;
            gdiff = _this.currNodes[b].assignedGroup - _this.currNodes[a].assignedGroup;
            if (gdiff === 0) {
              return _this.currNodes[b].count - _this.currNodes[a].count;
            } else {
              return gdiff;
            }
          };
        })(this))
      };
      return true;
    };

    MatrixView.prototype._row = function(svgRow, rowData, x, y, z) {
      var newCells, num, svgCells;
      svgCells = d3.select(svgRow).selectAll(".matrixcell").data(rowData, function(d) {
        return d.i;
      });
      num = this.elNum - 1;
      newCells = svgCells.enter().append("g").attr("class", "matrixcell").attr("transform", (function(_this) {
        return function(d, i) {
          return "translate(" + _this.x(d.x) + ",0)";
        };
      })(this));
      newCells.append("rect").attr("x", 0).attr("width", x.rangeBand()).attr("height", y.rangeBand()).style("fill-opacity", function(d) {
        return z(d.z);
      }).on("mouseover", (function(_this) {
        return function(p) {
          return _this._mouseover(p);
        };
      })(this)).on("mouseout", this._mouseout);
      newCells.append("text").attr("dy", ".32em").attr("y", x.rangeBand() / 2).attr("x", x.rangeBand() / 2).attr("text-anchor", "middle").text((function(_this) {
        return function(d) {
          if (d.z > 0) {
            return _this.formatCount(d.z);
          } else {
            return '';
          }
        };
      })(this));
      return true;
    };

    MatrixView.prototype._assumePositions = function() {
      var that, transit;
      that = this;
      transit = this.canvas.transition().duration(this.duration);
      transit.selectAll(".matrixrow").delay(function(d, i) {
        return that.y(d.index) * 4;
      }).attr("transform", function(d, i) {
        return "translate(0," + that.y(d.index) + ")";
      }).selectAll(".matrixcell").delay(function(d) {
        return that.x(d.x) * 4;
      }).attr("transform", (function(_this) {
        return function(d, i) {
          return "translate(" + that.x(d.x) + ",0)";
        };
      })(this));
      transit.selectAll(".matrixcolumn").delay(function(d, i) {
        return that.x(i) * 4;
      }).attr("transform", function(d, i) {
        return "translate(" + that.x(i) + ")rotate(-90)";
      });
      return true;
    };

    MatrixView.prototype._mouseover = function(p) {
      d3.selectAll(".matrixrow text").classed("matrixActive", function(d, i) {
        return d.index === p.y;
      });
      return d3.selectAll(".matrixcolumn text").classed("matrixActive", function(d, i) {
        return i === p.x;
      });
    };

    MatrixView.prototype._mouseout = function() {
      return d3.selectAll("text").classed("matrixActive", false);
    };

    MatrixView.prototype._classList = function(d) {
      var clsList;
      clsList = ['matrixrow'];
      if (d.selected) {
        clsList.push("selectedRow");
      }
      if (d.assignedGroup != null) {
        clsList.push("groupedRow" + d.assignedGroup);
      }
      return clsList.join(' ');
    };

    MatrixView.prototype.viewAction = function(genomes, argArray) {
      var event, _ref;
      event = argArray.shift();
      if (event === 'matrix_sort') {
        this.orderType = argArray[0];
        if (_ref = this.orderType, __indexOf.call(Object.keys(this.geneOrders), _ref) < 0) {
          throw new SuperphyError("Unrecognized order type: " + this.orderType + " in MatrixView viewAction method.");
        }
        this.update(genomes);
      } else {
        throw new SuperphyError("Unrecognized event type: " + event + " in MatrixView viewAction method.");
      }
      return true;
    };

    MatrixView.prototype.dump = function(genomes) {
      var g, n, numAlleles, row, rows, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      rows = [];
      row = [];
      row.push("#");
      _ref = this.geneNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        row.push(n.name);
      }
      rows.push(row.join("\t"));
      _ref1 = this.currNodes;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        g = _ref1[_j];
        row = [];
        row.push(g.viewname);
        _ref2 = this.geneNodes;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          n = _ref2[_k];
          numAlleles = this.matrix[g.id][n.id].z;
          row.push(numAlleles);
        }
        rows.push(row.join("\t"));
      }
      return {
        ext: 'csv',
        type: 'text/plain',
        data: rows.join("\n")
      };
    };

    MatrixView.prototype.updateCSS = function(gset, genomes) {
      var g, genomeList, svgNodes, _i, _j, _len, _len1, _ref, _ref1;
      genomeList = {};
      if (gset["public"] != null) {
        _ref = gset["public"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          genomeList[g] = genomes.public_genomes[g];
        }
      }
      if (gset["private"] != null) {
        _ref1 = gset["private"];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          genomeList[g] = genomes.private_genomes[g];
        }
      }
      svgNodes = this.canvas.selectAll("g.matrixrow");
      svgNodes.filter(function(d) {
        return genomeList[d.genome] != null;
      }).attr("class", (function(_this) {
        return function(d) {
          g = genomeList[d.genome];
          d.viewname = g.viewname;
          d.selected = (g.isSelected != null) && g.isSelected;
          if (g.assignedGroup != null) {
            d.assignedGroup = g.assignedGroup;
          } else {
            d.assignedGroup = 0;
          }
          return _this._classList(d);
        };
      })(this));
      return true;
    };

    MatrixView.prototype.select = function(genome, isSelected) {
      return true;
    };

    return MatrixView;

  })(ViewTemplate);


  /*
  
   File: superphy_map.coffee
   Desc: Objects & functions for managing geospatial views in Superphy
   Author: Akiff Manji akiff.manji@gmail.com
   Date: May 6, 2014
   */

  MapView = (function(_super) {
    __extends(MapView, _super);

    function MapView(parentElem, style, elNum, mapArgs) {
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      this.mapArgs = mapArgs;
      MapView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum, this.mapArgs);
    }

    MapView.prototype.type = 'map';

    MapView.prototype.elName = 'genome_map';

    MapView.prototype.cartographer = null;

    MapView.prototype.mapView = true;

    MapView.prototype.update = function(genomes) {
      var ft, i, mapElem, pubVis, pvtVis, t1, t2, _i, _j, _len, _len1, _ref, _ref1;
      mapElem = jQuery("#" + this.elID);
      if (mapElem.length) {
        mapElem.empty();
      } else {
        mapElem = jQuery("<ul id='" + this.elID + "' />");
        jQuery(this.parentElem).find('.map-manifest').append(mapElem);
      }
      pubVis = [];
      pvtVis = [];
      if (this.cartographer == null) {
        pubVis = genomes.pubVisible;
        pvtVis = genomes.pvtVisible;
      } else if ((this.cartographer != null) && this.cartographer.visibleStrains) {
        _ref = this.cartographer.visibileStrainLocations.pubVisible;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          if (__indexOf.call(genomes.pubVisible, i) >= 0) {
            pubVis.push(i);
          }
        }
        _ref1 = this.cartographer.visibileStrainLocations.pvtVisible;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          i = _ref1[_j];
          if (__indexOf.call(genomes.pvtVisible, i) >= 0) {
            pvtVis.push(i);
          }
        }
      }
      t1 = new Date();
      this._appendGenomes(mapElem, pubVis, genomes.public_genomes, this.style, false);
      this._appendGenomes(mapElem, pvtVis, genomes.private_genomes, this.style, true);
      t2 = new Date();
      ft = t2 - t1;
      console.log('MapView update elapsed time: ' + ft);
      return true;
    };

    MapView.prototype._appendGenomes = function(el, visibleG, genomes, style, priv) {
      var actionEl, checked, cls, g, labEl, mapEl, name, thiscls, _i, _len;
      cls = this.cssClass();
      if (priv && visibleG.length) {
        el.append("<li class='genome_list_spacer'>---- USER-SUBMITTED GENOMES ----</li>");
      }
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        name = genomes[g].htmlname;
        if (style = 'redirect') {
          mapEl = jQuery("<li class='" + thiscls + "'>" + name + "</li>");
          actionEl = jQuery("<a href='#' data-genome='" + g + "'> <span class='fa fa-search'></span>info</a>");
          actionEl.click(function(e) {
            var gid;
            e.preventDefault();
            gid = this.dataset.genome;
            return viewController.select(gid, true);
          });
          mapEl.append(actionEl);
          el.append(mapEl);
        } else if (style === 'select') {
          checked = '';
          if (genomes[g].isSelected) {
            checked = 'checked';
          }
          mapEl = jQuery("<li class='" + thiscls + "'></li>");
          labEl = jQuery("<label class='checkbox'>" + name + "</label>");
          actionEl = jQuery("<input class='checkbox' type='checkbox' value='" + g + "' " + checked + "/>");
          actionEl.change(function(e) {
            e.preventDefault();
            return viewController.select(this.value, this.checked);
          });
          labEl.append(actionEl);
          mapEl.append(labEl);
          el.append(mapEl);
        } else {
          return false;
        }
        true;
      }
    };

    MapView.prototype.updateCSS = function(gset, genomes) {
      var mapEl;
      mapEl = jQuery("#" + this.elID);
      if (!((mapEl != null) && mapEl.length)) {
        throw new SuperphyError(" DOM element for map view " + this.elID + " not found. Cannot call MapView method updateCSS().");
      }
      return true;
    };

    MapView.prototype.select = function(genome, isSelected) {
      var descriptor, itemEl;
      itemEl = null;
      if (this.style === 'select') {
        descriptor = "li input[value='" + genome + "']";
        itemEl = jQuery(descriptor);
      } else {
        return false;
      }
      if (!((itemEl != null) && itemEl.length)) {
        throw new SuperphyError(" Map element for genome " + genome + " not found in MapView " + this.elID);
        return false;
      }
      itemEl.prop('checked', isSelected);
      return true;
    };

    MapView.prototype.dump = function(genomes) {};

    MapView.prototype.conscriptCartographger = function() {
      var cartographerTypes, elem, _ref;
      elem = this.parentElem;
      this.mapArgs[0] = (_ref = this.mapArgs[0]) != null ? _ref : 'base';
      cartographerTypes = {
        'base': new Cartographer(jQuery(elem)),
        'dot': new DotCartographer(jQuery(elem)),
        'satellite': new SatelliteCartographer(jQuery(this.parentElem)),
        'infoSatellite': new InfoSatelliteCartographer(jQuery(this.parentElem), null, window.selectedGenome)
      };
      this.cartographer = cartographerTypes[this.mapArgs[0]];
      console.log(this.cartographer);
      this.cartographer.cartograPhy();
      return true;
    };

    return MapView;

  })(ViewTemplate);


  /*
    CLASS Cartographer
  
    Handles map drawing and location searching
   */

  Cartographer = (function() {
    function Cartographer(cartographDiv, cartograhOpt) {
      this.cartographDiv = cartographDiv;
      this.cartograhOpt = cartograhOpt;
    }

    Cartographer.prototype.visibleStrains = false;

    Cartographer.prototype.map = null;

    Cartographer.prototype.splitLayout = '<div class="col-md-6 map-search-div"> <table class="table map-search-table"> <tr> <td> <form class="form"> <fieldset> <div> <div class="input-group"> <input type="text" class="form-control map-search-location" placeholder="Enter a search location"> <span class="input-group-btn"> <button class="btn btn-default map-search-button" type="button"><span class="fa fa-search"></span></button> </span> </div> </div> </div> </fieldset> </form> </td> </tr> <tr> <td> <div class="map-canvas"></div> </td> </tr> </table> </div>';

    Cartographer.prototype.cartograPhy = function() {
      var cartograhOpt;
      jQuery(this.cartographDiv).prepend(this.splitLayout);
      if (this.map != null) {
        this.map = null;
      }
      cartograhOpt = {
        center: new google.maps.LatLng(-0.000, 0.000),
        zoom: 1,
        streetViewControl: false,
        mapTypeId: google.maps.MapTypeId.ROADMAP
      };
      this.map = new google.maps.Map(jQuery(this.cartographDiv).find('.map-canvas')[0], cartograhOpt);
      jQuery('.map-search-button').bind('click', {
        context: this
      }, this.pinPoint);
      return true;
    };

    Cartographer.prototype.pinPoint = function(e) {
      var geocoder, queryLocation, self;
      e.preventDefault();
      self = e.data.context;
      geocoder = new google.maps.Geocoder();
      queryLocation = jQuery('.map-search-location').val();
      geocoder.geocode({
        'address': queryLocation
      }, function(results, status) {
        if (status === google.maps.GeocoderStatus.OK) {
          self.map.setCenter(results[0].geometry.location);
          return self.map.fitBounds(results[0].geometry.viewport);
        } else {
          return alert("Location " + queryLocation + " could not be found. Please enter a proper location");
        }
      });
      return true;
    };

    return Cartographer;

  })();


  /*
    CLASS DotCartographer
  
    Handles map drawing and location searching
    Allows for pinpointing locations
   */

  DotCartographer = (function(_super) {
    __extends(DotCartographer, _super);

    function DotCartographer(dotCartographDiv, dotCartograhOpt) {
      this.dotCartographDiv = dotCartographDiv;
      this.dotCartograhOpt = dotCartograhOpt;
      DotCartographer.__super__.constructor.call(this, this.dotCartographDiv, this.dotCartograhOpt);
    }

    DotCartographer.prototype.latLng = null;

    DotCartographer.prototype.marker = null;

    DotCartographer.prototype.cartograPhy = function() {
      DotCartographer.__super__.cartograPhy.apply(this, arguments);
      google.maps.event.addListener(this.map, 'click', function(event) {
        return DotCartographer.prototype.plantFlag(event.latLng, this);
      });
      return true;
    };

    DotCartographer.prototype.pinPoint = function(e) {
      var geocoder, queryLocation, self;
      e.preventDefault();
      self = e.data.context;
      geocoder = new google.maps.Geocoder();
      queryLocation = jQuery('.map-search-location').val();
      geocoder.geocode({
        'address': queryLocation
      }, function(results, status) {
        if (status === google.maps.GeocoderStatus.OK) {
          self.latLng = results[0].geometry.location;
          self.map.setCenter(results[0].geometry.location);
          self.map.fitBounds(results[0].geometry.viewport);
          return DotCartographer.prototype.plantFlag(self.latLng, self.map);
        } else {
          return alert("Location " + queryLocation + " could not be found. Please enter a proper location");
        }
      });
      return true;
    };

    DotCartographer.prototype.plantFlag = function(location, map) {
      if (this.marker != null) {
        this.marker.setMap(null);
      }
      this.marker = new google.maps.Marker({
        position: location,
        map: map
      });
      this.marker.setTitle(this.marker.getPosition().toString());
      map.panTo(this.marker.getPosition());
      return true;
    };

    return DotCartographer;

  })(Cartographer);


  /*
    CLASS SatelliteCartographer
  
    Handles map drawing and location searching
    Displays multiple markers on map
    Handles marker clustering
    Displays list of genomes 
    Alters genome list when map viewport changes
   */

  SatelliteCartographer = (function(_super) {
    __extends(SatelliteCartographer, _super);

    function SatelliteCartographer(satelliteCartographDiv, satelliteCartograhOpt) {
      this.satelliteCartographDiv = satelliteCartographDiv;
      this.satelliteCartograhOpt = satelliteCartograhOpt;
      SatelliteCartographer.__super__.constructor.call(this, this.satelliteCartographDiv, this.satelliteCartograhOpt);
    }

    SatelliteCartographer.prototype.visibleStrains = true;

    SatelliteCartographer.prototype.clusterList = [];

    SatelliteCartographer.prototype.visibileStrainLocations = {};

    SatelliteCartographer.prototype.markerClusterer = null;

    SatelliteCartographer.prototype.mapViewIndex = null;

    SatelliteCartographer.prototype.cartograPhy = function() {
      var index;
      jQuery(this.satelliteCartographDiv).prepend('<div class="col-md-5 map-manifest"></div>');
      SatelliteCartographer.__super__.cartograPhy.apply(this, arguments);
      SatelliteCartographer.prototype.updateMarkerLists(viewController.genomeController, this.map);
      SatelliteCartographer.prototype.markerCluster(this.map);
      index = SatelliteCartographer.prototype.findMapViewIndex(viewController.views);
      SatelliteCartographer.prototype.mapViewIndex = index;
      jQuery(this.satelliteCartographDiv).data("viewsIndex", index);
      google.maps.event.addListener(this.map, 'zoom_changed', function() {
        return SatelliteCartographer.prototype.markerClusterer.clearMarkers();
      });
      google.maps.event.addListener(this.map, 'bounds_changed', function() {
        return SatelliteCartographer.prototype.markerClusterer.clearMarkers();
      });
      google.maps.event.addListener(this.map, 'resize', function() {
        return SatelliteCartographer.prototype.markerClusterer.clearMarkers();
      });
      google.maps.event.addListener(this.map, 'idle', function() {
        SatelliteCartographer.prototype.updateMarkerLists(viewController.genomeController, this);
        viewController.getView(SatelliteCartographer.prototype.mapViewIndex).update(viewController.genomeController);
        return SatelliteCartographer.prototype.markerClusterer.addMarkers(SatelliteCartographer.prototype.clusterList);
      });
      return true;
    };

    SatelliteCartographer.prototype.updateMarkerLists = function(genomes, map) {
      var circleIcon, private_genome, pubGenomeId, pubMarker, pubMarkerObj, public_genome, pvtGenomeId, pvtMarker, pvtMarkerObj, _ref, _ref1;
      this.clusterList = [];
      this.visibileStrainLocations.pubVisible = [];
      this.visibileStrainLocations.pvtVisible = [];
      _ref = genomes.public_genomes;
      for (pubGenomeId in _ref) {
        public_genome = _ref[pubGenomeId];
        if ((public_genome.isolation_location != null) && public_genome.isolation_location !== "") {
          pubMarkerObj = SatelliteCartographer.prototype.parseLocation(public_genome);
          circleIcon = {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: '#FF0000',
            fillOpacity: 0.8,
            scale: 5,
            strokeColor: '#FF0000',
            strokeWeight: 1
          };
          pubMarker = new google.maps.Marker({
            map: map,
            icon: circleIcon,
            position: pubMarkerObj['centerLatLng'],
            title: public_genome.uniquename,
            feature_id: pubGenomeId,
            uniquename: public_genome.uniquename,
            location: pubMarkerObj['locationName']
          });
          this.clusterList.push(pubMarker);
          if (map.getBounds() !== void 0 && map.getBounds().contains(pubMarker.getPosition())) {
            this.visibileStrainLocations.pubVisible.push(pubGenomeId);
          }
        }
      }
      _ref1 = genomes.private_genomes;
      for (pvtGenomeId in _ref1) {
        private_genome = _ref1[pvtGenomeId];
        if ((private_genome.isolation_location != null) && private_genome.isolation_location !== "") {
          pvtMarkerObj = SatelliteCartographer.prototype.parseLocation(private_genome);
          circleIcon = {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: '#000000',
            fillOpacity: 0.8,
            scale: 5,
            strokeColor: '#FF0000',
            strokeWeight: 1
          };
          pvtMarker = new google.maps.Marker({
            map: map,
            position: pvtMarkerObj['centerLatLng'],
            title: private_genome.uniquename,
            feature_id: pvtGenomeId,
            uniquename: private_genome.uniquename,
            location: pvtMarkerObj['locationName']
          });
          this.clusterList.push(pvtMarker);
          if (map.getBounds() !== void 0 && map.getBounds().contains(pubMarker.getPosition())) {
            this.visibileStrainLocations.pvtVisible.push(pvtGenomeId);
          }
        }
      }
      return true;
    };

    SatelliteCartographer.prototype.markerCluster = function(map) {
      var mcOptions;
      mcOptions = {
        gridSize: 50,
        maxZoom: 15
      };
      this.markerClusterer = new MarkerClusterer(map, this.clusterList, mcOptions);
      return true;
    };

    SatelliteCartographer.prototype.findMapViewIndex = function(views) {
      var index, v, _i, _len;
      for (index = _i = 0, _len = views.length; _i < _len; index = ++_i) {
        v = views[index];
        if (v.mapView != null) {
          return index;
        }
      }
      return null;
    };

    SatelliteCartographer.prototype.resetMap = function() {
      var c, x;
      SatelliteCartographer.prototype.updateMarkerLists(viewController.genomeController, this.map);
      x = this.map.getZoom();
      c = this.map.getCenter();
      google.maps.event.trigger(this.map, 'resize');
      this.map.setZoom(x);
      this.map.setCenter(c);
      return SatelliteCartographer.prototype.markerClusterer.addMarkers(SatelliteCartographer.prototype.clusterList);
    };

    SatelliteCartographer.prototype.parseLocation = function(genome) {
      var centerLatLng, locationCenter, locationCenterLat, locationCenterLng, locationCoordinates, locationName, locationViewPortNE, locationViewPortNELat, locationViewPortNELng, locationViewPortSW, locationViewPortSWLat, locationViewPortSWLng, markerBounds, markerObj, neLatLng, swLatLng;
      locationName = genome.isolation_location[0].match(/<location>[\w\d\W\D]*<\/location>/)[0];
      locationName = locationName.replace(/<location>/, '').replace(/<\/location>/, '').replace(/<[\/]+[\w\d]*>/g, '').replace(/<[\w\d]*>/g, ', ').replace(/, /, '');
      locationCoordinates = genome.isolation_location[0].match(/<coordinates>[\w\d\W\D]*<\/coordinates>/)[0];
      locationCenter = locationCoordinates.match(/<center>[\w\d\W\D]*<\/center>/)[0];
      locationCenterLat = locationCenter.match(/<lat>[\w\d\W\D]*<\/lat>/)[0];
      locationCenterLat = locationCenterLat.replace(/<lat>/, '').replace(/<\/lat>/, '');
      locationCenterLng = locationCenter.match(/<lng>[\w\d\W\D]*<\/lng>/)[0];
      locationCenterLng = locationCenterLng.replace(/<lng>/, '').replace(/<\/lng>/, '');
      locationViewPortSW = locationCoordinates.match(/<southwest>[\w\d\W\D]*<\/southwest>/)[0];
      locationViewPortSWLat = locationViewPortSW.match(/<lat>[\w\d\W\D]*<\/lat>/)[0];
      locationViewPortSWLat = locationViewPortSWLat.replace(/<lat>/, '').replace(/<\/lat>/, '');
      locationViewPortSWLng = locationViewPortSW.match(/<lng>[\w\d\W\D]*<\/lng>/)[0];
      locationViewPortSWLng = locationViewPortSWLng.replace(/<lng>/, '').replace(/<\/lng>/, '');
      locationViewPortNE = locationCoordinates.match(/<northeast>[\w\d\W\D]*<\/northeast>/)[0];
      locationViewPortNELat = locationViewPortNE.match(/<lat>[\w\d\W\D]*<\/lat>/)[0];
      locationViewPortNELat = locationViewPortNELat.replace(/<lat>/, '').replace(/<\/lat>/, '');
      locationViewPortNELng = locationViewPortNE.match(/<lng>[\w\d\W\D]*<\/lng>/)[0];
      locationViewPortNELng = locationViewPortNELng.replace(/<lng>/, '').replace(/<\/lng>/, '');
      centerLatLng = new google.maps.LatLng(locationCenterLat, locationCenterLng);
      swLatLng = new google.maps.LatLng(locationViewPortSWLat, locationViewPortSWLng);
      neLatLng = new google.maps.LatLng(locationViewPortNELat, locationViewPortNELng);
      markerBounds = new google.maps.LatLngBounds(swLatLng, neLatLng);
      markerObj = {};
      markerObj['locationName'] = locationName;
      markerObj['centerLatLng'] = centerLatLng;
      markerObj['markerBounds'] = markerBounds;
      return markerObj;
    };

    return SatelliteCartographer;

  })(Cartographer);


  /*
    CLASS InfoSatelliteCartographer
  
    Handles map drawing and location searching
    Displays multiple markers on map
    Handles marker clustering
    Displays list of genomes 
    Alters genome list when map viewport changes
    Highlights selected genome on map from search query
   */

  InfoSatelliteCartographer = (function(_super) {
    __extends(InfoSatelliteCartographer, _super);

    function InfoSatelliteCartographer(infoSatelliteCartographDiv, infoSatelliteCartograhOpt, infoSelectedGenome) {
      this.infoSatelliteCartographDiv = infoSatelliteCartographDiv;
      this.infoSatelliteCartograhOpt = infoSatelliteCartograhOpt;
      this.infoSelectedGenome = infoSelectedGenome;
      InfoSatelliteCartographer.__super__.constructor.call(this, this.infoSatelliteCartographDiv, this.infoSatelliteCartograhOpt, this.infoSelectedGenome);
    }

    InfoSatelliteCartographer.prototype.selectedGenomeLocation = null;

    InfoSatelliteCartographer.prototype.cartograPhy = function() {
      InfoSatelliteCartographer.__super__.cartograPhy.apply(this, arguments);
      this.selectedGenomeLocation = this.parseLocation(this.infoSelectedGenome);
      return this.showSelectedGenome(this.selectedGenomeLocation, this.map);
    };

    InfoSatelliteCartographer.prototype.showSelectedGenome = function(location, map) {
      var markerLatLng, maxZndex, overlay, zInd;
      if (location == null) {
        throw new SuperphyError('Location cannot be determined or location is undefined (not specified)!');
        return 0;
      }
      maxZndex = google.maps.Marker.MAX_ZINDEX;
      zInd = maxZndex + 1;
      markerLatLng = new google.maps.LatLng(location.centerLatLng);
      return overlay = new CartographerOverlay(map, location.centerLatLng, location.locationName);
    };

    return InfoSatelliteCartographer;

  })(SatelliteCartographer);

  CartographerOverlay = (function() {
    function CartographerOverlay(map, latLng, title) {
      this.map = map;
      this.latLng = latLng;
      this.title = title;
      this.setMap(this.map);
      this.div = null;
    }

    CartographerOverlay.prototype = new google.maps.OverlayView();

    CartographerOverlay.prototype.onAdd = function() {
      var div, img, panes;
      div = document.createElement('div');
      div.id = "selectedGenome";
      div.style.borderStyle = 'none';
      div.style.borderWidth = '0px';
      div.style.position = 'absolute';
      div.style.width = '22px';
      div.style.height = '40px';
      div.style.cursor = 'pointer';
      img = document.createElement('img');
      img.src = '/App/Pictures/marker_icon_green.png';
      img.style.width = '100%';
      img.style.height = '100%';
      img.style.position = 'absolute';
      img.id = "selectedGenomeMarker";
      img.title = this.title;
      div.appendChild(img);
      this.div = div;
      panes = this.getPanes();
      return panes.floatPane.appendChild(div);
    };

    CartographerOverlay.prototype.onRemove = function() {
      this.div.parentNode.removeChild(this.div);
      return this.div = null;
    };

    CartographerOverlay.prototype.draw = function() {
      var div, location, overlayProjection;
      overlayProjection = this.getProjection();
      location = overlayProjection.fromLatLngToDivPixel(this.latLng);
      div = this.div;
      div.style.left = (location.x - 11) + 'px';
      return div.style.top = (location.y - 40) + 'px';
    };

    return CartographerOverlay;

  })();

}).call(this);
