// Generated by CoffeeScript 1.7.1

/*


 File: superphy.coffee
 Desc: Objects & functions for managing views in Superphy
 Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
 Date: March 7th, 2013
 */

(function() {
  var GenomeController, GroupView, ListView, MsaView, SuperphyError, TreeView, ViewController, ViewTemplate, cmp, escapeRegExp, root, trimInput, typeIsArray,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;


  /*
   CLASS SuperphyError
   
   Error object for this library
   */

  SuperphyError = (function(_super) {
    __extends(SuperphyError, _super);

    function SuperphyError(message, name) {
      this.message = message != null ? message : '';
      this.name = name != null ? name : 'Superphy Error';
    }

    return SuperphyError;

  })(Error);


  /*
   CLASS ViewController
    
   Captures events. Updates data and views
   */

  ViewController = (function() {
    function ViewController() {
      if (typeof jQuery === "undefined" || jQuery === null) {
        throw new SuperphyError('jQuery must be loaded before the SuperPhy libary');
      }
      if (typeof URL === "undefined" || URL === null) {
        throw new SuperphyError('SuperPhy library requires the URL library');
      }
      if (typeof Blob === "undefined" || Blob === null) {
        throw new SuperphyError('SuperPhy library requires the Blob library');
      }
    }

    ViewController.prototype.views = [];

    ViewController.prototype.groups = [];

    ViewController.prototype.actionMode = false;

    ViewController.prototype.action = false;

    ViewController.prototype.genomeController = void 0;

    ViewController.prototype.init = function(publicGenomes, privateGenomes, actionMode, action) {
      this.actionMode = actionMode;
      this.action = action;
      if (!(this.actionMode === 'single_select' || this.actionMode === 'multi_select' || this.actionMode === 'two_groups')) {
        throw new SuperphyError('Unrecognized actionMode in ViewController init() method.');
      }
      this.genomeController = new GenomeController(publicGenomes, privateGenomes);
      this.views = [];
      return this.groups = [];
    };

    ViewController.prototype.createView = function() {
      var clickStyle, downloadElem, elem, listView, msaView, treeView, vNum, viewArgs, viewType;
      viewType = arguments[0], elem = arguments[1], viewArgs = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      clickStyle = 'select';
      vNum = this.views.length + 1;
      downloadElem = jQuery("<div class='download-view'><a class='download-view-link' href='#' data-genome-view='" + vNum + "'>Download <i class='fa fa-download'></a></div>");
      downloadElem.click(function(e) {
        var data, viewNum;
        viewNum = parseInt(this.dataset.genomeView);
        data = viewController.downloadViews(viewNum);
        this.href = data.href;
        this.download = data.file;
        return true;
      });
      elem.append(downloadElem);
      if (this.actionMode === 'single_select') {
        clickStyle = 'redirect';
      }
      if (viewType === 'list') {
        listView = new ListView(elem, clickStyle, vNum, viewArgs);
        listView.update(this.genomeController);
        this.views.push(listView);
      } else if (viewType === 'tree') {
        treeView = new TreeView(elem, clickStyle, vNum, viewArgs);
        treeView.update(this.genomeController);
        this.views.push(treeView);
      } else if (viewType === 'msa') {
        msaView = new MsaView(elem, clickStyle, vNum, viewArgs);
        msaView.update(this.genomeController);
        this.views.push(msaView);
      } else {
        throw new SuperphyError('Unrecognized viewType in ViewController createView() method.');
        return false;
      }
      return true;
    };

    ViewController.prototype.createGroup = function(boxEl, buttonEl) {
      var gNum, grpView;
      gNum = this.groups.length + 1;
      grpView = new GroupView(boxEl, 'select', gNum);
      grpView.update(this.genomeController);
      this.groups.push(grpView);
      buttonEl.click(function(e) {
        e.preventDefault();
        return viewController.addToGroup(gNum);
      });
      return true;
    };

    ViewController.prototype.select = function(g, checked) {
      var v, _i, _len, _ref;
      if (this.actionMode === 'single_select') {
        this.redirect(g);
      } else {
        this.genomeController.select(g, checked);
        _ref = this.views;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          v.select(g, checked);
        }
      }
      return true;
    };

    ViewController.prototype.redirect = function(g) {
      alert('Genome ' + g + ' redirected!');
      return true;
    };

    ViewController.prototype.addToGroup = function(grp) {
      var i, selected, v, _i, _len, _ref, _results;
      selected = this.genomeController.selected();
      console.log(selected);
      this.genomeController.assignGroup(selected, grp);
      this.genomeController.unselectAll();
      i = grp - 1;
      this.groups[i].add(selected, this.genomeController);
      _ref = this.views;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(v.update(this.genomeController));
      }
      return _results;
    };

    ViewController.prototype.removeFromGroup = function(genomeID, grp) {
      var gset, i, v, _i, _len, _ref;
      console.log('deleting ' + genomeID);
      gset = this.genomeController.genomeSet([genomeID]);
      this.genomeController.deleteGroup(gset);
      i = grp - 1;
      this.groups[i].remove(genomeID);
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.updateCSS(gset, this.genomeController);
      }
      return true;
    };

    ViewController.prototype.viewAction = function() {
      var vNum, viewArgs;
      vNum = arguments[0], viewArgs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      this.views[vNum].viewAction(this.genomeController, viewArgs);
      return true;
    };

    ViewController.prototype.getView = function(vNum) {
      return this.views[vNum];
    };

    ViewController.prototype.updateViews = function(option, checked) {
      var v, _i, _j, _len, _len1, _ref, _ref1;
      this.genomeController.updateMeta(option, checked);
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.update(this.genomeController);
      }
      _ref1 = this.groups;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        v = _ref1[_j];
        v.update(this.genomeController);
      }
      return true;
    };

    ViewController.prototype.downloadViews = function(viewNum) {
      var blob, dump, file, href, url;
      url = window.URL || window.webkitURL;
      blob = window.Blob;
      dump = this.views[viewNum - 1].dump(this.genomeController);
      file = new blob([dump.data], {
        type: dump.type
      });
      href = url.createObjectURL(file);
      file = "superphy_download." + dump.ext;
      return {
        href: href,
        file: file
      };
    };

    ViewController.prototype.metaForm = function(elem) {
      var form;
      form = '<div id="meta-display">' + '<h4><i class="fa fa-eye"></i> Meta-data</h4>' + '<p>Change meta-data displayed:</p>' + '<form class="form-inline">' + '<fieldset>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="accession"> Accession # </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="strain"> Strain </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="serotype"> Serotype </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="isolation_host"> Isolation Host </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="isolation_source"> Isolation Source </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="isolation_date"> Isolation Date </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="syndrome"> Symptoms / Diseases </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="stx1_subtype"> Stx1 Subtype </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="stx2_subtype"> Stx2 Subtype </label></div>' + '</fieldset>' + '</form>' + '</div>';
      elem.append(form);
      jQuery('input[name="meta-option"]').change(function() {
        return viewController.updateViews(this.value, this.checked);
      });
      return true;
    };

    ViewController.prototype.filterViews = function(filterForm) {
      var searchTerms, term, v, _i, _len, _ref;
      if (filterForm === 'selection') {
        this.genomeController.filterBySelection();
      } else {
        searchTerms = null;
        if (filterForm === 'fast') {
          term = jQuery("#fast-filter > input").val().toLowerCase();
          if ((term != null) && term.length) {
            searchTerms = [];
            searchTerms.push({
              searchTerm: term,
              dataField: 'displayname',
              negate: false
            });
          }
        } else {
          searchTerms = this._parseFilterForm();
        }
        this.genomeController.filter(searchTerms);
      }
      this._toggleFilterStatus();
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.update(this.genomeController);
      }
      return true;
    };

    ViewController.prototype.resetFilter = function() {
      var v, _i, _len, _ref, _results;
      this.genomeController.filter();
      this._toggleFilterStatus();
      this._clearFilterForm();
      _ref = this.views;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(v.update(this.genomeController));
      }
      return _results;
    };

    ViewController.prototype.filterForm = function(elem) {
      var advForm, advLab, advRadio, delButton, fastLab, fastRadio, fbs, filtButton, filtType, filterOff, filterOn, filterStatus, numVisible, selLab, selRadio, sf;
      elem.append('<h4><i class="fa fa-filter"></i> Filter</h4>');
      numVisible = this.genomeController.filtered;
      filterStatus = jQuery('<div id="filter-status"></div>');
      filterOn = jQuery("<div id='filter-on'><div id='filter-on-text' class='alert alert-info'>Filter active. " + numVisible + " genomes visible.</div></div>");
      filterOff = jQuery('<div id="filter-off"></div>');
      delButton = jQuery('<button id="remove-filter" type="button" class="btn btn-sm">Clear</button>');
      delButton.click(function(e) {
        e.preventDefault();
        return viewController.resetFilter();
      });
      delButton.appendTo(filterOn);
      if (numVisible > 0) {
        filterOn.show();
        filterOff.hide();
      } else {
        filterOn.hide();
        filterOff.show();
      }
      filterStatus.append(filterOn);
      filterStatus.append(filterOff);
      elem.append(filterStatus);
      elem.append('<p>Limit genomes displayed in views by:</p>');
      filtType = jQuery('<form id="select-filter-form" class="form-inline"></form>');
      fastLab = jQuery('<div class="form-group"><label class="radio">Basic</label></div>');
      fastRadio = jQuery('<input type="radio" name="filter-form-type" value="fast" checked>');
      fastRadio.change(function(e) {
        if (this.checked != null) {
          jQuery("#fast-filter").show();
          jQuery("#adv-filter").hide();
          jQuery("#selection-filter").hide();
        }
        return true;
      });
      fastLab.prepend(fastRadio);
      filtType.append(fastLab);
      advLab = jQuery('<div class="form-group"><label class="radio">Advanced</label></div>');
      advRadio = jQuery('<input type="radio" name="filter-form-type" value="advanced">');
      advRadio.change(function(e) {
        if (this.checked != null) {
          jQuery("#fast-filter").hide();
          jQuery("#adv-filter").show();
          jQuery("#selection-filter").hide();
        }
        return true;
      });
      advLab.prepend(advRadio);
      filtType.append(advLab);
      selLab = jQuery('<div class="form-group"><label class="radio">By Selection</label></div>');
      selRadio = jQuery('<input type="radio" name="filter-form-type" value="selection">');
      selRadio.change(function(e) {
        if (this.checked != null) {
          jQuery("#fast-filter").hide();
          jQuery("#adv-filter").hide();
          jQuery("#selection-filter").show();
        }
        return true;
      });
      selLab.prepend(selRadio);
      filtType.append(selLab);
      elem.append(filtType);
      sf = jQuery("<div id='fast-filter'></div>");
      this.addFastFilter(sf);
      elem.append(sf);
      advForm = jQuery("<div id='adv-filter'></div>");
      this.addAdvancedFilter(advForm);
      advForm.hide();
      elem.append(advForm);
      fbs = jQuery("<div id='selection-filter'>" + "<p>A selection in one of the views (i.e. genomes selected in a clade or map region)</p>" + "</div>");
      filtButton = jQuery('<button id="filter-selection-button" type="button" class="btn btn-sm">Filter by Selection</button>');
      filtButton.click(function(e) {
        e.preventDefault();
        return viewController.filterViews('selection');
      });
      fbs.append(filtButton);
      fbs.hide();
      elem.append(fbs);
      return true;
    };

    ViewController.prototype._toggleFilterStatus = function() {
      var filterOff, filterOn, numVisible;
      numVisible = this.genomeController.filtered;
      filterOn = jQuery('#filter-on');
      filterOff = jQuery('#filter-off');
      if (numVisible > 0) {
        filterOn.find('#filter-on-text').text("Filter active. " + numVisible + " genomes visible.");
        filterOn.show();
        filterOff.hide();
      } else {
        filterOn.hide();
        filterOff.show();
      }
      return true;
    };

    ViewController.prototype._clearFilterForm = function() {
      var advForm, sf;
      sf = jQuery("#fast-filter");
      sf.empty();
      this.addFastFilter(sf);
      advForm = jQuery("#adv-filter");
      advForm.empty();
      this.addAdvancedFilter(advForm);
      return true;
    };

    ViewController.prototype.addAdvancedFilter = function(elem) {
      var addRow, advButton, advRows;
      elem.append("<p>Boolean keyword search of specified meta-data fields</p>");
      advRows = jQuery("<div id='adv-filter-rows'></div>");
      elem.append(advRows);
      this.addFilterRow(advRows, 1);
      advButton = jQuery('<button id="adv-filter-submit" type="button" class="btn btn-sm">Filter</button>');
      elem.append(advButton);
      advButton.click(function(e) {
        e.preventDefault;
        return viewController.filterViews('advanced');
      });
      addRow = jQuery('<a href="#" class="adv-filter-addition">Add term</a>');
      addRow.click(function(e) {
        var rowI, rows;
        e.preventDefault();
        rows = jQuery('.adv-filter-row');
        rowI = rows.length + 1;
        return viewController.addFilterRow(jQuery('#adv-filter-rows'), rowI);
      });
      elem.append(addRow);
      return true;
    };

    ViewController.prototype.addFilterRow = function(elem, rowNum) {
      var delRow, dropDown, dt, k, keyw, row, v, _ref;
      row = jQuery('<div class="adv-filter-row" data-filter-row="' + rowNum + '"></div>').appendTo(elem);
      if (rowNum !== 1) {
        jQuery('<select name="adv-filter-op" data-filter-row="' + rowNum + '">' + '<option value="and" selected="selected">AND</option>' + '<option value="or">OR</option>' + '<option value="not">NOT</option>' + '</select>').appendTo(row);
      }
      dropDown = jQuery('<select name="adv-filter-field" data-filter-row="' + rowNum + '"></select>').appendTo(row);
      _ref = this.genomeController.metaMap;
      for (k in _ref) {
        v = _ref[k];
        dropDown.append('<option value="' + k + '">' + v + '</option>');
      }
      dropDown.append('<option value="displayname" selected="selected">Genome name</option>');
      dropDown.change(function() {
        var thisRow;
        thisRow = this.dataset.filterRow;
        if (this.value === 'isolation_date') {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').show();
        } else {
          jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').show();
          jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
        }
        return true;
      });
      keyw = jQuery('<div class="adv-filter-keyword" data-filter-row="' + rowNum + '"></div>)');
      jQuery('<input type="text" name="adv-filter-term" data-filter-row="' + rowNum + '" placeholder="Keyword"></input>').appendTo(keyw);
      keyw.appendTo(row);
      dt = jQuery('<div class="adv-filter-date" data-filter-row="' + rowNum + '"></div>)');
      dt.append('<select name="adv-filter-before" data-filter-row="' + rowNum + '">' + '<option value="before" selected="selected">before</option>' + '<option value="after">after</option>' + '</select>');
      dt.append('<input type="text" name="adv-filter-year" data-filter-row="' + rowNum + '" placeholder="YYYY"></input>');
      dt.append('<input type="text" name="adv-filter-mon" data-filter-row="' + rowNum + '" placeholder="MM"></input>');
      dt.append('<input type="text" name="adv-filter-day" data-filter-row="' + rowNum + '" placeholder="DD"></input>');
      dt.hide();
      dt.appendTo(row);
      if (rowNum !== 1) {
        delRow = jQuery('<a href="#" class="adv-filter-subtraction" data-filter-row="' + rowNum + '">Remove term</a>');
        delRow.appendTo(row);
        delRow.click(function(e) {
          var thisRow;
          e.preventDefault();
          thisRow = this.dataset.filterRow;
          return jQuery('.adv-filter-row[data-filter-row="' + thisRow + '"]').remove();
        });
      }
      return true;
    };

    ViewController.prototype.addFastFilter = function(elem) {
      var fastButton, tBox;
      elem.append("<p>Basic genome name filter</p>");
      tBox = jQuery('<input type="text" name="fast-filter-term" placeholder="Filter by..."></input>');
      fastButton = jQuery('<button id="fast-filter-submit" type="button" class="btn btn-sm">Filter</button>');
      fastButton.click(function(e) {
        e.preventDefault;
        return viewController.filterViews('fast');
      });
      tBox.appendTo(elem);
      fastButton.appendTo(elem);
      return true;
    };

    ViewController.prototype._parseFilterForm = function() {
      var bef, date, df, dy, isBefore, isDate, mn, negate, op, row, rowNum, rows, searchTerms, t, term, yr, _i, _len;
      rows = jQuery('.adv-filter-row');
      searchTerms = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        t = {};
        rowNum = parseInt(row.dataset.filterRow);
        df = jQuery("[name='adv-filter-field'][data-filter-row='" + rowNum + "']").val();
        t.dataField = df;
        isDate = false;
        if (df === 'isolation_date') {
          isDate = true;
        }
        if (!isDate) {
          term = jQuery("[name='adv-filter-term'][data-filter-row='" + rowNum + "']").val();
          term = trimInput(term, 'keyword');
          if (term == null) {
            return null;
          }
          t.searchTerm = term;
        } else {
          bef = jQuery("[name='adv-filter-before'][data-filter-row='" + rowNum + "']").val();
          if (!(bef === 'before' || bef === 'after')) {
            throw new SuperphyError('Invalid input in advanced filter form. Element "adv-filter-before" must contain strings "before","after".');
          }
          isBefore = true;
          if (bef === 'after') {
            isBefore = false;
          }
          yr = jQuery("[name='adv-filter-year'][data-filter-row='" + rowNum + "']").val();
          yr = trimInput(yr, 'Year');
          if (yr == null) {
            return null;
          }
          if (!/^[1-9][0-9]{3}$/.test(yr)) {
            alert('Error: invalid Year.');
            return null;
          }
          mn = jQuery("[name='adv-filter-mon'][data-filter-row='" + rowNum + "']").val();
          if (mn != null) {
            mn = jQuery.trim(mn);
          }
          if ((mn != null) && mn.length) {
            if (!/^[0-9]{1,2}$/.test(mn)) {
              alert('Error: invalid Month.');
              return null;
            }
          } else {
            mn = '01';
          }
          dy = jQuery("[name='adv-filter-day'][data-filter-row='" + rowNum + "']").val();
          if (dy != null) {
            dy = jQuery.trim(dy);
          }
          if ((dy != null) && dy.length) {
            if (!/^[0-9]{1,2}$/.test(dy)) {
              alert('Error: invalid Day.');
              return null;
            }
          } else {
            dy = '01';
          }
          date = Date.parse("" + yr + "-" + mn + "-" + dy);
          if (isNaN(date)) {
            alert('Error: invalid date.');
            return null;
          }
          t.date = date;
          t.before = isBefore;
        }
        if (rowNum !== 1) {
          op = jQuery("[name='adv-filter-op'][data-filter-row='" + rowNum + "']").val();
          negate = false;
          if (!(op === 'or' || op === 'and' || op === 'not')) {
            throw new SuperphyError('Invalid input in advanced filter form. Element "adv-filter-op" must contain strings "and","or","not".');
          }
          if (op === 'not') {
            op = 'and';
            negate = true;
          }
          t.op = op;
          t.negate = negate;
          searchTerms.push(t);
        } else {
          t.negate = false;
          searchTerms.unshift(t);
        }
      }
      return searchTerms;
    };

    return ViewController;

  })();

  if (!root.ViewController) {
    root.viewController = new ViewController;
  }


  /*
   CLASS ViewTemplate
   
   Template object for views. Defines required and
   common properties/methods. All view objects
   are descendants of the ViewTemplate.
   */

  ViewTemplate = (function() {
    function ViewTemplate(parentElem, style, elNum) {
      this.parentElem = parentElem;
      this.style = style != null ? style : 'select';
      this.elNum = elNum != null ? elNum : 1;
      this.elID = this.elName + this.elNum;
    }

    ViewTemplate.prototype.type = void 0;

    ViewTemplate.prototype.elNum = 1;

    ViewTemplate.prototype.elName = 'view';

    ViewTemplate.prototype.elID = void 0;

    ViewTemplate.prototype.parentElem = void 0;

    ViewTemplate.prototype.style = 'select';

    ViewTemplate.prototype.update = function(genomes) {
      throw new SuperphyError("ViewTemplate method update() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.updateCSS = function(gset, genomes) {
      throw new SuperphyError("ViewTemplate method updateCSS() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.select = function(genome, isSelected) {
      throw new SuperphyError("ViewTemplate method select() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.dump = function(genomes) {
      throw new SuperphyError("ViewTemplate method dump() must be defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.viewAction = function() {
      var args, genomes;
      genomes = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      throw new SuperphyError("viewAction method has not been defined in child class (" + this.type + ").");
      return false;
    };

    ViewTemplate.prototype.cssClass = function() {
      return this.elName + '_item';
    };

    return ViewTemplate;

  })();


  /*
   CLASS ListView
   
   Genome list
   
   Always genome-based
   Returns genome ID to redirect/select when genome list item is clicked
   */

  ListView = (function(_super) {
    __extends(ListView, _super);

    function ListView(parentElem, style, elNum, listArgs) {
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      if ((listArgs != null) && (listArgs[0] != null)) {
        this.genomeData = listArgs[0];
      }
      ListView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
    }

    ListView.prototype.type = 'list';

    ListView.prototype.elName = 'genome_list';

    ListView.prototype.update = function(genomes) {
      var ft, listElem, t1, t2;
      listElem = jQuery("#" + this.elID);
      if (listElem.length) {
        listElem.empty();
      } else {
        listElem = jQuery("<ul id='" + this.elID + "'/>");
        jQuery(this.parentElem).append(listElem);
      }
      t1 = new Date();
      this._appendGenomes(listElem, genomes.pubVisible, genomes.public_genomes, this.style, false);
      this._appendGenomes(listElem, genomes.pvtVisible, genomes.private_genomes, this.style, true);
      t2 = new Date();
      ft = t2 - t1;
      console.log('ListView update elapsed time: ' + ft);
      return true;
    };

    ListView.prototype._appendGenomes = function(el, visibleG, genomes, style, priv) {
      var actionEl, checked, cls, dataObj, g, labEl, listEl, name, thiscls, _i, _len;
      cls = this.cssClass();
      if (this.genomeData != null) {
        dataObj = this.genomeData;
        visibleG = visibleG.filter(function(i) {
          var found;
          found = i in dataObj;
          return found;
        });
      }
      if (priv && visibleG.length) {
        el.append("<li class='genome_list_spacer'>---- USER-SUBMITTED GENOMES ----</li>");
      }
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        name = genomes[g].viewname;
        if (this.genomeData != null) {
          name += this.genomeData[g];
        }
        if (style === 'redirect') {
          listEl = jQuery("<li class='" + thiscls + "'>" + name + "</li>");
          actionEl = jQuery("<a href='#' data-genome='" + g + "'><i class='icon-search'></i> info</a>");
          actionEl.click(function(e) {
            var gid;
            e.preventDefault();
            gid = this.dataset.genome;
            return viewController.select(gid, true);
          });
          listEl.append(actionEl);
          el.append(listEl);
        } else if (style === 'select') {
          checked = '';
          if (genomes[g].isSelected) {
            checked = 'checked';
          }
          listEl = jQuery("<li class='" + thiscls + "'></li>");
          labEl = jQuery("<label class='checkbox'>" + name + "</label>");
          actionEl = jQuery("<input class='checkbox' type='checkbox' value='" + g + "' " + checked + "/>");
          actionEl.change(function(e) {
            e.preventDefault();
            return viewController.select(this.value, this.checked);
          });
          labEl.append(actionEl);
          listEl.append(labEl);
          el.append(listEl);
        } else {
          return false;
        }
      }
      return true;
    };

    ListView.prototype.updateCSS = function(gset, genomes) {
      var listEl;
      listEl = jQuery("#" + this.elID);
      if (!((listEl != null) && listEl.length)) {
        throw new SuperphyError("DOM element for list view " + this.elID + " not found. Cannot call ListView method updateCSS().");
      }
      if (gset["public"] != null) {
        this._updateGenomeCSS(listEl, gset["public"], genomes.public_genomes);
      }
      if (gset["private"] != null) {
        this._updateGenomeCSS(listEl, gset["private"], genomes.private_genomes);
      }
      return true;
    };

    ListView.prototype._updateGenomeCSS = function(el, changedG, genomes) {
      var cls, descriptor, g, itemEl, liEl, thiscls, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = changedG.length; _i < _len; _i++) {
        g = changedG[_i];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        itemEl = null;
        if (this.style === 'redirect') {
          descriptor = "li > a[data-genome='" + g + "']";
          itemEl = el.find(descriptor);
        } else if (this.style === 'select') {
          descriptor = "li input[value='" + g + "']";
          itemEl = el.find(descriptor);
        } else {
          return false;
        }
        if (!((itemEl != null) && itemEl.length)) {
          throw new SuperphyError("List element for genome " + g + " not found in ListView " + this.elID);
          return false;
        }
        console.log("Updating class to " + thiscls);
        liEl = itemEl.parents().eq(1);
        liEl.attr('class', thiscls);
      }
      return true;
    };

    ListView.prototype.select = function(genome, isSelected) {
      var descriptor, itemEl;
      itemEl = null;
      if (this.style === 'select') {
        descriptor = "li input[value='" + genome + "']";
        itemEl = jQuery(descriptor);
      } else {
        return false;
      }
      if (!((itemEl != null) && itemEl.length)) {
        throw new SuperphyError("List element for genome " + genome + " not found in ListView " + this.elID);
        return false;
      }
      itemEl.prop('checked', isSelected);
      return true;
    };

    ListView.prototype.dump = function(genomes) {
      var fullMeta, g, header, id, k, output, _ref, _ref1;
      fullMeta = {};
      for (k in genomes.visibleMeta) {
        fullMeta[k] = true;
      }
      output = '';
      header = (function() {
        var _results;
        _results = [];
        for (k in fullMeta) {
          _results.push(genomes.metaMap[k]);
        }
        return _results;
      })();
      header.unshift("Genome name");
      output += "#" + header.join("\t") + "\n";
      _ref = genomes.public_genomes;
      for (id in _ref) {
        g = _ref[id];
        output += genomes.label(g, fullMeta, "\t") + "\n";
      }
      _ref1 = genomes.private_genomes;
      for (id in _ref1) {
        g = _ref1[id];
        output += genomes.label(g, fullMeta, "\t") + "\n";
      }
      return {
        ext: 'csv',
        type: 'text/plain',
        data: output
      };
    };

    return ListView;

  })(ViewTemplate);


  /*
   CLASS GroupView
   
   A special type of genome list that is used to temporarily store the user's
   selected genomes.
   
   Only one 'style' which provides a remove button to remove group from group.
   Will be updated by changes to the meta-display options but not by filtering.
   */

  GroupView = (function(_super) {
    __extends(GroupView, _super);

    function GroupView() {
      return GroupView.__super__.constructor.apply(this, arguments);
    }

    GroupView.prototype.type = 'group';

    GroupView.prototype.elName = 'group';

    GroupView.prototype.update = function(genomes) {
      var ingrp, listElem;
      listElem = jQuery("#" + this.elID);
      if (listElem.length) {
        listElem.empty();
      } else {
        listElem = jQuery("<ul id='" + this.elID + "'/>");
        jQuery(this.parentElem).append(listElem);
      }
      ingrp = genomes.grouped(this.elNum);
      this._appendGenomes(listElem, ingrp["public"], genomes.public_genomes);
      this._appendGenomes(listElem, ingrp["private"], genomes.private_genomes);
      return true;
    };

    GroupView.prototype.add = function(genomeSet, genomes) {
      var listElem;
      listElem = jQuery("#" + this.elID);
      if (!listElem.length) {
        listElem = jQuery("<ul id='" + this.elID + "'/>");
        jQuery(this.parentElem).append(listElem);
      }
      if (genomeSet["public"] != null) {
        this._appendGenomes(listElem, genomeSet["public"], genomes.public_genomes);
      }
      if (genomeSet["private"] != null) {
        return this._appendGenomes(listElem, genomeSet["private"], genomes.private_genomes);
      }
    };

    GroupView.prototype._appendGenomes = function(el, visibleG, genomes) {
      var actionEl, cls, g, listEl, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
        g = visibleG[_i];
        listEl = jQuery(("<li class='" + cls + "'>") + genomes[g].viewname + '</li>');
        actionEl = jQuery("<a href='#' data-genome='" + g + "' data-genome-group='" + this.elNum + "'> remove</a>");
        actionEl.click(function(e) {
          var gid, grp;
          e.preventDefault();
          gid = this.dataset.genome;
          grp = this.dataset.genomeGroup;
          console.log('clicked remove on ' + gid);
          return viewController.removeFromGroup(gid, grp);
        });
        listEl.append(actionEl);
        el.append(listEl);
      }
      return true;
    };

    GroupView.prototype.remove = function(gid) {
      var descriptor, linkEl, listEl;
      listEl = jQuery("#" + this.elID);
      if (!((listEl != null) && listEl.length)) {
        throw new SuperphyError("DOM element for group view " + this.elID + " not found. Cannot call GroupView method remove().");
      }
      descriptor = "li > a[data-genome='" + gid + "']";
      linkEl = listEl.find(descriptor);
      if (!((linkEl != null) && linkEl.length)) {
        throw new SuperphyError("List item element for genome " + gid + " not found in GroupView " + this.elID);
        return false;
      }
      linkEl.parent('li').remove();
      return true;
    };

    return GroupView;

  })(ViewTemplate);


  /*
   CLASS GenomeController
   
   Manages private/public genome list
   */

  GenomeController = (function() {
    function GenomeController(public_genomes, private_genomes) {
      this.public_genomes = public_genomes;
      this.private_genomes = private_genomes;
      this.update();
      this.filter();
    }

    GenomeController.prototype.pubVisible = [];

    GenomeController.prototype.pvtVisible = [];

    GenomeController.prototype.visibleMeta = {
      strain: false,
      serotype: false,
      isolation_host: false,
      isolation_source: false,
      isolation_date: false,
      accession: false,
      syndrome: false,
      stx1_subtype: false,
      stx2_subtype: false
    };

    GenomeController.prototype.metaMap = {
      'strain': 'Strain',
      'serotype': 'Serotype',
      'isolation_host': 'Host',
      'isolation_source': 'Source',
      'isolation_date': 'Date of isolation',
      'accession': 'Accession ID',
      'syndrome': 'Symptom / Disease',
      'stx1_subtype': 'Stx1 Subtype',
      'stx2_subtype': 'Stx2 Subtype'
    };

    GenomeController.prototype.publicRegexp = new RegExp('^public_');

    GenomeController.prototype.privateRegexp = new RegExp('^private_');

    GenomeController.prototype.filtered = 0;

    GenomeController.prototype.update = function() {
      var g, id, _ref, _ref1;
      _ref = this.public_genomes;
      for (id in _ref) {
        g = _ref[id];
        g.viewname = this.label(g, this.visibleMeta);
      }
      _ref1 = this.private_genomes;
      for (id in _ref1) {
        g = _ref1[id];
        g.viewname = this.label(g, this.visibleMeta);
      }
      return true;
    };

    GenomeController.prototype.filter = function(searchTerms) {
      var g, i, pubGenomeIds, pvtGenomeIds, results, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      if (searchTerms == null) {
        searchTerms = null;
      }
      pubGenomeIds = [];
      pvtGenomeIds = [];
      if (searchTerms != null) {
        results = this._runFilter(searchTerms);
        pubGenomeIds = results["public"];
        pvtGenomeIds = results["private"];
        this.filtered = pubGenomeIds.length + pvtGenomeIds.length;
        _ref = this.public_genomes;
        for (i in _ref) {
          g = _ref[i];
          g.visible = false;
        }
        _ref1 = this.private_genomes;
        for (i in _ref1) {
          g = _ref1[i];
          g.visible = false;
        }
        for (_i = 0, _len = pubGenomeIds.length; _i < _len; _i++) {
          g = pubGenomeIds[_i];
          this.public_genomes[g].visible = true;
        }
        for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
          g = pvtGenomeIds[_j];
          this.private_genomes[g].visible = true;
        }
      } else {
        pubGenomeIds = Object.keys(this.public_genomes);
        pvtGenomeIds = Object.keys(this.private_genomes);
        this.filtered = 0;
        _ref2 = this.public_genomes;
        for (i in _ref2) {
          g = _ref2[i];
          g.visible = true;
        }
        _ref3 = this.private_genomes;
        for (i in _ref3) {
          g = _ref3[i];
          g.visible = true;
        }
      }
      this.pubVisible = pubGenomeIds.sort((function(_this) {
        return function(a, b) {
          return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
        };
      })(this));
      this.pvtVisible = pvtGenomeIds.sort((function(_this) {
        return function(a, b) {
          return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
        };
      })(this));
      return true;
    };

    GenomeController.prototype.filterBySelection = function() {
      var g, gset, i, pubGenomeIds, pvtGenomeIds, _i, _j, _len, _len1, _ref, _ref1;
      gset = this.selected();
      pubGenomeIds = gset["public"];
      pvtGenomeIds = gset["private"];
      this.filtered = pubGenomeIds.length + pvtGenomeIds.length;
      if (this.filtered === 0) {
        this.filter();
      } else {
        _ref = this.public_genomes;
        for (i in _ref) {
          g = _ref[i];
          g.visible = false;
        }
        _ref1 = this.private_genomes;
        for (i in _ref1) {
          g = _ref1[i];
          g.visible = false;
        }
        for (_i = 0, _len = pubGenomeIds.length; _i < _len; _i++) {
          g = pubGenomeIds[_i];
          this.public_genomes[g].visible = true;
          this.public_genomes[g].isSelected = false;
        }
        for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
          g = pvtGenomeIds[_j];
          this.private_genomes[g].visible = true;
          this.private_genomes[g].isSelected = false;
        }
        this.pubVisible = pubGenomeIds.sort((function(_this) {
          return function(a, b) {
            return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
          };
        })(this));
        this.pvtVisible = pvtGenomeIds.sort((function(_this) {
          return function(a, b) {
            return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
          };
        })(this));
      }
      return true;
    };

    GenomeController.prototype._runFilter = function(searchTerms) {
      var firstTerm, id, pubGenomeIds, pubSet, pvtGenomeIds, pvtSet, regex, t, _i, _len;
      if (!typeIsArray(searchTerms)) {
        throw new SuperphyError('Invalid argument. GenomeController method _runFilter() requires array of search term objects as input.');
      }
      pubGenomeIds = Object.keys(this.public_genomes);
      pvtGenomeIds = Object.keys(this.private_genomes);
      firstTerm = true;
      for (_i = 0, _len = searchTerms.length; _i < _len; _i++) {
        t = searchTerms[_i];
        console.log(t);
        if (firstTerm) {
          if (t.op != null) {
            throw new SuperphyError("Invalid filter input. First search term object cannot contain an operator property 'op'.");
          }
          if (t.dataField !== 'isolation_date') {
            if (t.searchTerm == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'searchTerm' property.");
            }
            if (t.dataField == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'dataField' property.");
            }
            if (t.negate == null) {
              throw new SuperphyError("Invalid filter input. Search term objects must contain a 'negate' property.");
            }
          } else {
            if (t.dataField == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'searchTerm' property.");
            }
            if (t.date == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'date' property.");
            }
            if (t.before == null) {
              throw new SuperphyError("Invalid filter input. Date objects must contain a 'before' property.");
            }
          }
          firstTerm = false;
        } else {
          if (t.op == null) {
            throw new SuperphyError("Invalid filter input. Subsequent search term objects must contain an operator property 'op'.");
          }
        }
        if ((t.op != null) && t.op === 'or') {
          pubSet = [];
          pubSet = [];
          if (t.dataField === 'isolation_date') {
            pubSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.public_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.passDate(this.public_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.private_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.passDate(this.private_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
          } else {
            regex = new RegExp(escapeRegExp(t.searchTerm), "i");
            pubSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.public_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.match(this.public_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _ref, _results;
              _ref = Object.keys(this.private_genomes);
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                id = _ref[_j];
                if (this.match(this.private_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
          }
          pubGenomeIds = this.union(pubGenomeIds, pubSet);
          pvtGenomeIds = this.union(pvtGenomeIds, pvtSet);
        } else {
          if (t.dataField === 'isolation_date') {
            pubSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pubGenomeIds.length; _j < _len1; _j++) {
                id = pubGenomeIds[_j];
                if (this.passDate(this.public_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
                id = pvtGenomeIds[_j];
                if (this.passDate(this.private_genomes[id], t.before, t.date)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pubGenomeIds = pubSet;
            pvtGenomeIds = pvtSet;
          } else {
            regex = new RegExp(escapeRegExp(t.searchTerm), "i");
            pubSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pubGenomeIds.length; _j < _len1; _j++) {
                id = pubGenomeIds[_j];
                if (this.match(this.public_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pvtSet = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
                id = pvtGenomeIds[_j];
                if (this.match(this.private_genomes[id], t.dataField, regex, t.negate)) {
                  _results.push(id);
                }
              }
              return _results;
            }).call(this);
            pubGenomeIds = pubSet;
            pvtGenomeIds = pvtSet;
          }
        }
      }
      return {
        "public": pubGenomeIds,
        "private": pvtGenomeIds
      };
    };

    GenomeController.prototype.match = function(genome, key, regex, negate) {
      var val;
      if (genome[key] == null) {
        return false;
      }
      val = genome[key];
      if (typeIsArray(genome[key])) {
        val = genome[key].toString();
      }
      if (regex.test(val)) {
        if (!negate) {
          return true;
        } else {
          return false;
        }
      } else {
        if (negate) {
          return true;
        } else {
          return false;
        }
      }
    };

    GenomeController.prototype.passDate = function(genome, before, date) {
      var d2, val;
      if (genome['isolation_date'] == null) {
        return false;
      }
      val = genome['isolation_date'][0];
      d2 = Date.parse(val);
      if (before) {
        if (d2 < date) {
          return true;
        } else {
          return false;
        }
      } else {
        if (d2 > date) {
          return true;
        } else {
          return false;
        }
      }
    };

    GenomeController.prototype.union = function(arr1, arr2) {
      var arr, i, _i, _len, _ref;
      arr = [];
      _ref = arr1.concat(arr2);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (__indexOf.call(arr, i) < 0) {
          arr.push(i);
        }
      }
      return arr;
    };

    GenomeController.prototype.label = function(genome, visibleMeta, joinStr) {
      var lab, mtypes, na, t, _i, _len, _ref, _ref1;
      if (joinStr == null) {
        joinStr = '|';
      }
      na = 'NA';
      lab = [genome.displayname];
      mtypes = ['strain', 'serotype', 'isolation_host', 'isolation_source', 'isolation_date', 'syndrome', 'stx1_subtype', 'stx2_subtype'];
      for (_i = 0, _len = mtypes.length; _i < _len; _i++) {
        t = mtypes[_i];
        if (visibleMeta[t]) {
          lab.push(((_ref = genome[t]) != null ? _ref : [na]).join(' '));
        }
      }
      if (visibleMeta.accession) {
        lab.push((_ref1 = genome.primary_dbxref) != null ? _ref1 : na);
      }
      return lab.join(joinStr);
    };

    GenomeController.prototype.updateMeta = function(option, checked) {
      console.log(option);
      if (this.visibleMeta[option] == null) {
        throw new SuperphyError('unrecognized option in GenomeController method updateMeta()');
        return false;
      }
      if (!(checked === true || checked === false)) {
        throw new SuperphyError('invalid checked argument in GenomeController method updateMeta()');
        return false;
      }
      this.visibleMeta[option] = checked;
      this.update();
      return true;
    };

    GenomeController.prototype.select = function(g, checked) {
      if (this.publicRegexp.test(g)) {
        this.public_genomes[g].isSelected = checked;
        alert('selected public: ' + g + ' value:' + checked);
      } else {
        this.private_genomes[g].isSelected = checked;
        alert('selected private: ' + g + ' value:' + checked);
      }
      return true;
    };

    GenomeController.prototype.selected = function() {
      var k, pub, pvt, v;
      pub = [];
      pvt = [];
      pub = (function() {
        var _ref, _results;
        _ref = this.public_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.isSelected != null) && v.isSelected === true) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      pvt = (function() {
        var _ref, _results;
        _ref = this.private_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.isSelected != null) && v.isSelected === true) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    GenomeController.prototype.unselectAll = function() {
      var k, v, _ref, _ref1, _results;
      _ref = this.public_genomes;
      for (k in _ref) {
        v = _ref[k];
        if (v.isSelected != null) {
          v.isSelected = false;
        }
      }
      _ref1 = this.private_genomes;
      _results = [];
      for (k in _ref1) {
        v = _ref1[k];
        if (v.isSelected != null) {
          _results.push(v.isSelected = false);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    GenomeController.prototype.assignGroup = function(gset, grpNum) {
      var cls, g, _i, _j, _len, _len1, _ref, _ref1;
      if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
        _ref = gset["public"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          this.public_genomes[g].assignedGroup = grpNum;
          cls = 'genome_group' + grpNum;
          this.public_genomes[g].cssClass = cls;
        }
      }
      if ((gset["private"] != null) && typeof gset["private"] !== 'undefined') {
        _ref1 = gset["private"];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          this.private_genomes[g].assignedGroup = grpNum;
          cls = 'genome_group' + grpNum;
          this.private_genomes[g].cssClass = cls;
        }
      }
      return true;
    };

    GenomeController.prototype.deleteGroup = function(gset) {
      var g, _i, _j, _len, _len1, _ref, _ref1;
      if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
        _ref = gset["public"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          this.public_genomes[g].assignedGroup = null;
          this.public_genomes[g].cssClass = null;
        }
      }
      if ((gset["private"] != null) && typeof gset["public"] !== 'undefined') {
        _ref1 = gset["private"];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          this.private_genomes[g].assignedGroup = null;
          this.private_genomes[g].cssClass = null;
        }
      }
      return true;
    };

    GenomeController.prototype.grouped = function(grpNum) {
      var k, pub, pvt, v;
      pub = [];
      pvt = [];
      pub = (function() {
        var _ref, _results;
        _ref = this.public_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.assignedGroup != null) && v.assignedGroup === grpNum) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      pvt = (function() {
        var _ref, _results;
        _ref = this.private_genomes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          if ((v.assignedGroup != null) && v.assignedGroup === grpNum) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    GenomeController.prototype.genomeSet = function(gids) {
      var g, pub, pvt;
      pub = [];
      pvt = [];
      pub = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = gids.length; _i < _len; _i++) {
          g = gids[_i];
          if (this.publicRegexp.test(g)) {
            _results.push(g);
          }
        }
        return _results;
      }).call(this);
      pvt = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = gids.length; _i < _len; _i++) {
          g = gids[_i];
          if (this.privateRegexp.test(g)) {
            _results.push(g);
          }
        }
        return _results;
      }).call(this);
      return {
        "public": pub,
        "private": pvt
      };
    };

    GenomeController.prototype.genome = function(gid) {
      if (this.publicRegexp.test(gid)) {
        return this.public_genomes[gid];
      } else {
        return this.private_genomes[gid];
      }
    };

    return GenomeController;

  })();

  ({

    /*
    
      HELPER FUNCTIONS
     */
    parseHeader: function(str) {
      var match;
      match = /^((?:public|private)_\d+)\|(\d+)/.exec(str);
      return match;
    }
  });

  typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  escapeRegExp = function(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  cmp = function(a, b) {
    if (a > b) {
      return 1;
    } else if (a < b) {
      return -1;
    } else {
      return 0;
    }
  };

  trimInput = function(str, field) {
    var term;
    if (str != null) {
      term = jQuery.trim(str);
      if (term.length) {
        return term;
      } else {
        alert("Error: " + field + " is empty.");
        return null;
      }
    } else {
      alert("Error: " + field + " is empty.");
      return null;
    }
  };


  /*
  
  
   File: superphy_tree.coffee
   Desc: Phylogenetic Tree View Class
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: March 20th, 2013
   */

  d3.selection.prototype.moveToFront = function() {
    return this.each(function() {
      return this.parentNode.appendChild(this);
    });
  };


  /*
   CLASS TreeView
    
   Phylogenetic tree view
   
   Can be genome- or locus-based
   Returns genome ID to redirect/select if leaf node is clicked
   */

  TreeView = (function(_super) {
    __extends(TreeView, _super);

    function TreeView(parentElem, style, elNum, treeArgs) {
      var dialog, num;
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      if (!(treeArgs.length > 0)) {
        throw new SuperphyError('Missing argument. TreeView constructor requires JSON tree object.');
      }
      this.root = this.trueRoot = treeArgs[0];
      this.dim = {
        w: 500,
        h: 800
      };
      this.margin = {
        top: 20,
        right: 180,
        bottom: 20,
        left: 20
      };
      if (treeArgs[1] != null) {
        this.locusData = treeArgs[1];
      }
      if (treeArgs[2] != null) {
        this.dim = treeArgs[2];
      }
      if (treeArgs[3] != null) {
        this.margin = treeArgs[3];
      }
      TreeView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this.width = this.dim.w - this.margin.right - this.margin.left;
      this.height = this.dim.h - this.margin.top - this.margin.bottom;
      this.xzoom = d3.scale.linear().domain([0, this.width]).range([0, this.width]);
      this.yzoom = d3.scale.linear().domain([0, this.height]).range([0, this.height]);
      this.cluster = d3.layout.cluster().size([this.width, this.height]).sort(null).value(function(d) {
        return Number(d.length);
      }).separation(function(a, b) {
        return 1;
      });
      this.parentElem.append("<div id='" + this.elID + "'></div>");
      this.wrap = d3.select("#" + this.elID).append("svg").attr("width", this.dim.w).attr("height", this.dim.h).style("-webkit-backface-visibility", "hidden");
      this.canvas = this.wrap.append("g").attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");
      num = this.elNum - 1;
      this.wrap.call(d3.behavior.zoom().x(this.xzoom).y(this.yzoom).scaleExtent([1, 8]).on("zoom", function() {
        return viewController.getView(num).zoomed();
      }));
      if (this.style === 'select') {
        dialog = jQuery('#dialog-clade-select');
        if (!dialog.length) {
          dialog = jQuery('<div id="dialog-clade-select"></div>').appendTo('body');
          dialog.text("Select/unselect genomes in clade:").dialog({
            title: 'Select clade',
            autoOpen: false,
            resizable: false,
            height: 160,
            modal: true,
            buttons: {
              Select: function() {
                var node;
                node = jQuery(this).data("clade-node");
                viewController.getView(num).selectClade(node, true);
                return jQuery(this).dialog("close");
              },
              Unselect: function() {
                var node;
                node = jQuery(this).data("clade-node");
                viewController.getView(num).selectClade(node, false);
                return jQuery(this).dialog("close");
              },
              Cancel: function() {
                return jQuery(this).dialog("close");
              }
            }
          });
        }
      }
      this._prepTree();
      true;
    }

    TreeView.prototype.type = 'tree';

    TreeView.prototype.elName = 'genome_tree';

    TreeView.prototype.nodeId = 0;

    TreeView.prototype.duration = 1000;

    TreeView.prototype.update = function(genomes, sourceNode) {
      var branch_scale_factor_x, branch_scale_factor_y, cladeIcons, cmdBox, currLeaves, dt, elID, farthest, iNodes, id, leaves, linksEnter, lowest, n, nodesEnter, nodesExit, nodesUpdate, num, oldRoot, svgLinks, svgNode, svgNodes, t1, t2, _i, _j, _len, _len1, _ref, _ref1;
      if (sourceNode == null) {
        sourceNode = null;
      }
      t1 = new Date();
      oldRoot = this.root;
      this._sync(genomes);
      if (sourceNode == null) {
        sourceNode = this.root;
      }
      this.launchPt = {
        x: sourceNode.x,
        y: sourceNode.y,
        x0: sourceNode.x0,
        y0: sourceNode.y0
      };
      this.nodes = this.cluster.nodes(this.root);
      farthest = d3.max(this.nodes, function(d) {
        return d.sum_length * 1;
      });
      lowest = d3.max(this.nodes, function(d) {
        return d.x;
      });
      branch_scale_factor_y = (this.width - 20) / farthest;
      branch_scale_factor_x = (this.height - 20) / lowest;
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        n.y = n.sum_length * branch_scale_factor_y;
        n.x = n.x * branch_scale_factor_x;
      }
      svgNodes = this.canvas.selectAll("g.treenode").data(this.nodes, function(d) {
        return d.id;
      });
      svgLinks = this.canvas.selectAll("path.treelink").data(this.cluster.links(this.nodes), function(d) {
        return d.target.id;
      });
      linksEnter = svgLinks.enter().insert("path").attr("class", "treelink").attr("d", (function(_this) {
        return function(d) {
          var p;
          p = {
            x: _this.launchPt.x0,
            y: _this.launchPt.y0
          };
          return _this._step({
            source: p,
            target: p
          });
        };
      })(this));
      svgLinks.transition().duration(this.duration).attr("d", this._step);
      svgLinks.exit().transition().duration(this.duration).attr("d", (function(_this) {
        return function(d) {
          var o;
          o = {
            x: _this.launchPt.x,
            y: _this.launchPt.y
          };
          return _this._step({
            source: o,
            target: o
          });
        };
      })(this)).remove();
      currLeaves = svgNodes.filter(function(d) {
        return d.leaf;
      }).attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this)).on("click", function(d) {
        if (d.assignedGroup == null) {
          return viewController.select(d.genome, !d.selected);
        } else {
          return null;
        }
      });
      currLeaves.select("text").text(function(d) {
        return d.viewname;
      });
      currLeaves.select("circle").style("fill", function(d) {
        if (d.selected) {
          return "lightsteelblue";
        } else {
          return "#fff";
        }
      });
      nodesEnter = svgNodes.enter().append("g").attr("class", (function(_this) {
        return function(d) {
          return _this._classList(d);
        };
      })(this)).attr("id", function(d) {
        return "treenode" + d.id;
      }).attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.launchPt.y0 + "," + _this.launchPt.x0 + ")";
        };
      })(this));
      leaves = nodesEnter.filter(function(d) {
        return d.leaf;
      });
      leaves.append("circle").attr("r", 1e-6).style("fill", function(d) {
        if (d.selected) {
          return "lightsteelblue";
        } else {
          return "#fff";
        }
      });
      if (this.style === 'select') {
        leaves.on("click", function(d) {
          if (d.assignedGroup == null) {
            return viewController.select(d.genome, !d.selected);
          } else {
            return null;
          }
        });
      } else {
        leaves.on("click", function(d) {
          return viewController.redirect(d.genome);
        });
      }
      nodesEnter.append("text").attr("class", "treelabel").attr("dx", ".6em").attr("dy", ".4em").attr("text-anchor", "start").text(function(d) {
        if (d.leaf) {
          return d.viewname;
        } else {
          return d.label;
        }
      }).style("fill-opacity", 1e-6);
      iNodes = nodesEnter.filter(function(n) {
        return !n.leaf && !n.root;
      });
      num = this.elNum - 1;
      cmdBox = iNodes.append("rect").attr("width", 1e-6).attr("height", 1e-6).attr("y", -4).attr("x", -12).style("fill", "#fff");
      cmdBox.on("click", function(d) {
        return viewController.viewAction(num, 'expand_collapse', d, this.parentNode);
      });
      if (this.style === 'select') {
        cladeIcons = iNodes.append('text').attr("class", "treeicon").attr("text-anchor", 'middle').attr("y", 4).attr("x", -20).text(function(d) {
          return "\uf058";
        });
        cladeIcons.on("click", function(d) {
          return jQuery('#dialog-clade-select').data('clade-node', d).dialog('open');
        });
      }
      nodesUpdate = svgNodes.transition().duration(this.duration).attr("transform", function(d) {
        return "translate(" + d.y + "," + d.x + ")";
      });
      nodesUpdate.select("circle").attr("r", 4);
      nodesUpdate.filter(function(d) {
        return !d.children;
      }).select("text").style("fill-opacity", 1);
      nodesUpdate.select("rect").attr("width", 8).attr("height", 8).style("fill", function(d) {
        if (d._children != null) {
          return "lightsteelblue";
        } else {
          return "#fff";
        }
      });
      nodesExit = svgNodes.exit().transition().duration(this.duration).attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.launchPt.y + "," + _this.launchPt.x + ")";
        };
      })(this)).remove();
      nodesExit.select("circle").attr("r", 1e-6);
      nodesExit.select("text").style("fill-opacity", 1e-6);
      nodesExit.select("rect").attr("width", 1e-6).attr("height", 1e-6);
      if (!oldRoot.root && this.root !== oldRoot) {
        id = oldRoot.id;
        elID = "treenode" + id;
        svgNode = this.canvas.select("#" + elID);
        svgNode.moveToFront();
      }
      _ref1 = this.nodes;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        n = _ref1[_j];
        n.x0 = n.x;
        n.y0 = n.y;
      }
      t2 = new Date();
      dt = new Date(t2 - t1);
      console.log('TreeView update elapsed time (sec): ' + dt.getSeconds());
      return true;
    };

    TreeView.prototype.updateCSS = function(gset, genomes) {
      var g, genomeList, svgNodes, updateNodes, _i, _j, _len, _len1, _ref, _ref1;
      genomeList = {};
      if (gset["public"] != null) {
        _ref = gset["public"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          g = _ref[_i];
          genomeList[g] = genomes.public_genomes[g];
        }
      }
      if (gset["private"] != null) {
        _ref1 = gset["private"];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          g = _ref1[_j];
          genomeList[g] = genomes.private_genomes[g];
        }
      }
      svgNodes = this.canvas.selectAll("g.treenode");
      updateNodes = svgNodes.filter(function(d) {
        return genomeList[d.genome] != null;
      }).attr("class", (function(_this) {
        return function(d) {
          g = genomeList[d.genome];
          d.selected = (g.isSelected != null) && g.isSelected;
          d.assignedGroup = g.assignedGroup;
          return _this._classList(d);
        };
      })(this));
      updateNodes.on("click", function(d) {
        if (d.assignedGroup == null) {
          return viewController.select(d.genome, !d.selected);
        } else {
          return null;
        }
      });
      return true;
    };

    TreeView.prototype.viewAction = function(genomes, argArray) {
      var event;
      event = argArray.shift();
      if (event === 'expand_collapse') {
        this._expandCollapse(genomes, argArray[0], argArray[1]);
      } else {
        throw new SuperphyError("Unrecognized event type: " + event + " in TreeView viewAction method.");
      }
      return true;
    };

    TreeView.prototype.selectClade = function(node, checked) {
      var c, _i, _j, _len, _len1, _ref, _ref1, _results, _results1;
      if (node.leaf) {
        return viewController.select(node.genome, checked);
      } else {
        if (node.children != null) {
          _ref = node.children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(this.selectClade(c, checked));
          }
          return _results;
        } else if (node._children != null) {
          _ref1 = node._children;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            c = _ref1[_j];
            _results1.push(this.selectClade(c, checked));
          }
          return _results1;
        }
      }
    };

    TreeView.prototype.select = function(genome, isSelected) {
      var svgNodes, updateNode;
      svgNodes = this.canvas.selectAll("g.treenode");
      updateNode = svgNodes.filter(function(d) {
        return d.genome === genome;
      }).attr("class", (function(_this) {
        return function(d) {
          d.selected = isSelected;
          return _this._classList(d);
        };
      })(this));
      updateNode.select("circle").style("fill", function(d) {
        if (d.selected) {
          return "lightsteelblue";
        } else {
          return "#fff";
        }
      });
      return true;
    };

    TreeView.prototype.dump = function(genomes) {
      var output, tokens;
      tokens = [];
      this._printNode(genomes, this.root, tokens);
      output = tokens.join('');
      return {
        ext: 'newick',
        type: 'text/plain',
        data: output
      };
    };

    TreeView.prototype._printNode = function(genomes, node, tokens) {
      var c, g, lab, _i, _len, _ref;
      if (node.leaf) {
        g = genomes.genome(node.genome);
        lab = genomes.label(g, genomes.visibleMeta);
        tokens.push("\"" + lab + "\"", ':', node.length);
      } else {
        if (node.daycare != null) {
          tokens.push('(');
          _ref = node.daycare;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            this._printNode(genomes, c, tokens);
            tokens.push(',');
          }
          tokens[tokens.length - 1] = ')';
        }
        tokens.push("\"" + node.name + "\"", ':', node.length);
      }
      return true;
    };

    TreeView.prototype._step = function(d) {
      return "M" + d.source.y + "," + d.source.x + "L" + d.source.y + "," + d.target.x + "L" + d.target.y + "," + d.target.x;
    };

    TreeView.prototype._prepTree = function() {
      var gPattern;
      this.trueRoot.root = true;
      this.trueRoot.x0 = this.height / 2;
      this.trueRoot.y0 = 0;
      gPattern = /^((?:public_|private_)\d+)\|/;
      return this._assignKeys(this.trueRoot, 0, gPattern);
    };

    TreeView.prototype._assignKeys = function(n, i, gPattern) {
      var m, res, _i, _j, _len, _len1, _ref, _ref1;
      n.id = i;
      n.storage = n.length * 1;
      i++;
      if (n.children != null) {
        n.daycare = n.children.slice();
        _ref = n.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          m = _ref[_i];
          i = this._assignKeys(m, i, gPattern);
        }
      } else if (n._children != null) {
        n.daycare = n._children.slice();
        _ref1 = n._children;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          m = _ref1[_j];
          i = this._assignKeys(m, i, gPattern);
        }
      }
      if ((n.leaf != null) && n.leaf === "true") {
        if (this.locusData != null) {
          res = gPattern.exec(n.name);
          if (res == null) {
            throw new SuperphyError("Invalid tree node key. Expecting: genome|locus. Recieved: " + n.name);
          }
          n.genome = res[1];
        } else {
          n.genome = n.name;
        }
      }
      return i;
    };

    TreeView.prototype._sync = function(genomes) {
      this.root = this._syncNode(this.trueRoot, genomes, 0);
      return true;
    };

    TreeView.prototype._syncNode = function(node, genomes, sumLengths) {
      var c, child, children, g, isExpanded, u, _i, _len, _ref;
      node.length = node.storage * 1;
      node.sum_length = sumLengths + node.length;
      if ((node.leaf != null) && node.leaf === "true") {
        g = genomes.genome(node.genome);
        if (g.visible) {
          node.viewname = g.viewname;
          if ((this.locusData != null) && (this.locusData[node.name] != null)) {
            node.viewname += this.locusData[node.name];
          }
          node.selected = (g.isSelected != null) && g.isSelected;
          node.assignedGroup = g.assignedGroup;
          node.hidden = false;
        } else {
          node.hidden = true;
        }
      } else {
        isExpanded = true;
        if (node._children != null) {
          isExpanded = false;
        }
        children = [];
        _ref = node.daycare;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          u = this._syncNode(c, genomes, node.sum_length);
          if (!u.hidden) {
            children.push(u);
          }
        }
        if (children.length === 0) {
          node.hidden = true;
        } else if (children.length === 1) {
          node.hidden = true;
          child = children[0];
          child.length += node.length;
          return child;
        } else {
          node.hidden = false;
          if (isExpanded) {
            node.children = children;
          } else {
            node._children = children;
          }
        }
      }
      return node;
    };

    TreeView.prototype._cloneNode = function(node) {
      var copy, k, v;
      copy = {};
      for (k in node) {
        v = node[k];
        if (!(k === 'children' || k === '_children')) {
          copy[k] = v;
        }
      }
      return copy;
    };

    TreeView.prototype._expandCollapse = function(genomes, d, el) {
      var c, svgNode, _i, _len, _ref;
      svgNode = d3.select(el);
      if (d.children != null) {
        d._children = d.children;
        d.children = null;
      } else {
        d.children = d._children;
        d._children = null;
        svgNode.select("text").transition().duration(this.duration).style("fill-opacity", 1e-6);
        _ref = d.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          if (c._children != null) {
            c.children = c._children;
            c._children = null;
            d3.select("#treenode" + c.id).select("text").transition().duration(this.duration).style("fill-opacity", 1e-6);
          }
        }
      }
      this.update(genomes, d);
      return true;
    };

    TreeView.prototype.zoomed = function() {
      this.canvas.selectAll("g.treenode").attr("transform", (function(_this) {
        return function(d) {
          return _this._zTransform(d, _this.xzoom, _this.yzoom);
        };
      })(this));
      this.canvas.selectAll("path.treelink").attr("d", (function(_this) {
        return function(d) {
          return _this._zTranslate(d, _this.xzoom, _this.yzoom);
        };
      })(this));
      return true;
    };

    TreeView.prototype._zTranslate = function(d, xzoom, yzoom) {
      var sourceX, sourceY, targetX, targetY;
      sourceX = xzoom(d.source.y);
      sourceY = yzoom(d.source.x);
      targetX = xzoom(d.target.y);
      targetY = yzoom(d.target.x);
      return "M" + sourceX + "," + sourceY + "L" + sourceX + "," + targetY + "L" + targetX + "," + targetY;
    };

    TreeView.prototype._zTransform = function(d, xzoom, yzoom) {
      return "translate(" + xzoom(d.y) + "," + yzoom(d.x) + ")";
    };

    TreeView.prototype._classList = function(d) {
      var clsList;
      clsList = ['treenode'];
      if (d.selected) {
        clsList.push("selectedNode");
      }
      if (d.focus) {
        clsList.push("focusNode");
      }
      if (d.assignedGroup != null) {
        clsList.push("groupedNode" + d.assignedGroup);
      }
      return clsList.join(' ');
    };

    return TreeView;

  })(ViewTemplate);


  /*
  
  
   File: superphy_msa.coffee
   Desc: Multiple Sequence Alignment View Class
   Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
   Date: April 9th, 2013
   */


  /*
   CLASS MsaView
    
   Multiple Sequence Alignment view
   
   Always locus-based
   Returns nothing to redirect/select (no click behavior defined)
   */

  MsaView = (function(_super) {
    __extends(MsaView, _super);

    function MsaView(parentElem, style, elNum, msaArgs) {
      var alignmentJSON;
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      if (!(msaArgs.length > 0)) {
        throw new SuperphyError('Missing argument. MsaView constructor requires JSON alignment object.');
      }
      alignmentJSON = msaArgs[0];
      if (msaArgs[1] != null) {
        this.locusData = msaArgs[1];
      }
      MsaView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this._formatAlignment(alignmentJSON);
    }

    MsaView.prototype.type = 'msa';

    MsaView.prototype.elName = 'genome_msa';

    MsaView.prototype.blockLen = 70;

    MsaView.prototype.nameLen = 25;

    MsaView.prototype.consLine = 'conservation_line';

    MsaView.prototype.posLine = 'position_line';

    MsaView.prototype.nuclClasses = {
      'A': 'nuclA',
      'G': 'nuclG',
      'C': 'nuclC',
      'T': 'nuclT',
      '*': 'consM',
      ' ': 'consMM',
      '-': 'nuclGAP'
    };

    MsaView.prototype.cssClass = 'msa_row_name';

    MsaView.prototype._formatAlignment = function(alignmentJSON) {
      var g, i, j, n, pos, posElem, seq, seqLen, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
      this.rowIDs = (function() {
        var _results;
        _results = [];
        for (g in alignmentJSON) {
          _results.push(g);
        }
        return _results;
      })();
      i = this.rowIDs.indexOf(this.consLine);
      if (!(i >= 0)) {
        throw new SuperphyError('Alignment Object missing "conservation_line".');
      }
      this.rowIDs.splice(i, 1);
      seqLen = alignmentJSON[this.rowIDs[0]]['seq'].length;
      this.alignment = {};
      _ref = this.rowIDs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        this.alignment[n] = {
          'alignment': [],
          'seq': alignmentJSON[n]['seq'],
          'genome': alignmentJSON[n]['genome'],
          'locus': alignmentJSON[n]['locus']
        };
      }
      this.alignment[this.consLine] = {
        'alignment': []
      };
      this.alignment[this.posLine] = {
        'alignment': []
      };
      this.numBlock = 0;
      for (j = _j = 0, _ref1 = this.blockLen; _ref1 > 0 ? _j <= seqLen : _j >= seqLen; j = _j += _ref1) {
        this.numBlock++;
        _ref2 = this.rowIDs;
        for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
          n = _ref2[_k];
          seq = alignmentJSON[n]['seq'];
          this.alignment[n]['alignment'].push(this._formatBlock(seq.substr(j, this.blockLen)));
        }
        seq = alignmentJSON[this.consLine]['seq'];
        this.alignment[this.consLine]['alignment'].push(this._formatBlock(seq.substr(j, this.blockLen)));
        pos = j + 1;
        posElem = "<td class='msaPosition'>" + pos + "</td>";
        this.alignment[this.posLine]['alignment'].push(posElem);
      }
      return true;
    };

    MsaView.prototype._formatBlock = function(seq) {
      var c, chr, cls, html, _i, _ref;
      html = '';
      seq.toUpperCase();
      for (c = _i = 0, _ref = seq.length; 0 <= _ref ? _i <= _ref : _i >= _ref; c = 0 <= _ref ? ++_i : --_i) {
        chr = seq.charAt(c);
        cls = this.nuclClasses[chr];
        html += "<td class='" + cls + "'>" + chr + "</td>";
      }
      return html;
    };

    MsaView.prototype.update = function(genomes) {
      var ft, msaElem, t1, t2;
      msaElem = jQuery("#" + this.elID);
      if (msaElem.length) {
        msaElem.empty();
        msaElem.append('<tbody></tbody>');
      } else {
        msaElem = jQuery("<table id='" + this.elID + "'><tbody></tbody></table>");
        jQuery(this.parentElem).append(msaElem);
      }
      t1 = new Date();
      this._appendRows(msaElem, genomes);
      t2 = new Date();
      ft = t2 - t1;
      console.log('MsaView update elapsed time: ' + ft);
      return true;
    };

    MsaView.prototype._appendRows = function(el, genomes) {
      var a, g, genomeElem, genomeID, i, j, name, nameCell, rowEl, thiscls, tmp, visibleRows, _i, _j, _k, _len, _len1, _ref, _ref1;
      genomeElem = {};
      visibleRows = [];
      tmp = {};
      _ref = this.rowIDs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        a = this.alignment[i];
        genomeID = a['genome'];
        g = genomes.genome(genomeID);
        if (g.visible) {
          visibleRows.push(i);
          name = g.viewname;
          tmp[i] = name;
          if ((this.locusData != null) && (this.locusData[i] != null)) {
            name += this.locusData[i];
          }
          thiscls = this.cssClass;
          if (g.cssClass != null) {
            thiscls = this.cssClass + ' ' + g.cssClass;
          }
          nameCell = "<td class='" + thiscls + "' data-genome='" + genomeID + "'>" + name + "</td>";
          genomeElem[i] = nameCell;
        }
      }
      visibleRows.sort(function(a, b) {
        var aname, bname;
        aname = tmp[a];
        bname = tmp[b];
        if (aname > bname) {
          return 1;
        } else if (aname < bname) {
          return -1;
        } else {
          return 0;
        }
      });
      for (j = _j = 0, _ref1 = this.numBlock; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        for (_k = 0, _len1 = visibleRows.length; _k < _len1; _k++) {
          i = visibleRows[_k];
          rowEl = jQuery('<tr></tr>');
          rowEl.append(genomeElem[i] + this.alignment[i]['alignment'][j]);
          el.append(rowEl);
        }
        rowEl = jQuery('<tr></tr>');
        rowEl.append('<td></td>' + this.alignment[this.consLine]['alignment'][j]);
        el.append(rowEl);
        rowEl = jQuery('<tr></tr>');
        rowEl.append(this.alignment[this.posLine]['alignment'][j]);
        el.append(rowEl);
      }
      return true;
    };

    MsaView.prototype.updateCSS = function(gset, genomes) {
      var msaEl;
      msaEl = jQuery("#" + this.elID);
      if (!((msaEl != null) && msaEl.length)) {
        throw new SuperphyError("DOM element for Msa view " + this.elID + " not found. Cannot call MsaView method updateCSS().");
      }
      if (gset["public"] != null) {
        this._updateGenomeCSS(listEl, gset["public"], genomes.public_genomes);
      }
      if (gset["private"] != null) {
        this._updateGenomeCSS(listEl, gset["private"], genomes.private_genomes);
      }
      return true;
    };

    MsaView.prototype._updateGenomeCSS = function(el, changedG, genomes) {
      var cls, descriptor, g, itemEl, liEl, thiscls, _i, _len;
      cls = this.cssClass();
      for (_i = 0, _len = changedG.length; _i < _len; _i++) {
        g = changedG[_i];
        thiscls = cls;
        if (genomes[g].cssClass != null) {
          thiscls = cls + ' ' + genomes[g].cssClass;
        }
        descriptor = "td[data-genome='" + g + "']";
        itemEl = el.find(descriptor);
        if (!((itemEl != null) && itemEl.length)) {
          throw new SuperphyError("Msa element for genome " + g + " not found in MsaView " + this.elID);
          return false;
        }
        console.log("Updating class to " + thiscls);
        liEl = itemEl.parents().eq(1);
        liEl.attr('class', thiscls);
      }
      return true;
    };

    MsaView.prototype.select = function(genome, isSelected) {
      return true;
    };

    MsaView.prototype.dump = function(genomes) {
      var a, g, genomeID, i, name, output, seq, _i, _len, _ref;
      output = '';
      _ref = this.rowIDs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        a = this.alignment[i];
        genomeID = a['genome'];
        g = genomes.genome(genomeID);
        if (g.visible) {
          name = g.viewname;
          if ((this.locusData != null) && (this.locusData[i] != null)) {
            name += this.locusData[i];
          }
          seq = a['seq'];
          output += ">" + name + "\n" + seq + "\n";
        }
      }
      return {
        ext: 'fasta',
        type: 'text/plain',
        data: output
      };
    };

    return MsaView;

  })(ViewTemplate);

}).call(this);
