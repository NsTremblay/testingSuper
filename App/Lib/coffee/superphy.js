// Generated by CoffeeScript 1.7.1

/*


 File: superphy.coffee
 Desc: Objects & functions for managing views in Superphy
 Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
 Date: March 7th, 2013
 */
var GenomeController, GroupView, ListView, LocusController, SuperphyError, ViewController, ViewTemplate, cmp, escapeRegExp, parseHeader, root, trimInput, typeIsArray,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

root = typeof exports !== "undefined" && exports !== null ? exports : this;


/*
 CLASS SuperphyError
 
 Error object for this library
 */

SuperphyError = (function(_super) {
  __extends(SuperphyError, _super);

  function SuperphyError(message, name) {
    this.message = message != null ? message : '';
    this.name = name != null ? name : 'Superphy Error';
  }

  return SuperphyError;

})(Error);


/*
 CLASS ViewController
  
 Captures events. Updates data and views
 */

ViewController = (function() {
  function ViewController() {
    if (typeof jQuery === "undefined" || jQuery === null) {
      throw new SuperphyError('jQuery must be loaded before the SuperPhy libary');
    }
    if (typeof URL === "undefined" || URL === null) {
      throw new SuperphyError('SuperPhy library requires the URL library');
    }
    if (typeof Blob === "undefined" || Blob === null) {
      throw new SuperphyError('SuperPhy library requires the Blob library');
    }
  }

  ViewController.prototype.views = [];

  ViewController.prototype.groups = [];

  ViewController.prototype.tickers = [];

  ViewController.prototype.actionMode = false;

  ViewController.prototype.action = false;

  ViewController.prototype.maxGroups = 10;

  ViewController.prototype.genomeController = void 0;

  ViewController.prototype.init = function(publicGenomes, privateGenomes, actionMode, action, subset) {
    this.actionMode = actionMode;
    this.action = action;
    if (subset == null) {
      subset = null;
    }
    if (!(this.actionMode === 'single_select' || this.actionMode === 'multi_select' || this.actionMode === 'two_groups')) {
      throw new SuperphyError('Unrecognized actionMode in ViewController init() method.');
    }
    this.genomeController = new GenomeController(publicGenomes, privateGenomes, subset);
    this.views = [];
    return this.groups = [];
  };

  ViewController.prototype.createView = function() {
    var clickStyle, downloadElem, downloadElemDiv, elem, listView, mapView, matView, msaView, treeView, vNum, viewArgs, viewType;
    viewType = arguments[0], elem = arguments[1], viewArgs = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    clickStyle = 'select';
    vNum = this.views.length + 1;
    downloadElemDiv = jQuery("<div class='download-view'></div>");
    downloadElem = jQuery("<a class='download-view-link' href='#' data-genome-view='" + vNum + "'>Download <i class='fa fa-download'></a>");
    downloadElem.click(function(e) {
      var data, viewNum;
      viewNum = parseInt(this.dataset.genomeView);
      data = viewController.downloadViews(viewNum);
      this.href = data.href;
      this.download = data.file;
      return true;
    });
    downloadElemDiv.append(downloadElem);
    elem.append(downloadElemDiv);
    if (this.actionMode === 'single_select') {
      clickStyle = 'redirect';
    }
    if (viewType === 'list') {
      listView = new ListView(elem, clickStyle, vNum, viewArgs);
      listView.update(this.genomeController);
      this.views.push(listView);
    } else if (viewType === 'tree') {
      treeView = new TreeView(elem, clickStyle, vNum, viewArgs);
      treeView.update(this.genomeController);
      this.views.push(treeView);
    } else if (viewType === 'msa') {
      msaView = new MsaView(elem, clickStyle, vNum, viewArgs);
      msaView.update(this.genomeController);
      this.views.push(msaView);
    } else if (viewType === 'matrix') {
      matView = new MatrixView(elem, clickStyle, vNum, this.genomeController, viewArgs);
      matView.update(this.genomeController);
      this.views.push(matView);
    } else if (viewType === 'map') {
      mapView = new MapView(elem, clickStyle, vNum, viewArgs);
      this.views.push(mapView);
      mapView.conscriptCartographger();
      mapView.update(this.genomeController, mapView.cartographer);
    } else {
      throw new SuperphyError('Unrecognized viewType in ViewController createView() method.');
      return false;
    }
    return true;
  };

  ViewController.prototype.createGroup = function(boxEl, buttonEl) {
    var gNum, grpView;
    gNum = this.groups.length + 1;
    if (gNum > this.maxGroups) {
      console.log('DIE');
      return false;
    }
    grpView = new GroupView(boxEl, 'select', gNum);
    grpView.update(this.genomeController);
    this.groups.push(grpView);
    buttonEl.click(function(e) {
      e.preventDefault();
      return viewController.addToGroup(gNum);
    });
    return true;
  };

  ViewController.prototype.select = function(g, checked) {
    var v, _i, _len, _ref;
    if (this.actionMode === 'single_select') {
      this.redirect(g);
    } else {
      this.genomeController.select(g, checked);
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.select(g, checked);
      }
    }
    return true;
  };

  ViewController.prototype.redirect = function(g) {
    alert('Genome ' + g + ' redirected!');
    return true;
  };

  ViewController.prototype.addToGroup = function(grp) {
    var i, selected, v, _i, _len, _ref, _results;
    selected = this.genomeController.selected();
    console.log(selected);
    this.genomeController.assignGroup(selected, grp);
    this.genomeController.unselectAll();
    i = grp - 1;
    this.groups[i].add(selected, this.genomeController);
    _ref = this.views;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      _results.push(v.update(this.genomeController));
    }
    return _results;
  };

  ViewController.prototype.createTicker = function() {
    var alTicker, elem, locTicker, metaTicker, tNum, tickerArgs, tickerType;
    tickerType = arguments[0], elem = arguments[1], tickerArgs = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    tNum = this.tickers.length + 1;
    if (tickerType === 'meta') {
      metaTicker = new MetaTicker(elem, tNum, tickerArgs);
      metaTicker.update(this.genomeController);
      this.tickers.push(metaTicker);
    } else if (tickerType === 'locus') {
      locTicker = new LocusTicker(elem, tNum, tickerArgs);
      locTicker.update(this.genomeController);
      this.tickers.push(locTicker);
    } else if (tickerType === 'allele') {
      alTicker = new AlleleTicker(elem, tNum, this.genomeController, tickerArgs);
      alTicker.update(this.genomeController);
      this.tickers.push(alTicker);
    } else {
      throw new SuperphyError('Unrecognized tickerType in ViewController createTicker() method.');
      return false;
    }
    return true;
  };

  ViewController.prototype.select = function(g, checked) {
    var v, _i, _len, _ref;
    if (this.actionMode === 'single_select') {
      this.redirect(g);
    } else {
      this.genomeController.select(g, checked);
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.select(g, checked);
      }
    }
    return true;
  };

  ViewController.prototype.redirect = function(g) {
    alert('Genome ' + g + ' redirected!');
    return true;
  };

  ViewController.prototype.removeFromGroup = function(genomeID, grp) {
    var gset, i, v, _i, _len, _ref;
    console.log('deleting ' + genomeID);
    gset = this.genomeController.genomeSet([genomeID]);
    this.genomeController.deleteGroup(gset);
    i = grp - 1;
    this.groups[i].remove(genomeID);
    _ref = this.views;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      v.updateCSS(gset, this.genomeController);
    }
    return true;
  };

  ViewController.prototype.groupForm = function(elem, addMoreOpt) {
    var addEl, blockEl, buttEl, divEl;
    blockEl = jQuery("<div id='group-form-block'></div>").appendTo(elem);
    this.addGroupFormRow(blockEl);
    if (addMoreOpt) {
      addEl = jQuery("<div class='add-genome-groups row'></div>");
      divEl = jQuery("<div class='col-md-12'></div>").appendTo(addEl);
      buttEl = jQuery("<button class='btn' type='button'>More Genome Groups...</button>").appendTo(divEl);
      buttEl.click(function(e) {
        var reachedMax;
        reachedMax = viewController.addGroupFormRow(jQuery("#group-form-block"));
        if (!reachedMax) {
          jQuery(this).text('Max groups reached').css('color', 'darkgrey');
          return e.preventDefault();
        }
      });
      elem.append(addEl);
    }
    return true;
  };

  ViewController.prototype.addGroupFormRow = function(elem) {
    var buttEl, formEl, gNum, i, listEl, ok, rowEl, _i, _len, _ref;
    if (typeof elem === 'string') {
      elem = jQuery(elem);
    }
    gNum = this.groups.length + 1;
    if (gNum > this.maxGroups) {
      return false;
    }
    rowEl = jQuery("<div class='group-form-row row'></div>").appendTo(elem);
    ok = true;
    _ref = [gNum, gNum + 1];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      formEl = jQuery("<div id='genome-group-form" + i + "' class='genome-group-form col-md-6'></div>");
      listEl = jQuery("<div id='genome-group-list" + i + "'></div>").appendTo(formEl);
      buttEl = jQuery("<button id='genome-group-add" + i + "' class='btn' type='button'>Add to Group " + i + "</button>").appendTo(formEl);
      rowEl.append(formEl);
      ok = this.createGroup(listEl, buttEl);
    }
    return ok;
  };

  ViewController.prototype.viewAction = function() {
    var vNum, viewArgs;
    vNum = arguments[0], viewArgs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.views[vNum].viewAction(this.genomeController, viewArgs);
    return true;
  };

  ViewController.prototype.getView = function(vNum) {
    return this.views[vNum];
  };

  ViewController.prototype.updateViews = function(option, checked) {
    var t, v, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    this.genomeController.updateMeta(option, checked);
    _ref = this.views;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      v.update(this.genomeController);
    }
    _ref1 = this.groups;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      v = _ref1[_j];
      v.update(this.genomeController);
    }
    _ref2 = this.tickers;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      t = _ref2[_k];
      t.update(this.genomeController);
    }
    return true;
  };

  ViewController.prototype.downloadViews = function(viewNum) {
    var blob, dump, file, href, url;
    url = window.URL || window.webkitURL;
    blob = window.Blob;
    dump = this.views[viewNum - 1].dump(this.genomeController);
    file = new blob([dump.data], {
      type: dump.type
    });
    href = url.createObjectURL(file);
    file = "superphy_download." + dump.ext;
    return {
      href: href,
      file: file
    };
  };

  ViewController.prototype.metaForm = function(elem) {
    var form;
    form = '<div id="meta-display">' + '<h4><i class="fa fa-eye"></i> Meta-data</h4>' + '<p>Change meta-data displayed:</p>' + '<form class="form-inline">' + '<fieldset>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="accession"> Accession # </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="strain"> Strain </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="serotype"> Serotype </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="isolation_host"> Isolation Host </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="isolation_source"> Isolation Source </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="isolation_date"> Isolation Date </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="syndrome"> Symptoms / Diseases </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="stx1_subtype"> Stx1 Subtype </label></div>' + '<div class="checkbox"><label><input class="meta-option" type="checkbox" name="meta-option" value="stx2_subtype"> Stx2 Subtype </label></div>' + '</fieldset>' + '</form>' + '</div>';
    elem.append(form);
    jQuery('input[name="meta-option"]').change(function() {
      return viewController.updateViews(this.value, this.checked);
    });
    return true;
  };

  ViewController.prototype.filterViews = function(filterForm) {
    var searchTerms, t, term, v, _i, _j, _len, _len1, _ref, _ref1;
    if (filterForm === 'selection') {
      this.genomeController.filterBySelection();
    } else {
      searchTerms = null;
      if (filterForm === 'fast') {
        term = jQuery("#fast-filter > input").val().toLowerCase();
        if ((term != null) && term.length) {
          searchTerms = [];
          searchTerms.push({
            searchTerm: term,
            dataField: 'viewname',
            negate: false
          });
        }
      } else {
        searchTerms = this._parseFilterForm();
      }
      this.genomeController.filter(searchTerms);
    }
    this._toggleFilterStatus();
    _ref = this.views;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      v.update(this.genomeController);
    }
    _ref1 = this.tickers;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      t = _ref1[_j];
      t.update(this.genomeController);
    }
    return true;
  };

  ViewController.prototype.resetFilter = function() {
    var t, v, _i, _j, _len, _len1, _ref, _ref1, _results;
    this.genomeController.filter();
    this._toggleFilterStatus();
    this._clearFilterForm();
    _ref = this.views;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      v.update(this.genomeController);
    }
    _ref1 = this.tickers;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      t = _ref1[_j];
      _results.push(t.update(this.genomeController));
    }
    return _results;
  };

  ViewController.prototype.filterForm = function(elem) {
    var advForm, advLab, advRadio, delButton, fastLab, fastRadio, fbs, filtButton, filtType, filterOff, filterOn, filterStatus, numVisible, selLab, selRadio, sf;
    elem.append('<h4><i class="fa fa-filter"></i> Filter</h4>');
    numVisible = this.genomeController.filtered;
    filterStatus = jQuery('<div id="filter-status"></div>');
    filterOn = jQuery("<div id='filter-on'><div id='filter-on-text' class='alert alert-info'>Filter active. " + numVisible + " genomes visible.</div></div>");
    filterOff = jQuery('<div id="filter-off"></div>');
    delButton = jQuery('<button id="remove-filter" type="button" class="btn btn-sm">Clear</button>');
    delButton.click(function(e) {
      e.preventDefault();
      return viewController.resetFilter();
    });
    delButton.appendTo(filterOn);
    if (numVisible > 0) {
      filterOn.show();
      filterOff.hide();
    } else {
      filterOn.hide();
      filterOff.show();
    }
    filterStatus.append(filterOn);
    filterStatus.append(filterOff);
    elem.append(filterStatus);
    elem.append('<p>Limit genomes displayed in views by:</p>');
    filtType = jQuery('<form id="select-filter-form" class="form-inline"></form>');
    fastLab = jQuery('<div class="form-group"><label class="radio">Basic</label></div>');
    fastRadio = jQuery('<input type="radio" name="filter-form-type" value="fast" checked>');
    fastRadio.change(function(e) {
      if (this.checked != null) {
        jQuery("#fast-filter").show();
        jQuery("#adv-filter").hide();
        jQuery("#selection-filter").hide();
      }
      return true;
    });
    fastLab.prepend(fastRadio);
    filtType.append(fastLab);
    advLab = jQuery('<div class="form-group"><label class="radio">Advanced</label></div>');
    advRadio = jQuery('<input type="radio" name="filter-form-type" value="advanced">');
    advRadio.change(function(e) {
      if (this.checked != null) {
        jQuery("#fast-filter").hide();
        jQuery("#adv-filter").show();
        jQuery("#selection-filter").hide();
      }
      return true;
    });
    advLab.prepend(advRadio);
    filtType.append(advLab);
    selLab = jQuery('<div class="form-group"><label class="radio">By Selection</label></div>');
    selRadio = jQuery('<input type="radio" name="filter-form-type" value="selection">');
    selRadio.change(function(e) {
      if (this.checked != null) {
        jQuery("#fast-filter").hide();
        jQuery("#adv-filter").hide();
        jQuery("#selection-filter").show();
      }
      return true;
    });
    selLab.prepend(selRadio);
    filtType.append(selLab);
    elem.append(filtType);
    sf = jQuery("<div id='fast-filter'></div>");
    this.addFastFilter(sf);
    elem.append(sf);
    advForm = jQuery("<div id='adv-filter'></div>");
    this.addAdvancedFilter(advForm);
    advForm.hide();
    elem.append(advForm);
    fbs = jQuery("<div id='selection-filter'>" + "<p>A selection in one of the views (i.e. genomes selected in a clade or map region)</p>" + "</div>");
    filtButton = jQuery('<button id="filter-selection-button" type="button" class="btn btn-sm">Filter by Selection</button>');
    filtButton.click(function(e) {
      e.preventDefault();
      return viewController.filterViews('selection');
    });
    fbs.append(filtButton);
    fbs.hide();
    elem.append(fbs);
    return true;
  };

  ViewController.prototype._toggleFilterStatus = function() {
    var filterOff, filterOn, numVisible;
    numVisible = this.genomeController.filtered;
    filterOn = jQuery('#filter-on');
    filterOff = jQuery('#filter-off');
    if (numVisible > 0) {
      filterOn.find('#filter-on-text').text("Filter active. " + numVisible + " genomes visible.");
      filterOn.show();
      filterOff.hide();
    } else {
      filterOn.hide();
      filterOff.show();
    }
    return true;
  };

  ViewController.prototype._clearFilterForm = function() {
    var advForm, sf;
    sf = jQuery("#fast-filter");
    sf.empty();
    this.addFastFilter(sf);
    advForm = jQuery("#adv-filter");
    advForm.empty();
    this.addAdvancedFilter(advForm);
    return true;
  };

  ViewController.prototype.addAdvancedFilter = function(elem) {
    var addRow, advButton, advRows;
    elem.append("<p>Boolean keyword search of specified meta-data fields</p>");
    advRows = jQuery("<div id='adv-filter-rows'></div>");
    elem.append(advRows);
    this.addFilterRow(advRows, 1);
    advButton = jQuery('<button id="adv-filter-submit" type="button" class="btn btn-sm">Filter</button>');
    elem.append(advButton);
    advButton.click(function(e) {
      e.preventDefault;
      return viewController.filterViews('advanced');
    });
    addRow = jQuery('<a href="#" class="adv-filter-addition">Add term</a>');
    addRow.click(function(e) {
      var rowI, rows;
      e.preventDefault();
      rows = jQuery('.adv-filter-row');
      rowI = rows.length + 1;
      return viewController.addFilterRow(jQuery('#adv-filter-rows'), rowI);
    });
    elem.append(addRow);
    return true;
  };

  ViewController.prototype.addFilterRow = function(elem, rowNum) {
    var delRow, dropDown, dt, k, keyw, row, v, _ref;
    row = jQuery('<div class="adv-filter-row" data-filter-row="' + rowNum + '"></div>').appendTo(elem);
    if (rowNum !== 1) {
      jQuery('<select name="adv-filter-op" data-filter-row="' + rowNum + '">' + '<option value="and" selected="selected">AND</option>' + '<option value="or">OR</option>' + '<option value="not">NOT</option>' + '</select>').appendTo(row);
    }
    dropDown = jQuery('<select name="adv-filter-field" data-filter-row="' + rowNum + '"></select>').appendTo(row);
    _ref = this.genomeController.metaMap;
    for (k in _ref) {
      v = _ref[k];
      dropDown.append('<option value="' + k + '">' + v + '</option>');
    }
    dropDown.append('<option value="displayname" selected="selected">Genome name</option>');
    dropDown.change(function() {
      var thisRow;
      thisRow = this.dataset.filterRow;
      if (this.value === 'isolation_date') {
        jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').hide();
        jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').show();
      } else {
        jQuery('.adv-filter-keyword[data-filter-row="' + thisRow + '"]').show();
        jQuery('.adv-filter-date[data-filter-row="' + thisRow + '"]').hide();
      }
      return true;
    });
    keyw = jQuery('<div class="adv-filter-keyword" data-filter-row="' + rowNum + '"></div>)');
    jQuery('<input type="text" name="adv-filter-term" data-filter-row="' + rowNum + '" placeholder="Keyword"></input>').appendTo(keyw);
    keyw.appendTo(row);
    dt = jQuery('<div class="adv-filter-date" data-filter-row="' + rowNum + '"></div>)');
    dt.append('<select name="adv-filter-before" data-filter-row="' + rowNum + '">' + '<option value="before" selected="selected">before</option>' + '<option value="after">after</option>' + '</select>');
    dt.append('<input type="text" name="adv-filter-year" data-filter-row="' + rowNum + '" placeholder="YYYY"></input>');
    dt.append('<input type="text" name="adv-filter-mon" data-filter-row="' + rowNum + '" placeholder="MM"></input>');
    dt.append('<input type="text" name="adv-filter-day" data-filter-row="' + rowNum + '" placeholder="DD"></input>');
    dt.hide();
    dt.appendTo(row);
    if (rowNum !== 1) {
      delRow = jQuery('<a href="#" class="adv-filter-subtraction" data-filter-row="' + rowNum + '">Remove term</a>');
      delRow.appendTo(row);
      delRow.click(function(e) {
        var thisRow;
        e.preventDefault();
        thisRow = this.dataset.filterRow;
        return jQuery('.adv-filter-row[data-filter-row="' + thisRow + '"]').remove();
      });
    }
    return true;
  };

  ViewController.prototype.addFastFilter = function(elem) {
    var fastButton, tBox;
    elem.append("<p>Basic genome name filter</p>");
    tBox = jQuery('<input type="text" name="fast-filter-term" placeholder="Filter by..."></input>');
    fastButton = jQuery('<button id="fast-filter-submit" type="button" class="btn btn-sm">Filter</button>');
    fastButton.click(function(e) {
      e.preventDefault;
      return viewController.filterViews('fast');
    });
    tBox.appendTo(elem);
    fastButton.appendTo(elem);
    return true;
  };

  ViewController.prototype._parseFilterForm = function() {
    var bef, date, df, dy, isBefore, isDate, mn, negate, op, row, rowNum, rows, searchTerms, t, term, yr, _i, _len;
    rows = jQuery('.adv-filter-row');
    searchTerms = [];
    for (_i = 0, _len = rows.length; _i < _len; _i++) {
      row = rows[_i];
      t = {};
      rowNum = parseInt(row.dataset.filterRow);
      df = jQuery("[name='adv-filter-field'][data-filter-row='" + rowNum + "']").val();
      t.dataField = df;
      isDate = false;
      if (df === 'isolation_date') {
        isDate = true;
      }
      if (!isDate) {
        term = jQuery("[name='adv-filter-term'][data-filter-row='" + rowNum + "']").val();
        term = trimInput(term, 'keyword');
        if (term == null) {
          return null;
        }
        t.searchTerm = term;
      } else {
        bef = jQuery("[name='adv-filter-before'][data-filter-row='" + rowNum + "']").val();
        if (!(bef === 'before' || bef === 'after')) {
          throw new SuperphyError('Invalid input in advanced filter form. Element "adv-filter-before" must contain strings "before","after".');
        }
        isBefore = true;
        if (bef === 'after') {
          isBefore = false;
        }
        yr = jQuery("[name='adv-filter-year'][data-filter-row='" + rowNum + "']").val();
        yr = trimInput(yr, 'Year');
        if (yr == null) {
          return null;
        }
        if (!/^[1-9][0-9]{3}$/.test(yr)) {
          alert('Error: invalid Year.');
          return null;
        }
        mn = jQuery("[name='adv-filter-mon'][data-filter-row='" + rowNum + "']").val();
        if (mn != null) {
          mn = jQuery.trim(mn);
        }
        if ((mn != null) && mn.length) {
          if (!/^[0-9]{1,2}$/.test(mn)) {
            alert('Error: invalid Month.');
            return null;
          }
        } else {
          mn = '01';
        }
        dy = jQuery("[name='adv-filter-day'][data-filter-row='" + rowNum + "']").val();
        if (dy != null) {
          dy = jQuery.trim(dy);
        }
        if ((dy != null) && dy.length) {
          if (!/^[0-9]{1,2}$/.test(dy)) {
            alert('Error: invalid Day.');
            return null;
          }
        } else {
          dy = '01';
        }
        date = Date.parse("" + yr + "-" + mn + "-" + dy);
        if (isNaN(date)) {
          alert('Error: invalid date.');
          return null;
        }
        t.date = date;
        t.before = isBefore;
      }
      if (rowNum !== 1) {
        op = jQuery("[name='adv-filter-op'][data-filter-row='" + rowNum + "']").val();
        negate = false;
        if (!(op === 'or' || op === 'and' || op === 'not')) {
          throw new SuperphyError('Invalid input in advanced filter form. Element "adv-filter-op" must contain strings "and","or","not".');
        }
        if (op === 'not') {
          op = 'and';
          negate = true;
        }
        t.op = op;
        t.negate = negate;
        searchTerms.push(t);
      } else {
        t.negate = false;
        searchTerms.unshift(t);
      }
    }
    return searchTerms;
  };

  return ViewController;

})();

if (!root.ViewController) {
  root.viewController = new ViewController;
}


/*
 CLASS ViewTemplate
 
 Template object for views. Defines required and
 common properties/methods. All view objects
 are descendants of the ViewTemplate.
 */

ViewTemplate = (function() {
  function ViewTemplate(parentElem, style, elNum) {
    this.parentElem = parentElem;
    this.style = style != null ? style : 'select';
    this.elNum = elNum != null ? elNum : 1;
    this.elID = this.elName + this.elNum;
  }

  ViewTemplate.prototype.type = void 0;

  ViewTemplate.prototype.elNum = 1;

  ViewTemplate.prototype.elName = 'view';

  ViewTemplate.prototype.elID = void 0;

  ViewTemplate.prototype.parentElem = void 0;

  ViewTemplate.prototype.style = 'select';

  ViewTemplate.prototype.update = function(genomes) {
    throw new SuperphyError("ViewTemplate method update() must be defined in child class (" + this.type + ").");
    return false;
  };

  ViewTemplate.prototype.updateCSS = function(gset, genomes) {
    throw new SuperphyError("ViewTemplate method updateCSS() must be defined in child class (" + this.type + ").");
    return false;
  };

  ViewTemplate.prototype.select = function(genome, isSelected) {
    throw new SuperphyError("ViewTemplate method select() must be defined in child class (" + this.type + ").");
    return false;
  };

  ViewTemplate.prototype.dump = function(genomes) {
    throw new SuperphyError("ViewTemplate method dump() must be defined in child class (" + this.type + ").");
    return false;
  };

  ViewTemplate.prototype.viewAction = function() {
    var args, genomes;
    genomes = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    throw new SuperphyError("viewAction method has not been defined in child class (" + this.type + ").");
    return false;
  };

  ViewTemplate.prototype.cssClass = function() {
    return this.elName + '_item';
  };

  return ViewTemplate;

})();


/*
 CLASS ListView
 
 Genome list
 
 Always genome-based
 Returns genome ID to redirect/select when genome list item is clicked
 */

ListView = (function(_super) {
  __extends(ListView, _super);

  function ListView(parentElem, style, elNum, listArgs) {
    this.parentElem = parentElem;
    this.style = style;
    this.elNum = elNum;
    if ((listArgs != null) && (listArgs[0] != null)) {
      this.locusData = listArgs[0];
    }
    ListView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
  }

  ListView.prototype.type = 'list';

  ListView.prototype.elName = 'genome_list';

  ListView.prototype.locusData = null;

  ListView.prototype.update = function(genomes) {
    var ft, listElem, t1, t2;
    listElem = jQuery("#" + this.elID);
    if (listElem.length) {
      listElem.empty();
    } else {
      listElem = jQuery("<ul id='" + this.elID + "'/>");
      jQuery(this.parentElem).append(listElem);
    }
    t1 = new Date();
    this._appendGenomes(listElem, genomes.pubVisible, genomes.public_genomes, this.style, false);
    this._appendGenomes(listElem, genomes.pvtVisible, genomes.private_genomes, this.style, true);
    t2 = new Date();
    ft = t2 - t1;
    console.log('ListView update elapsed time: ' + ft);
    return true;
  };

  ListView.prototype._appendGenomes = function(el, visibleG, genomes, style, priv) {
    var actionEl, checked, cls, g, labEl, listEl, name, thiscls, _i, _len;
    cls = this.cssClass();
    if (priv && visibleG.length) {
      el.append("<li class='genome_list_spacer'>---- USER-SUBMITTED GENOMES ----</li>");
    }
    for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
      g = visibleG[_i];
      thiscls = cls;
      if (genomes[g].cssClass != null) {
        thiscls = cls + ' ' + genomes[g].cssClass;
      }
      name = genomes[g].viewname;
      if (this.locusData != null) {
        name += this.locusData.genomeString(g);
      }
      if (style === 'redirect') {
        listEl = jQuery("<li class='" + thiscls + "'>" + name + "</li>");
        actionEl = jQuery("<a href='#' data-genome='" + g + "'><i class='icon-search'></i> info</a>");
        actionEl.click(function(e) {
          var gid;
          e.preventDefault();
          gid = this.dataset.genome;
          return viewController.select(gid, true);
        });
        listEl.append(actionEl);
        el.append(listEl);
      } else if (style === 'select') {
        checked = '';
        if (genomes[g].isSelected) {
          checked = 'checked';
        }
        listEl = jQuery("<li class='" + thiscls + "'></li>");
        labEl = jQuery("<label class='checkbox'>" + name + "</label>");
        actionEl = jQuery("<input class='checkbox' type='checkbox' value='" + g + "' " + checked + "/>");
        actionEl.change(function(e) {
          e.preventDefault();
          return viewController.select(this.value, this.checked);
        });
        labEl.append(actionEl);
        listEl.append(labEl);
        el.append(listEl);
      } else {
        return false;
      }
    }
    return true;
  };

  ListView.prototype.updateCSS = function(gset, genomes) {
    var listEl;
    listEl = jQuery("#" + this.elID);
    if (!((listEl != null) && listEl.length)) {
      throw new SuperphyError("DOM element for list view " + this.elID + " not found. Cannot call ListView method updateCSS().");
    }
    if (gset["public"] != null) {
      this._updateGenomeCSS(listEl, gset["public"], genomes.public_genomes);
    }
    if (gset["private"] != null) {
      this._updateGenomeCSS(listEl, gset["private"], genomes.private_genomes);
    }
    return true;
  };

  ListView.prototype._updateGenomeCSS = function(el, changedG, genomes) {
    var cls, descriptor, g, itemEl, liEl, thiscls, _i, _len;
    cls = this.cssClass();
    for (_i = 0, _len = changedG.length; _i < _len; _i++) {
      g = changedG[_i];
      thiscls = cls;
      if (genomes[g].cssClass != null) {
        thiscls = cls + ' ' + genomes[g].cssClass;
      }
      itemEl = null;
      if (this.style === 'redirect') {
        descriptor = "li > a[data-genome='" + g + "']";
        itemEl = el.find(descriptor);
      } else if (this.style === 'select') {
        descriptor = "li input[value='" + g + "']";
        itemEl = el.find(descriptor);
      } else {
        return false;
      }
      if (!((itemEl != null) && itemEl.length)) {
        throw new SuperphyError("List element for genome " + g + " not found in ListView " + this.elID);
        return false;
      }
      liEl = itemEl.parents().eq(1);
      liEl.attr('class', thiscls);
    }
    return true;
  };

  ListView.prototype.select = function(genome, isSelected) {
    var descriptor, itemEl;
    itemEl = null;
    if (this.style === 'select') {
      descriptor = "li input[value='" + genome + "']";
      itemEl = jQuery(descriptor);
    } else {
      return false;
    }
    if (!((itemEl != null) && itemEl.length)) {
      throw new SuperphyError("List element for genome " + genome + " not found in ListView " + this.elID);
      return false;
    }
    itemEl.prop('checked', isSelected);
    return true;
  };

  ListView.prototype.dump = function(genomes) {
    var fullMeta, g, header, id, k, output, _ref, _ref1;
    fullMeta = {};
    for (k in genomes.visibleMeta) {
      fullMeta[k] = true;
    }
    output = '';
    header = (function() {
      var _results;
      _results = [];
      for (k in fullMeta) {
        _results.push(genomes.metaMap[k]);
      }
      return _results;
    })();
    header.unshift("Genome name");
    output += "#" + header.join("\t") + "\n";
    _ref = genomes.public_genomes;
    for (id in _ref) {
      g = _ref[id];
      output += genomes.label(g, fullMeta, "\t") + "\n";
    }
    _ref1 = genomes.private_genomes;
    for (id in _ref1) {
      g = _ref1[id];
      output += genomes.label(g, fullMeta, "\t") + "\n";
    }
    return {
      ext: 'csv',
      type: 'text/plain',
      data: output
    };
  };

  return ListView;

})(ViewTemplate);


/*
 CLASS GroupView
 
 A special type of genome list that is used to temporarily store the user's
 selected genomes.
 
 Only one 'style' which provides a remove button to remove group from group.
 Will be updated by changes to the meta-display options but not by filtering.
 */

GroupView = (function(_super) {
  __extends(GroupView, _super);

  function GroupView() {
    return GroupView.__super__.constructor.apply(this, arguments);
  }

  GroupView.prototype.type = 'group';

  GroupView.prototype.elName = 'group';

  GroupView.prototype.update = function(genomes) {
    var ingrp, listElem;
    listElem = jQuery("#" + this.elID);
    if (listElem.length) {
      listElem.empty();
    } else {
      listElem = jQuery("<ul id='" + this.elID + "' class='genome-group-list'/>");
      jQuery(this.parentElem).append(listElem);
    }
    ingrp = genomes.grouped(this.elNum);
    this._appendGenomes(listElem, ingrp["public"], genomes.public_genomes);
    this._appendGenomes(listElem, ingrp["private"], genomes.private_genomes);
    return true;
  };

  GroupView.prototype.add = function(genomeSet, genomes) {
    var listElem;
    listElem = jQuery("#" + this.elID);
    if (!listElem.length) {
      listElem = jQuery("<ul id='" + this.elID + "' class='genome-group-list'/>");
      jQuery(this.parentElem).append(listElem);
    }
    if (genomeSet["public"] != null) {
      this._appendGenomes(listElem, genomeSet["public"], genomes.public_genomes);
    }
    if (genomeSet["private"] != null) {
      return this._appendGenomes(listElem, genomeSet["private"], genomes.private_genomes);
    }
  };

  GroupView.prototype._appendGenomes = function(el, visibleG, genomes) {
    var actionEl, cls, g, listEl, _i, _len;
    cls = this.cssClass();
    for (_i = 0, _len = visibleG.length; _i < _len; _i++) {
      g = visibleG[_i];
      listEl = jQuery(("<li class='" + cls + "'>") + genomes[g].viewname + '</li>');
      actionEl = jQuery("<a href='#' data-genome='" + g + "' data-genome-group='" + this.elNum + "'> remove</a>");
      actionEl.click(function(e) {
        var gid, grp;
        e.preventDefault();
        gid = this.dataset.genome;
        grp = this.dataset.genomeGroup;
        console.log('clicked remove on ' + gid);
        return viewController.removeFromGroup(gid, grp);
      });
      listEl.append(actionEl);
      el.append(listEl);
    }
    return true;
  };

  GroupView.prototype.remove = function(gid) {
    var descriptor, linkEl, listEl;
    listEl = jQuery("#" + this.elID);
    if (!((listEl != null) && listEl.length)) {
      throw new SuperphyError("DOM element for group view " + this.elID + " not found. Cannot call GroupView method remove().");
    }
    descriptor = "li > a[data-genome='" + gid + "']";
    linkEl = listEl.find(descriptor);
    if (!((linkEl != null) && linkEl.length)) {
      throw new SuperphyError("List item element for genome " + gid + " not found in GroupView " + this.elID);
      return false;
    }
    linkEl.parent('li').remove();
    return true;
  };

  return GroupView;

})(ViewTemplate);


/*
 CLASS GenomeController
 
 Manages private/public genome list
 */

GenomeController = (function() {
  function GenomeController(public_genomes, private_genomes, subset) {
    var i, newPri, newPub, _i, _len;
    this.public_genomes = public_genomes;
    this.private_genomes = private_genomes;
    if (subset == null) {
      subset = null;
    }
    if (subset != null) {
      newPub = {};
      newPri = {};
      for (_i = 0, _len = subset.length; _i < _len; _i++) {
        i = subset[_i];
        if (this.public_genomes[i] != null) {
          newPub[i] = this.public_genomes[i];
        } else if (this.private_genomes[i] != null) {
          newPri[i] = this.private_genomes[i];
        }
      }
      this.public_genomes = newPub;
      this.private_genomes = newPri;
    }
    this.update();
    this.filter();
  }

  GenomeController.prototype.pubVisible = [];

  GenomeController.prototype.pvtVisible = [];

  GenomeController.prototype.visibleMeta = {
    strain: false,
    serotype: false,
    isolation_host: false,
    isolation_source: false,
    isolation_date: false,
    accession: false,
    syndrome: false,
    stx1_subtype: false,
    stx2_subtype: false
  };

  GenomeController.prototype.metaMap = {
    'strain': 'Strain',
    'serotype': 'Serotype',
    'isolation_host': 'Host',
    'isolation_source': 'Source',
    'isolation_date': 'Date of isolation',
    'accession': 'Accession ID',
    'syndrome': 'Symptom / Disease',
    'stx1_subtype': 'Stx1 Subtype',
    'stx2_subtype': 'Stx2 Subtype'
  };

  GenomeController.prototype.publicRegexp = new RegExp('^public_');

  GenomeController.prototype.privateRegexp = new RegExp('^private_');

  GenomeController.prototype.filtered = 0;

  GenomeController.prototype.update = function() {
    var g, id, _ref, _ref1;
    _ref = this.public_genomes;
    for (id in _ref) {
      g = _ref[id];
      g.viewname = this.label(g, this.visibleMeta);
      g.htmlname = this.labelHTML(g, this.visibleMeta);
    }
    _ref1 = this.private_genomes;
    for (id in _ref1) {
      g = _ref1[id];
      g.viewname = this.label(g, this.visibleMeta);
      g.htmlname = this.labelHTML(g, this.visibleMeta);
    }
    return true;
  };

  GenomeController.prototype.filter = function(searchTerms) {
    var g, i, pubGenomeIds, pvtGenomeIds, results, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    if (searchTerms == null) {
      searchTerms = null;
    }
    pubGenomeIds = [];
    pvtGenomeIds = [];
    if (searchTerms != null) {
      results = this._runFilter(searchTerms);
      pubGenomeIds = results["public"];
      pvtGenomeIds = results["private"];
      this.filtered = pubGenomeIds.length + pvtGenomeIds.length;
      _ref = this.public_genomes;
      for (i in _ref) {
        g = _ref[i];
        g.visible = false;
      }
      _ref1 = this.private_genomes;
      for (i in _ref1) {
        g = _ref1[i];
        g.visible = false;
      }
      for (_i = 0, _len = pubGenomeIds.length; _i < _len; _i++) {
        g = pubGenomeIds[_i];
        this.public_genomes[g].visible = true;
      }
      for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
        g = pvtGenomeIds[_j];
        this.private_genomes[g].visible = true;
      }
    } else {
      pubGenomeIds = Object.keys(this.public_genomes);
      pvtGenomeIds = Object.keys(this.private_genomes);
      this.filtered = 0;
      _ref2 = this.public_genomes;
      for (i in _ref2) {
        g = _ref2[i];
        g.visible = true;
      }
      _ref3 = this.private_genomes;
      for (i in _ref3) {
        g = _ref3[i];
        g.visible = true;
      }
    }
    this.pubVisible = pubGenomeIds.sort((function(_this) {
      return function(a, b) {
        return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
      };
    })(this));
    this.pvtVisible = pvtGenomeIds.sort((function(_this) {
      return function(a, b) {
        return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
      };
    })(this));
    return true;
  };

  GenomeController.prototype.filterBySelection = function() {
    var g, gset, i, pubGenomeIds, pvtGenomeIds, _i, _j, _len, _len1, _ref, _ref1;
    gset = this.selected();
    pubGenomeIds = gset["public"];
    pvtGenomeIds = gset["private"];
    this.filtered = pubGenomeIds.length + pvtGenomeIds.length;
    if (this.filtered === 0) {
      this.filter();
    } else {
      _ref = this.public_genomes;
      for (i in _ref) {
        g = _ref[i];
        g.visible = false;
      }
      _ref1 = this.private_genomes;
      for (i in _ref1) {
        g = _ref1[i];
        g.visible = false;
      }
      for (_i = 0, _len = pubGenomeIds.length; _i < _len; _i++) {
        g = pubGenomeIds[_i];
        this.public_genomes[g].visible = true;
        this.public_genomes[g].isSelected = false;
      }
      for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
        g = pvtGenomeIds[_j];
        this.private_genomes[g].visible = true;
        this.private_genomes[g].isSelected = false;
      }
      this.pubVisible = pubGenomeIds.sort((function(_this) {
        return function(a, b) {
          return cmp(_this.public_genomes[a].viewname, _this.public_genomes[b].viewname);
        };
      })(this));
      this.pvtVisible = pvtGenomeIds.sort((function(_this) {
        return function(a, b) {
          return cmp(_this.private_genomes[a].viewname, _this.private_genomes[b].viewname);
        };
      })(this));
    }
    return true;
  };

  GenomeController.prototype._runFilter = function(searchTerms) {
    var firstTerm, id, pubGenomeIds, pubSet, pvtGenomeIds, pvtSet, regex, t, _i, _len;
    if (!typeIsArray(searchTerms)) {
      throw new SuperphyError('Invalid argument. GenomeController method _runFilter() requires array of search term objects as input.');
    }
    pubGenomeIds = Object.keys(this.public_genomes);
    pvtGenomeIds = Object.keys(this.private_genomes);
    firstTerm = true;
    for (_i = 0, _len = searchTerms.length; _i < _len; _i++) {
      t = searchTerms[_i];
      console.log(t);
      if (firstTerm) {
        if (t.op != null) {
          throw new SuperphyError("Invalid filter input. First search term object cannot contain an operator property 'op'.");
        }
        if (t.dataField !== 'isolation_date') {
          if (t.searchTerm == null) {
            throw new SuperphyError("Invalid filter input. Search term objects must contain a 'searchTerm' property.");
          }
          if (t.dataField == null) {
            throw new SuperphyError("Invalid filter input. Search term objects must contain a 'dataField' property.");
          }
          if (t.negate == null) {
            throw new SuperphyError("Invalid filter input. Search term objects must contain a 'negate' property.");
          }
        } else {
          if (t.dataField == null) {
            throw new SuperphyError("Invalid filter input. Date objects must contain a 'searchTerm' property.");
          }
          if (t.date == null) {
            throw new SuperphyError("Invalid filter input. Date objects must contain a 'date' property.");
          }
          if (t.before == null) {
            throw new SuperphyError("Invalid filter input. Date objects must contain a 'before' property.");
          }
        }
        firstTerm = false;
      } else {
        if (t.op == null) {
          throw new SuperphyError("Invalid filter input. Subsequent search term objects must contain an operator property 'op'.");
        }
      }
      if ((t.op != null) && t.op === 'or') {
        pubSet = [];
        pubSet = [];
        if (t.dataField === 'isolation_date') {
          pubSet = (function() {
            var _j, _len1, _ref, _results;
            _ref = Object.keys(this.public_genomes);
            _results = [];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              id = _ref[_j];
              if (this.passDate(this.public_genomes[id], t.before, t.date)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
          pvtSet = (function() {
            var _j, _len1, _ref, _results;
            _ref = Object.keys(this.private_genomes);
            _results = [];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              id = _ref[_j];
              if (this.passDate(this.private_genomes[id], t.before, t.date)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
        } else {
          regex = new RegExp(escapeRegExp(t.searchTerm), "i");
          pubSet = (function() {
            var _j, _len1, _ref, _results;
            _ref = Object.keys(this.public_genomes);
            _results = [];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              id = _ref[_j];
              if (this.match(this.public_genomes[id], t.dataField, regex, t.negate)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
          pvtSet = (function() {
            var _j, _len1, _ref, _results;
            _ref = Object.keys(this.private_genomes);
            _results = [];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              id = _ref[_j];
              if (this.match(this.private_genomes[id], t.dataField, regex, t.negate)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
        }
        pubGenomeIds = this.union(pubGenomeIds, pubSet);
        pvtGenomeIds = this.union(pvtGenomeIds, pvtSet);
      } else {
        if (t.dataField === 'isolation_date') {
          pubSet = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = pubGenomeIds.length; _j < _len1; _j++) {
              id = pubGenomeIds[_j];
              if (this.passDate(this.public_genomes[id], t.before, t.date)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
          pvtSet = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
              id = pvtGenomeIds[_j];
              if (this.passDate(this.private_genomes[id], t.before, t.date)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
          pubGenomeIds = pubSet;
          pvtGenomeIds = pvtSet;
        } else {
          regex = new RegExp(escapeRegExp(t.searchTerm), "i");
          pubSet = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = pubGenomeIds.length; _j < _len1; _j++) {
              id = pubGenomeIds[_j];
              if (this.match(this.public_genomes[id], t.dataField, regex, t.negate)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
          pvtSet = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = pvtGenomeIds.length; _j < _len1; _j++) {
              id = pvtGenomeIds[_j];
              if (this.match(this.private_genomes[id], t.dataField, regex, t.negate)) {
                _results.push(id);
              }
            }
            return _results;
          }).call(this);
          pubGenomeIds = pubSet;
          pvtGenomeIds = pvtSet;
        }
      }
    }
    return {
      "public": pubGenomeIds,
      "private": pvtGenomeIds
    };
  };

  GenomeController.prototype.match = function(genome, key, regex, negate) {
    var val;
    if (genome[key] == null) {
      return false;
    }
    val = genome[key];
    if (typeIsArray(genome[key])) {
      val = genome[key].toString();
    }
    if (regex.test(val)) {
      if (!negate) {
        return true;
      } else {
        return false;
      }
    } else {
      if (negate) {
        return true;
      } else {
        return false;
      }
    }
  };

  GenomeController.prototype.passDate = function(genome, before, date) {
    var d2, val;
    if (genome['isolation_date'] == null) {
      return false;
    }
    val = genome['isolation_date'][0];
    d2 = Date.parse(val);
    if (before) {
      if (d2 < date) {
        return true;
      } else {
        return false;
      }
    } else {
      if (d2 > date) {
        return true;
      } else {
        return false;
      }
    }
  };

  GenomeController.prototype.union = function(arr1, arr2) {
    var arr, i, _i, _len, _ref;
    arr = [];
    _ref = arr1.concat(arr2);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      if (__indexOf.call(arr, i) < 0) {
        arr.push(i);
      }
    }
    return arr;
  };

  GenomeController.prototype.label = function(genome, visibleMeta, joinStr) {
    var lab, mtypes, na, t, _i, _len, _ref, _ref1;
    if (joinStr == null) {
      joinStr = '|';
    }
    na = 'NA';
    lab = [genome.displayname];
    mtypes = ['strain', 'serotype', 'isolation_host', 'isolation_source', 'isolation_date', 'syndrome', 'stx1_subtype', 'stx2_subtype'];
    for (_i = 0, _len = mtypes.length; _i < _len; _i++) {
      t = mtypes[_i];
      if (visibleMeta[t]) {
        lab.push(((_ref = genome[t]) != null ? _ref : [na]).join(' '));
      }
    }
    if (visibleMeta.accession) {
      lab.push((_ref1 = genome.primary_dbxref) != null ? _ref1 : na);
    }
    return lab.join(joinStr);
  };

  GenomeController.prototype.labelHTML = function(genome, visibleMeta, joinStr) {
    var i, lab, mtypes, na, t, _i, _j, _len, _len1, _ref, _ref1;
    if (joinStr == null) {
      joinStr = ' ';
    }
    na = 'NA';
    lab = [genome.displayname];
    mtypes = ['strain', 'serotype', 'isolation_host', 'isolation_source', 'isolation_date', 'syndrome', 'stx1_subtype', 'stx2_subtype'];
    for (_i = 0, _len = mtypes.length; _i < _len; _i++) {
      t = mtypes[_i];
      if (visibleMeta[t]) {
        if (genome[t] != null) {
          _ref = genome[t];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            i = _ref[_j];
            lab.push('<span class="label label-default">' + i + '</span>');
          }
        } else {
          lab.push('<span class="label label-default">' + [na] + '</span>');
        }
      }
    }
    if (visibleMeta.accession) {
      lab.push((_ref1 = genome.primary_dbxref) != null ? _ref1 : na);
    }
    return lab.join(joinStr);
  };

  GenomeController.prototype.updateMeta = function(option, checked) {
    console.log(option);
    if (this.visibleMeta[option] == null) {
      throw new SuperphyError('unrecognized option in GenomeController method updateMeta()');
      return false;
    }
    if (!(checked === true || checked === false)) {
      throw new SuperphyError('invalid checked argument in GenomeController method updateMeta()');
      return false;
    }
    this.visibleMeta[option] = checked;
    this.update();
    return true;
  };

  GenomeController.prototype.select = function(g, checked) {
    if (this.publicRegexp.test(g)) {
      this.public_genomes[g].isSelected = checked;
      alert('selected public: ' + g + ' value:' + checked);
    } else {
      this.private_genomes[g].isSelected = checked;
      alert('selected private: ' + g + ' value:' + checked);
    }
    return true;
  };

  GenomeController.prototype.selected = function() {
    var k, pub, pvt, v;
    pub = [];
    pvt = [];
    pub = (function() {
      var _ref, _results;
      _ref = this.public_genomes;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        if ((v.isSelected != null) && v.isSelected === true) {
          _results.push(k);
        }
      }
      return _results;
    }).call(this);
    pvt = (function() {
      var _ref, _results;
      _ref = this.private_genomes;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        if ((v.isSelected != null) && v.isSelected === true) {
          _results.push(k);
        }
      }
      return _results;
    }).call(this);
    return {
      "public": pub,
      "private": pvt
    };
  };

  GenomeController.prototype.unselectAll = function() {
    var k, v, _ref, _ref1, _results;
    _ref = this.public_genomes;
    for (k in _ref) {
      v = _ref[k];
      if (v.isSelected != null) {
        v.isSelected = false;
      }
    }
    _ref1 = this.private_genomes;
    _results = [];
    for (k in _ref1) {
      v = _ref1[k];
      if (v.isSelected != null) {
        _results.push(v.isSelected = false);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  GenomeController.prototype.assignGroup = function(gset, grpNum) {
    var cls, g, _i, _j, _len, _len1, _ref, _ref1;
    if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
      _ref = gset["public"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        g = _ref[_i];
        this.public_genomes[g].assignedGroup = grpNum;
        cls = 'genome_group' + grpNum;
        this.public_genomes[g].cssClass = cls;
      }
    }
    if ((gset["private"] != null) && typeof gset["private"] !== 'undefined') {
      _ref1 = gset["private"];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        g = _ref1[_j];
        this.private_genomes[g].assignedGroup = grpNum;
        cls = 'genome_group' + grpNum;
        this.private_genomes[g].cssClass = cls;
      }
    }
    return true;
  };

  GenomeController.prototype.deleteGroup = function(gset) {
    var g, _i, _j, _len, _len1, _ref, _ref1;
    if ((gset["public"] != null) && typeof gset["public"] !== 'undefined') {
      _ref = gset["public"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        g = _ref[_i];
        this.public_genomes[g].assignedGroup = null;
        this.public_genomes[g].cssClass = null;
      }
    }
    if ((gset["private"] != null) && typeof gset["public"] !== 'undefined') {
      _ref1 = gset["private"];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        g = _ref1[_j];
        this.private_genomes[g].assignedGroup = null;
        this.private_genomes[g].cssClass = null;
      }
    }
    return true;
  };

  GenomeController.prototype.grouped = function(grpNum) {
    var k, pub, pvt, v;
    pub = [];
    pvt = [];
    pub = (function() {
      var _ref, _results;
      _ref = this.public_genomes;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        if ((v.assignedGroup != null) && v.assignedGroup === grpNum) {
          _results.push(k);
        }
      }
      return _results;
    }).call(this);
    pvt = (function() {
      var _ref, _results;
      _ref = this.private_genomes;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        if ((v.assignedGroup != null) && v.assignedGroup === grpNum) {
          _results.push(k);
        }
      }
      return _results;
    }).call(this);
    return {
      "public": pub,
      "private": pvt
    };
  };

  GenomeController.prototype.genomeSet = function(gids) {
    var g, pub, pvt;
    pub = [];
    pvt = [];
    pub = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = gids.length; _i < _len; _i++) {
        g = gids[_i];
        if (this.publicRegexp.test(g)) {
          _results.push(g);
        }
      }
      return _results;
    }).call(this);
    pvt = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = gids.length; _i < _len; _i++) {
        g = gids[_i];
        if (this.privateRegexp.test(g)) {
          _results.push(g);
        }
      }
      return _results;
    }).call(this);
    return {
      "public": pub,
      "private": pvt
    };
  };

  GenomeController.prototype.genome = function(gid) {
    if (this.publicRegexp.test(gid)) {
      return this.public_genomes[gid];
    } else {
      return this.private_genomes[gid];
    }
  };

  return GenomeController;

})();


/*
 CLASS LocusController
 
 Manages locus data
 */

LocusController = (function() {
  function LocusController(locusData) {
    this.locusData = locusData;
    this.dataValues = {};
    this.format();
  }

  LocusController.prototype.emptyString = "<span class='locus_group0'>NA</span>";

  LocusController.prototype.format = function() {
    var dataGroup, g, grpNum, k, o, val, _ref;
    for (g in this.locusData) {
      _ref = this.locusData[g];
      for (k in _ref) {
        o = _ref[k];
        val = o.data;
        dataGroup = 0;
        if (this.dataValues[val] != null) {
          dataGroup = this.dataValues[val];
        } else {
          grpNum = Object.keys(this.dataValues).length;
          grpNum++;
          this.dataValues[val] = grpNum;
          dataGroup = grpNum;
        }
        o.cls = "locus_group" + dataGroup;
        o.group = dataGroup;
        o.dataString = "<span class='" + o.cls + "'>" + val + "</span>";
      }
    }
    return true;
  };

  LocusController.prototype.locusString = function(id, locusID) {
    var g, genomeID, l, res, str;
    if (locusID == null) {
      locusID = null;
    }
    genomeID;
    if (locusID != null) {
      genomeID = id;
    } else {
      res = parseHeader(id);
      genomeID = res[1];
      locusID = res[2];
      if (!((genomeID != null) && (locusID != null))) {
        throw new SuperphyError("Invalid locus ID format: " + id + ".");
      }
    }
    g = this.locusData[genomeID];
    if (g == null) {
      throw new SuperphyError("Unknown genome: " + genomeID + ".");
    }
    l = g[locusID];
    if (l == null) {
      throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
    }
    str;
    if (l.copy > 1) {
      str = " (" + l.copy + " copy) -  " + l.dataString;
    } else {
      str = ' - ' + l.dataString;
    }
    return str;
  };

  LocusController.prototype.locusNode = function(id, locusID) {
    var g, genomeID, l, res, str;
    if (locusID == null) {
      locusID = null;
    }
    genomeID;
    if (locusID != null) {
      genomeID = id;
    } else {
      res = parseHeader(id);
      genomeID = res[1];
      locusID = res[2];
      if (!((genomeID != null) && (locusID != null))) {
        throw new SuperphyError("Invalid locus ID format: " + id + ".");
      }
    }
    g = this.locusData[genomeID];
    if (g == null) {
      throw new SuperphyError("Unknown genome: " + genomeID + ".");
    }
    l = g[locusID];
    if (l == null) {
      throw new SuperphyError("Unknown locus: " + locusID + " for genome " + genomeID + ".");
    }
    str;
    if (l.copy > 1) {
      str = " (" + l.copy + " copy) -  " + l.data;
    } else {
      str = ' - ' + l.data;
    }
    return [str, l.group];
  };

  LocusController.prototype.genomeString = function(genomeID) {
    var ds, g, k, str, v;
    str = ' - ';
    g = this.locusData[genomeID];
    if (g != null) {
      ds = (function() {
        var _results;
        _results = [];
        for (k in g) {
          v = g[k];
          _results.push(v.dataString);
        }
        return _results;
      })();
      str += ds.join(',');
    } else {
      str += this.emptyString;
    }
    return str;
  };

  LocusController.prototype.count = function(genomes) {
    var uniqueValues;
    uniqueValues = {
      'NA': 0
    };
    this._count(genomes.pubVisible, uniqueValues);
    this._count(genomes.pvtVisible, uniqueValues);
    return uniqueValues;
  };

  LocusController.prototype._count = function(genomeList, uniqueValues) {
    var g, gID, k, v, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = genomeList.length; _i < _len; _i++) {
      gID = genomeList[_i];
      g = this.locusData[gID];
      if (g != null) {
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (k in g) {
            v = g[k];
            if (uniqueValues[v.data] != null) {
              _results1.push(uniqueValues[v.data]++);
            } else {
              _results1.push(uniqueValues[v.data] = 1);
            }
          }
          return _results1;
        })());
      } else {
        _results.push(uniqueValues['NA']++);
      }
    }
    return _results;
  };

  return LocusController;

})();

if (!root.LocusController) {
  root.LocusController = LocusController;
}


/*

  HELPER FUNCTIONS
 */

parseHeader = function(str) {
  var match;
  match = /^((?:public|private)_\d+)\|(\d+)/.exec(str);
  return match;
};

typeIsArray = Array.isArray || function(value) {
  return {}.toString.call(value) === '[object Array]';
};

escapeRegExp = function(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
};

cmp = function(a, b) {
  if (a > b) {
    return 1;
  } else if (a < b) {
    return -1;
  } else {
    return 0;
  }
};

trimInput = function(str, field) {
  var term;
  if (str != null) {
    term = jQuery.trim(str);
    if (term.length) {
      return term;
    } else {
      alert("Error: " + field + " is empty.");
      return null;
    }
  } else {
    alert("Error: " + field + " is empty.");
    return null;
  }
};
