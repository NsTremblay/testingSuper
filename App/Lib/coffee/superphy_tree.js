// Generated by CoffeeScript 1.7.1

/*


 File: superphy_tree.coffee
 Desc: Phylogenetic Tree View Class
 Author: Matt Whiteside matthew.whiteside@phac-aspc.gc.ca
 Date: March 20th, 2013
 */


/*
 CLASS TreeView
  
 Phylogenetic tree view
 */

(function() {
  var TreeView,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  TreeView = (function(_super) {
    __extends(TreeView, _super);

    function TreeView(parentElem, style, elNum, treeArgs) {
      this.parentElem = parentElem;
      this.style = style;
      this.elNum = elNum;
      if (!(treeArgs.length > 0)) {
        throw new SuperphyError('Missing argument. TreeView constructor requires JSON tree object.');
      }
      this.root = treeArgs[0];
      this.dim = {
        w: 500,
        h: 800
      };
      this.margin = {
        top: 20,
        right: 180,
        bottom: 20,
        left: 20
      };
      if (treeArgs[1] != null) {
        this.dim = treeArgs[1];
      }
      if (treeArgs[2] != null) {
        this.margin = treeArgs[2];
      }
      TreeView.__super__.constructor.call(this, this.parentElem, this.style, this.elNum);
      this.width = this.dim.w - this.margin.right - this.margin.left;
      this.height = this.dim.h - this.margin.top - this.margin.bottom;
      this.xzoom = d3.scale.linear().domain([0, this.width]).range([0, this.width]);
      this.yzoom = d3.scale.linear().domain([0, this.height]).range([0, this.height]);
      this.cluster = d3.layout.cluster().size([this.width, this.height]).sort(null).value(function(d) {
        return Number(d.length);
      }).separation(function(a, b) {
        return 1;
      });
      this.parentElem.append("<div id='tree-viewport'></div>");
      this.wrap = d3.select("#tree-viewport").append("svg").attr("width", this.dim.w).attr("height", this.dim.h).style("-webkit-backface-visibility", "hidden");
      this.canvas = this.wrap.append("g").attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");
      this.wrap.call(d3.behavior.zoom().x(this.xzoom).y(this.yzoom).scaleExtent([1, 8]).on("zoom", TreeView.zoomed));
      this.root.x0 = this.height / 2;
      this.root.y0 = 0;
      this._assignKeys(this.root, 0);
      true;
    }

    TreeView.prototype.type = 'tree';

    TreeView.prototype.elName = 'genome_tree';

    TreeView.prototype.nodeId = 0;

    TreeView.prototype.duration = 1000;

    TreeView.prototype.update = function(genomes, sourceNode) {
      var branch_scale_factor_x, branch_scale_factor_y, cmdBox, dt, farthest, focusNode, leaves, linksEnter, lowest, n, nodeExit, nodeUpdate, nodesEnter, svgLinks, svgNodes, t1, t2, _i, _j, _len, _len1, _ref;
      if (sourceNode == null) {
        sourceNode = null;
      }
      t1 = new Date();
      this._sync(genomes);
      if (sourceNode == null) {
        sourceNode = this.currRoot;
      }
      this.nodes = this.cluster.nodes(this.currRoot);
      farthest = d3.max(this.nodes, function(d) {
        return d.sum_length * 1;
      });
      lowest = d3.max(this.nodes, function(d) {
        return d.x;
      });
      branch_scale_factor_y = (this.width - 20) / farthest;
      branch_scale_factor_x = (this.height - 20) / lowest;
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        n.y = n.sum_length * branch_scale_factor_y;
        n.x = n.x * branch_scale_factor_x;
      }
      svgNodes = this.canvas.selectAll("g.node").data(this.nodes, function(d) {
        return d.id;
      });
      svgLinks = this.canvas.selectAll("path.link").data(this.cluster.links(this.nodes), function(d) {
        return d.target.id;
      });
      linksEnter = svgLinks.enter().insert("path").attr("class", "link").attr("d", (function(_this) {
        return function(d) {
          var p;
          p = {
            x: sourceNode.x0,
            y: sourceNode.y0
          };
          return _this._step({
            source: p,
            target: p
          });
        };
      })(this));
      svgLinks.transition().duration(this.duration).attr("d", this._step);
      svgLinks.exit().transition().duration(this.duration).attr("d", (function(_this) {
        return function(d) {
          var o;
          o = {
            x: sourceNode.x,
            y: sourceNode.y
          };
          return _this._step({
            source: o,
            target: o
          });
        };
      })(this)).remove();
      nodesEnter = svgNodes.enter().append("g").attr("class", "node").attr("id", function(d) {
        return "node" + d.id;
      }).attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + sourceNode.y0 + "," + sourceNode.x0 + ")";
        };
      })(this));
      leaves = nodesEnter.filter(function(d) {
        return d.leaf;
      });
      leaves.append("circle").attr("r", 1e-6).style("fill", function(d) {
        var _ref1;
        return (_ref1 = d.selected) != null ? _ref1 : {
          "lightsteelblue": "#fff"
        };
      });
      nodeEnter.append("text").attr("dx", ".6em").attr("dy", ".4em").attr("text-anchor", "start").text(function(d) {
        if (d.leaf) {
          return d.viewname;
        } else {
          return d.label;
        }
      }).style("fill-opacity", 1e-6);
      focusNode = nodeEnter.filter(function(d) {
        return d.focus;
      });
      focusNode.select("circle").attr('id', 'focusNodeCircle');
      focusNode.select("text").attr('id', 'focusNodeText');
      cmdBox = nodeEnter.filter(function(n) {
        return !n.leaf;
      }).append("rect").attr("width", 1e-6).attr("height", 1e-6).attr("y", -4).attr("x", -14).style("fill", "#fff");
      nodeUpdate = node.transition().duration(this.duration).attr("transform", function(d) {
        return "translate(" + d.y + "," + d.x + ")";
      });
      nodeUpdate.select("circle").attr("r", 4);
      nodeUpdate.filter(function(d) {
        return !d.children;
      }).select("text").style("fill-opacity", 1);
      nodeUpdate.select("rect").attr("width", 8).attr("height", 8).style("fill", function(d) {
        var _ref1;
        return (_ref1 = d._children) != null ? _ref1 : {
          "lightsteelblue": "#fff"
        };
      });
      nodeExit = node.exit().transition().duration(duration).attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + _this.sourceNode.y + "," + _this.sourceNode.x + ")";
        };
      })(this)).remove();
      nodeExit.select("circle").attr("r", 1e-6);
      nodeExit.select("text").style("fill-opacity", 1e-6);
      nodeExit.select("rect").attr("width", 1e-6).attr("height", 1e-6);
      for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
        n = nodes[_j];
        n.x0 = n.x;
        n.y0 = n.y;
      }
      t2 = new Date();
      dt = new Date(t2 - t1);
      console.log('TreeView update elapsed time (sec): ' + dt.getSeconds());
      return true;
    };

    TreeView.prototype._step = function(d) {
      return "M" + d.source.y + "," + d.source.x + "L" + d.source.y + "," + d.target.x + "L" + d.target.y + "," + d.target.x;
    };

    TreeView.prototype._stepTranslate = function(d) {
      var sourceX, sourceY, targetX, targetY;
      sourceX = this.xzoom(d.source.y);
      sourceY = this.yzoom(d.source.x);
      targetX = this.xzoom(d.target.y);
      targetY = this.yzoom(d.target.x);
      return "M" + sourceX + "," + sourceY + "L" + sourceX + "," + targetY + "L" + targetX + "," + targetY;
    };

    TreeView.prototype._assignKeys = function(n, i) {
      var m, _i, _j, _len, _len1, _ref, _ref1;
      n.id = i;
      i++;
      if (n.children != null) {
        _ref = n.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          m = _ref[_i];
          i = this._assignKeys(m, i);
        }
      }
      if (n._children != null) {
        _ref1 = n._children;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          m = _ref1[_j];
          i = this._assignKeys(m, i);
        }
      }
      return i;
    };

    TreeView.prototype._sync = function(genomes) {
      this.currRoot = this._syncNode(this.root, genomes);
      return true;
    };

    TreeView.prototype._syncNode = function(node, genomes) {
      var g, m, n, syncNode, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      syncNode = this._cloneNode(node);
      if ((node.leaf != null) && node.leaf === "true") {
        g = genomes.genome(node.name);
        if (g.visible) {
          syncNode = node;
          syncNode.viewname = g.viewname;
          syncNode.selected = (_ref = (g.isSelected != null) && g.isSelected) != null ? _ref : {
            "true": false
          };
          syncNode.cssClass = g.cssClass;
        } else {
          syncNode = null;
        }
      } else {
        if (node.children != null) {
          syncNode.children = [];
          _ref1 = node.children;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            n = _ref1[_i];
            m = this._syncNode(n, genomes);
            if (m != null) {
              syncNode.children.push(m);
            }
          }
          if (syncNode.children.length === 0) {
            syncNode = null;
          }
        } else if (node._children != null) {
          syncNode._children = [];
          _ref2 = node._children;
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            n = _ref2[_j];
            m = this._syncNode(n, genomes);
            if (m != null) {
              syncNode._children.push(m);
            }
          }
          if (syncNode._children.length === 0) {
            syncNode = null;
          }
        }
      }
      return syncNode;
    };

    TreeView.prototype._cloneNode = function(node) {
      var copy, k, v;
      copy = {};
      if (!(function() {
        var _results;
        _results = [];
        for (k in node) {
          v = node[k];
          _results.push(k === 'children' || k === '_children');
        }
        return _results;
      })()) {
        copy[k] = v;
      }
      return copy;
    };


    /*
    
    _appendGenomes: (el, visibleG, genomes, style) ->
      
       * View class
      cls = @cssClass()
      
      for g in visibleG
        
        thiscls = cls
        thiscls = cls+' '+genomes[g].cssClass if genomes[g].cssClass?
        
        if style == 'redirect'
           * Links
          
           * Create elements
          listEl = jQuery("<li class='#{thiscls}'>"+genomes[g].viewname+'</li>')
          actionEl = jQuery("<a href='#' data-genome='#{g}'><i class='icon-search'></i> info</a>")
          
           * Set behaviour
          actionEl.click (e) ->
            e.preventDefault()
            gid = @.dataset.genome
            viewController.redirect(gid)
          
           * Append to list
          listEl.append(actionEl)
          el.append(listEl)
          
        else if style == 'select'
           * Checkboxes
          
           * Create elements
          checked = ''
          checked = 'checked' if genomes[g].isSelected
          listEl = jQuery("<li class='#{thiscls}'></li>")
          labEl = jQuery("<label class='checkbox'>"+genomes[g].viewname+"</label>")
          actionEl = jQuery("<input class='checkbox' type='checkbox' value='#{g}' #{checked}/>")
          
           * Set behaviour
          actionEl.change (e) ->
            e.preventDefault()
            viewController.select(@.value, @.checked)
          
           * Append to list
          labEl.append(actionEl)
          listEl.append(labEl)
          el.append(listEl)
          
        else
          return false
        
      true
      
     * FUNC updateCSS
     * Change CSS class for selected genomes to match underlying genome properties
     *
     * PARAMS
     * simple hash object with private and public list of genome Ids to update
     * genomeController object
     * 
     * RETURNS
     * boolean 
     *      
    updateCSS: (gset, genomes) ->
      
       * Retrieve list DOM element    
      listEl = jQuery("##{@elID}")
      throw new SuperphyError "DOM element for list view #{@elID} not found. Cannot call ListView method updateCSS()." unless listEl? and listEl.length
      
       * append genomes to list
      @_updateGenomeCSS(listEl, gset.public, genomes.public_genomes) if gset.public? and typeof gset.public isnt 'undefined'
      
      @_updateGenomeCSS(listEl, gset.private, genomes.private_genomes) if gset.private? and typeof gset.private isnt 'undefined'
      
      true # return success
      
    
    _updateGenomeCSS: (el, changedG, genomes) ->
      
       * View class
      cls = @cssClass()
      
      for g in changedG
        
        thiscls = cls
        thiscls = cls+' '+ genomes[g].cssClass if genomes[g].cssClass?
        itemEl = null
        
        if @style == 'redirect'
           * Link style
          
           * Find element
          descriptor = "li > a[data-genome='#{g}']"
          itemEl = el.find(descriptor)
         
        else if @style == 'select'
           * Checkbox style
          
           * Find element
          descriptor = "li input[value='#{g}']"
          itemEl = el.find(descriptor)
     
        else
          return false
        
        unless itemEl? and itemEl.length
          throw new SuperphyError "List element for genome #{g} not found in ListView #{@elID}"
          return false
        
        console.log("Updating class to #{thiscls}")
        liEl = itemEl.parents().eq(1)
         *console.log("Current class for list li: "+liEl.class)  
        liEl.attr('class', thiscls)
         *console.log("Updated class for list li: "+liEl.class())  
          
          
      true # success
    
     * FUNC dump
     * Generate CSV tab-delimited representation of all genomes and meta-data
     *
     * PARAMS
     * genomeController object
     * 
     * RETURNS
     * object containing:
     *   ext[string] - a suitable file extension (e.g. csv)
     *   type[string] - a MIME type
     *   data[string] - a string containing data in final format
     *      
    dump: (genomes) ->
      
       * Create complete list of meta-types
       * make all visible
      fullMeta = {}
      fullMeta[k] = true for k of genomes.visibleMeta
      
      output = ''
       * Output header
      header = (genomes.metaMap[k] for k of fullMeta)
      header.unshift "Genome name"
      output += "#" + header.join("\t") + "\n"
      
       * Output public set
      for id,g of genomes.public_genomes
        output += genomes.label(g,fullMeta,"\t") + "\n"
        
       * Output private set
      for id,g of genomes.private_genomes
        output += genomes.label(g,fullMeta,"\t") + "\n"
        
      return {
        ext: 'csv'
        type: 'text/plain'
        data: output 
      }
     */

    return TreeView;

  })(ViewTemplate);

}).call(this);
